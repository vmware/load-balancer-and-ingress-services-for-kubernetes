/*
 * Copyright ¬© 2025 Broadcom Inc. and/or its subsidiaries. All Rights Reserved.
 * All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*   http://www.apache.org/licenses/LICENSE-2.0
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

// @AI-Generated
// This test file was generated by Claude AI assistant.

package infratests

import (
	"context"
	"encoding/json"
	"fmt"
	"testing"
	"time"

	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-infra/addon"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-infra/ingestion"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-infra/webhook"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/lib"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/utils"

	"github.com/onsi/gomega"
	admissionv1 "k8s.io/api/admission/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/types"
	dynamicfake "k8s.io/client-go/dynamic/fake"
	k8sfake "k8s.io/client-go/kubernetes/fake"
)

// VKS GVRs for testing
var (
	SupervisorCapabilityGVR = schema.GroupVersionResource{
		Group:    "run.tanzu.vmware.com",
		Version:  "v1alpha3",
		Resource: "supervisorcapabilities",
	}
	AddonInstallGVR = schema.GroupVersionResource{
		Group:    "addons.kubernetes.vmware.com",
		Version:  "v1alpha1",
		Resource: "addoninstalls",
	}
	ClusterGVR = schema.GroupVersionResource{
		Group:    "cluster.x-k8s.io",
		Version:  "v1beta2",
		Resource: "clusters",
	}
)

// setupVKSIntegrationTest sets up the environment for VKS integration tests
func setupVKSIntegrationTest(t *testing.T) (*k8sfake.Clientset, *dynamicfake.FakeDynamicClient) {
	kubeClient := k8sfake.NewSimpleClientset()

	// Create avi-secret with admin credentials
	aviSecret := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      lib.AviSecret,
			Namespace: utils.GetAKONamespace(),
		},
		Type: corev1.SecretTypeOpaque,
		Data: map[string][]byte{
			"username":                 []byte("admin"),
			"password":                 []byte("admin123"),
			"authtoken":                []byte("test-auth-token-12345"),
			"certificateAuthorityData": []byte("-----BEGIN CERTIFICATE-----\nMIICertificateData...\n-----END CERTIFICATE-----"),
		},
	}
	_, err := kubeClient.CoreV1().Secrets(utils.GetAKONamespace()).Create(context.Background(), aviSecret, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create avi-secret: %v", err)
	}

	// Set up dynamic client with custom list kinds
	gvrToKind := map[schema.GroupVersionResource]string{
		SupervisorCapabilityGVR: "supervisorcapabilitiesList",
		AddonInstallGVR:         "addoninstallsList",
		ClusterGVR:              "clustersList",
	}

	dynamicClient := dynamicfake.NewSimpleDynamicClientWithCustomListKinds(runtime.NewScheme(), gvrToKind)
	lib.SetDynamicClientSet(dynamicClient)
	lib.NewDynamicInformers(dynamicClient, true)

	// Set controller IP for testing
	lib.SetControllerIP("10.10.10.10")

	return kubeClient, dynamicClient
}

// createVKSSupervisorCapability creates a VKS SupervisorCapability resource
func createVKSSupervisorCapability(name string) *unstructured.Unstructured {
	return &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "run.tanzu.vmware.com/v1alpha3",
			"kind":       "SupervisorCapability",
			"metadata": map[string]interface{}{
				"name": name,
			},
			"spec": map[string]interface{}{
				"capability": "ako_vks",
				"version":    "v1.12.1",
			},
		},
	}
}

// createClusterResource creates a cluster.x-k8s.io Cluster resource
func createClusterResource(name, namespace, phase string, managed bool) *unstructured.Unstructured {
	cluster := &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "cluster.x-k8s.io/v1beta2",
			"kind":       "Cluster",
			"metadata": map[string]interface{}{
				"name":      name,
				"namespace": namespace,
			},
			"status": map[string]interface{}{
				"phase": phase,
			},
		},
	}

	if managed {
		cluster.SetLabels(map[string]string{
			webhook.VKSManagedLabel: webhook.VKSManagedLabelValueTrue,
		})
	}

	return cluster
}

// TestVKSCapabilityToAddonFlow tests the full flow from VKS capability enablement to addon creation
func TestVKSCapabilityToAddonFlow(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	_, dynamicClient := setupVKSIntegrationTest(t)

	// Step 1: Create VKS SupervisorCapability
	capability := createVKSSupervisorCapability("ako-vks")
	_, err := dynamicClient.Resource(SupervisorCapabilityGVR).Create(context.Background(), capability, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create SupervisorCapability: %v", err)
	}

	// Step 2: Ensure global addon install is created
	err = addon.EnsureGlobalAddonInstall()
	if err != nil {
		t.Fatalf("Failed to ensure global addon install: %v", err)
	}

	// Step 3: Verify AddonInstall resource was created
	g.Eventually(func() bool {
		addonInstall, err := dynamicClient.Resource(AddonInstallGVR).
			Namespace(addon.VKSPublicNamespace).
			Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
		if err != nil {
			t.Logf("AddonInstall not found: %v", err)
			return false
		}

		// Verify basic addon structure
		name, _, _ := unstructured.NestedString(addonInstall.Object, "metadata", "name")
		namespace, _, _ := unstructured.NestedString(addonInstall.Object, "metadata", "namespace")

		return name == addon.AKOAddonInstallName && namespace == addon.VKSPublicNamespace
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))

	t.Log("‚úÖ VKS Capability to Addon flow completed successfully")
}

// TestVKSWebhookFunctionality tests the VKS webhook validation and labeling
func TestVKSWebhookFunctionality(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, _ := setupVKSIntegrationTest(t)

	// Create a namespace with ServiceEngineGroup annotation
	namespace := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "test-cluster-ns",
			Annotations: map[string]string{
				"ako.vmware.com/wcp-se-group": "test-se-group",
			},
		},
	}
	_, err := kubeClient.CoreV1().Namespaces().Create(context.Background(), namespace, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create namespace: %v", err)
	}

	// Create VKS webhook
	webhook := webhook.NewVKSClusterWebhook(kubeClient)

	// Test cluster that should be managed by VKS
	clusterObj := createClusterResource("test-cluster", "test-cluster-ns", "Provisioned", false)
	clusterBytes, _ := json.Marshal(clusterObj)

	admissionRequest := &admissionv1.AdmissionRequest{
		UID:       types.UID("test-uid"),
		Kind:      metav1.GroupVersionKind{Group: "cluster.x-k8s.io", Version: "v1beta2", Kind: "Cluster"},
		Namespace: "test-cluster-ns",
		Object:    runtime.RawExtension{Raw: clusterBytes},
		Operation: admissionv1.Create,
	}

	// Process admission request
	response := webhook.ProcessAdmissionRequest(admissionRequest)

	// Verify response
	g.Expect(response.Allowed).To(gomega.BeTrue())
	g.Expect(len(response.Patch)).To(gomega.BeNumerically(">", 0))

	// Verify patch adds VKS managed label
	var patches []map[string]interface{}
	err = json.Unmarshal(response.Patch, &patches)
	g.Expect(err).To(gomega.BeNil())

	foundVKSLabel := false
	for _, patch := range patches {
		if path, ok := patch["path"].(string); ok && path == "/metadata/labels" {
			if valueMap, ok := patch["value"].(map[string]interface{}); ok {
				if vksValue, exists := valueMap["ako.kubernetes.vmware.com/install"]; exists && vksValue == "true" {
					foundVKSLabel = true
					break
				}
			}
		}
	}
	g.Expect(foundVKSLabel).To(gomega.BeTrue())

	t.Log("‚úÖ VKS Webhook functionality validated successfully")
}

// TestVKSClusterLifecycleIntegration tests the full cluster lifecycle from creation to secret management
func TestVKSClusterLifecycleIntegration(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, dynamicClient := setupVKSIntegrationTest(t)

	// Step 1: Create required namespace with VKS annotations
	namespace := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "test-cluster-ns",
			Annotations: map[string]string{
				lib.WCPSEGroup:       "test-se-group",
				lib.TenantAnnotation: "test-tenant",
			},
		},
	}
	_, err := kubeClient.CoreV1().Namespaces().Create(context.Background(), namespace, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create namespace: %v", err)
	}

	clusterWatcher := ingestion.NewVKSClusterWatcher(kubeClient, dynamicClient)
	clusterWatcher.SetTestMode(func(clusterName, operationalTenant string) (*lib.ClusterCredentials, error) {
		return &lib.ClusterCredentials{
			Username: fmt.Sprintf("vks-cluster-%s-user", clusterName),
			Password: "integration-test-password",
		}, nil
	})

	stopCh := make(chan struct{})
	defer close(stopCh)

	err = clusterWatcher.Start(stopCh)
	if err != nil {
		t.Fatalf("Failed to start cluster watcher: %v", err)
	}

	// Create a VKS-managed cluster
	cluster := createClusterResource("test-cluster", "test-cluster-ns", "Provisioned", true)
	_, err = dynamicClient.Resource(ClusterGVR).Namespace("test-cluster-ns").Create(context.Background(), cluster, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create cluster: %v", err)
	}

	clusterWatcher.EnqueueCluster(cluster, "ADD")
	processed := clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())

	// Verify cluster secret was created
	g.Eventually(func() bool {
		secretName := "test-cluster-avi-secret"
		secret, err := kubeClient.CoreV1().Secrets("test-cluster-ns").Get(context.Background(), secretName, metav1.GetOptions{})
		if err != nil {
			t.Logf("Secret not found: %v", err)
			return false
		}

		expectedFields := []string{"username", "controllerIP", "authtoken"}
		for _, field := range expectedFields {
			if _, exists := secret.Data[field]; !exists {
				t.Logf("Secret missing field: %s", field)
				return false
			}
		}

		usernameBytes, exists := secret.Data["username"]
		if !exists {
			return false
		}

		expectedUsername := "vks-cluster-test-cluster-user"
		return string(usernameBytes) == expectedUsername
	}, 15*time.Second, 1*time.Second).Should(gomega.Equal(true))

	// Test cluster opt-out
	cluster.SetLabels(map[string]string{
		webhook.VKSManagedLabel: webhook.VKSManagedLabelValueFalse,
	})
	_, err = dynamicClient.Resource(ClusterGVR).Namespace("test-cluster-ns").Update(context.Background(), cluster, metav1.UpdateOptions{})
	if err != nil {
		t.Fatalf("Failed to update cluster: %v", err)
	}

	clusterWatcher.EnqueueCluster(cluster, "UPDATE")
	processed = clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())

	// Verify secret was cleaned up
	g.Eventually(func() bool {
		secretName := "test-cluster-avi-secret"
		_, err := kubeClient.CoreV1().Secrets("test-cluster-ns").Get(context.Background(), secretName, metav1.GetOptions{})
		return err != nil // Secret should be deleted
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))

	// Test cluster deletion
	err = dynamicClient.Resource(ClusterGVR).Namespace("test-cluster-ns").Delete(context.Background(), "test-cluster", metav1.DeleteOptions{})
	if err != nil {
		t.Fatalf("Failed to delete cluster: %v", err)
	}

	clusterWatcher.EnqueueCluster(cluster, "DELETE")
	processed = clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())

	clusterWatcher.Stop()

	t.Log("‚úÖ VKS Cluster lifecycle integration test completed successfully")
}

// TestVKSEndToEndIntegration tests the complete VKS integration flow
func TestVKSEndToEndIntegration(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, dynamicClient := setupVKSIntegrationTest(t)

	capability := createVKSSupervisorCapability("ako-vks")
	_, err := dynamicClient.Resource(SupervisorCapabilityGVR).Create(context.Background(), capability, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create SupervisorCapability: %v", err)
	}

	err = addon.EnsureGlobalAddonInstall()
	if err != nil {
		t.Fatalf("Failed to ensure global addon install: %v", err)
	}
	g.Eventually(func() bool {
		_, err := dynamicClient.Resource(AddonInstallGVR).
			Namespace(addon.VKSPublicNamespace).
			Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
		return err == nil
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))

	namespace := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "vks-test-ns",
			Annotations: map[string]string{
				"ako.vmware.com/wcp-se-group": "test-se-group",
			},
		},
	}
	_, err = kubeClient.CoreV1().Namespaces().Create(context.Background(), namespace, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create namespace: %v", err)
	}

	clusterWatcher := ingestion.NewVKSClusterWatcher(kubeClient, dynamicClient)
	clusterWatcher.SetTestMode(func(clusterName, operationalTenant string) (*lib.ClusterCredentials, error) {
		return &lib.ClusterCredentials{
			Username: fmt.Sprintf("vks-cluster-%s-user", clusterName),
			Password: "integration-test-password",
		}, nil
	})

	stopCh := make(chan struct{})
	defer close(stopCh)

	err = clusterWatcher.Start(stopCh)
	if err != nil {
		t.Fatalf("Failed to start cluster watcher: %v", err)
	}

	cluster := createClusterResource("vks-cluster", "vks-test-ns", "Provisioned", true)
	_, err = dynamicClient.Resource(ClusterGVR).Namespace("vks-test-ns").Create(context.Background(), cluster, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create cluster: %v", err)
	}

	clusterWatcher.EnqueueCluster(cluster, "ADD")
	processed := clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())
	g.Eventually(func() bool {
		secretName := "vks-cluster-avi-secret"
		secret, err := kubeClient.CoreV1().Secrets("vks-test-ns").Get(context.Background(), secretName, metav1.GetOptions{})
		if err != nil {
			return false
		}

		requiredFields := []string{"username", "password", "authtoken", "controllerIP"}
		for _, field := range requiredFields {
			if _, exists := secret.Data[field]; !exists {
				t.Logf("Secret missing required field: %s", field)
				return false
			}
		}

		expectedLabels := map[string]string{
			"ako.kubernetes.vmware.com/cluster":    "vks-cluster",
			"ako.kubernetes.vmware.com/managed-by": "ako-infra",
		}

		for key, expectedValue := range expectedLabels {
			if actualValue, exists := secret.Labels[key]; !exists || actualValue != expectedValue {
				t.Logf("Secret label mismatch: %s expected=%s actual=%s", key, expectedValue, actualValue)
				return false
			}
		}

		return true
	}, 15*time.Second, 1*time.Second).Should(gomega.Equal(true))

	clusterWatcher.Stop()

	t.Log("‚úÖ VKS End-to-End integration test completed successfully")
}

// TestVKSErrorHandling tests error scenarios in VKS integration
func TestVKSErrorHandling(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, dynamicClient := setupVKSIntegrationTest(t)

	unmanageableNamespace := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "unmanageable-ns",
		},
	}
	_, err := kubeClient.CoreV1().Namespaces().Create(context.Background(), unmanageableNamespace, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create namespace: %v", err)
	}

	webhookHandler := webhook.NewVKSClusterWebhook(kubeClient)

	cluster := createClusterResource("unmanageable-cluster", "unmanageable-ns", "Provisioned", false)
	clusterBytes, _ := json.Marshal(cluster)

	admissionRequest := &admissionv1.AdmissionRequest{
		UID:       types.UID("test-uid"),
		Kind:      metav1.GroupVersionKind{Group: "cluster.x-k8s.io", Version: "v1beta2", Kind: "Cluster"},
		Namespace: "unmanageable-ns",
		Object:    runtime.RawExtension{Raw: clusterBytes},
		Operation: admissionv1.Create,
	}

	response := webhookHandler.ProcessAdmissionRequest(admissionRequest)

	g.Expect(response.Allowed).To(gomega.BeTrue())
	g.Expect(len(response.Patch)).To(gomega.Equal(0))

	// Test missing admin credentials
	err = kubeClient.CoreV1().Secrets(utils.GetAKONamespace()).Delete(context.Background(), lib.AviSecret, metav1.DeleteOptions{})
	if err != nil {
		t.Fatalf("Failed to delete avi-secret: %v", err)
	}

	clusterWatcher := ingestion.NewVKSClusterWatcher(kubeClient, dynamicClient)
	managedCluster := createClusterResource("test-cluster", "vks-test-ns", "Provisioned", true)

	ctx := context.Background()
	err = clusterWatcher.UpsertAviCredentialsSecret(ctx, managedCluster)
	g.Expect(err).To(gomega.HaveOccurred())
	g.Expect(err.Error()).To(gomega.ContainSubstring("failed to build cluster configuration"))

	t.Log("‚úÖ VKS Error handling test completed successfully")
}

// TestVKSIdempotencyIntegration tests that VKS operations are idempotent
func TestVKSIdempotencyIntegration(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, dynamicClient := setupVKSIntegrationTest(t)

	// Create required namespace with VKS annotations
	namespace := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "test-ns",
			Annotations: map[string]string{
				lib.WCPSEGroup:       "test-se-group",
				lib.TenantAnnotation: "test-tenant",
			},
		},
	}
	_, err := kubeClient.CoreV1().Namespaces().Create(context.Background(), namespace, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create namespace: %v", err)
	}

	err = addon.EnsureGlobalAddonInstall()
	if err != nil {
		t.Fatalf("First addon creation failed: %v", err)
	}

	err = addon.EnsureGlobalAddonInstall()
	if err != nil {
		t.Fatalf("Second addon creation failed: %v", err)
	}
	addons, err := dynamicClient.Resource(AddonInstallGVR).Namespace(addon.VKSPublicNamespace).List(context.Background(), metav1.ListOptions{})
	if err != nil {
		t.Fatalf("Failed to list addons: %v", err)
	}
	g.Expect(len(addons.Items)).To(gomega.Equal(1))

	clusterWatcher := ingestion.NewVKSClusterWatcher(kubeClient, dynamicClient)
	clusterWatcher.SetTestMode(func(clusterName, operationalTenant string) (*lib.ClusterCredentials, error) {
		return &lib.ClusterCredentials{
			Username: fmt.Sprintf("vks-cluster-%s-user", clusterName),
			Password: "integration-test-password",
		}, nil
	})

	cluster := createClusterResource("idempotent-cluster", "test-ns", "Provisioned", true)

	ctx := context.Background()

	err = clusterWatcher.UpsertAviCredentialsSecret(ctx, cluster)
	if err != nil {
		t.Fatalf("Expected secret creation to succeed with mock credentials, got: %v", err)
	}

	err = clusterWatcher.UpsertAviCredentialsSecret(ctx, cluster)
	if err != nil {
		t.Fatalf("Expected second secret creation to be idempotent, got: %v", err)
	}

	t.Log("‚úÖ VKS Idempotency test completed - validated secret creation idempotency")
}

// TestVKSE2ECreationToCleanup tests the full E2E flow from VKS infrastructure startup to complete cleanup
func TestVKSE2ECreationToCleanup(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, dynamicClient := setupVKSIntegrationTest(t)

	t.Log("üöÄ Phase 1: VKS Infrastructure Startup")

	capability := createVKSSupervisorCapability("ako-vks")
	_, err := dynamicClient.Resource(SupervisorCapabilityGVR).Create(context.Background(), capability, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create SupervisorCapability: %v", err)
	}
	t.Log("‚úÖ VKS SupervisorCapability created")

	err = addon.EnsureGlobalAddonInstall()
	if err != nil {
		t.Fatalf("Failed to ensure global addon install: %v", err)
	}
	g.Eventually(func() bool {
		_, err := dynamicClient.Resource(AddonInstallGVR).
			Namespace(addon.VKSPublicNamespace).
			Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
		return err == nil
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("‚úÖ Global AddonInstall created")

	err = webhook.CreateWebhookConfiguration(kubeClient)
	if err != nil {
		t.Fatalf("Failed to create webhook configuration: %v", err)
	}
	g.Eventually(func() bool {
		_, err := kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().Get(
			context.Background(), "ako-vks-cluster-webhook", metav1.GetOptions{})
		return err == nil
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("‚úÖ VKS webhook configuration created")

	t.Log("üîÑ Phase 2: Cluster Lifecycle Management")
	namespace := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "e2e-test-ns",
			Annotations: map[string]string{
				"ako.vmware.com/wcp-se-group": "test-se-group",
			},
		},
	}
	_, err = kubeClient.CoreV1().Namespaces().Create(context.Background(), namespace, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create namespace: %v", err)
	}

	clusterWatcher := ingestion.NewVKSClusterWatcher(kubeClient, dynamicClient)
	clusterWatcher.SetTestMode(func(clusterName, operationalTenant string) (*lib.ClusterCredentials, error) {
		return &lib.ClusterCredentials{
			Username: fmt.Sprintf("vks-cluster-%s-user", clusterName),
			Password: "integration-test-password",
		}, nil
	})

	stopCh := make(chan struct{})

	err = clusterWatcher.Start(stopCh)
	if err != nil {
		t.Fatalf("Failed to start cluster watcher: %v", err)
	}
	t.Log("‚úÖ VKS cluster watcher started")

	cluster := createClusterResource("e2e-cluster", "e2e-test-ns", "Provisioned", true)
	_, err = dynamicClient.Resource(ClusterGVR).Namespace("e2e-test-ns").Create(context.Background(), cluster, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create cluster: %v", err)
	}

	clusterWatcher.EnqueueCluster(cluster, "ADD")
	processed := clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())
	g.Eventually(func() bool {
		secretName := "e2e-cluster-avi-secret"
		secret, err := kubeClient.CoreV1().Secrets("e2e-test-ns").Get(context.Background(), secretName, metav1.GetOptions{})
		if err != nil {
			return false
		}

		requiredFields := []string{"username", "password", "authtoken", "controllerIP"}
		for _, field := range requiredFields {
			if _, exists := secret.Data[field]; !exists {
				return false
			}
		}

		expectedLabels := map[string]string{
			"ako.kubernetes.vmware.com/cluster":    "e2e-cluster",
			"ako.kubernetes.vmware.com/managed-by": "ako-infra",
		}
		for key, expectedValue := range expectedLabels {
			if actualValue, exists := secret.Labels[key]; !exists || actualValue != expectedValue {
				return false
			}
		}

		return true
	}, 15*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("‚úÖ Cluster secret created successfully")

	t.Log("üîç Phase 3: Resource State Validation")
	resourceChecks := []struct {
		name        string
		checkFunc   func() bool
		description string
	}{
		{
			name: "AddonInstall",
			checkFunc: func() bool {
				_, err := dynamicClient.Resource(AddonInstallGVR).
					Namespace(addon.VKSPublicNamespace).
					Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
				return err == nil
			},
			description: "Global AddonInstall exists",
		},
		{
			name: "WebhookConfiguration",
			checkFunc: func() bool {
				_, err := kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().Get(
					context.Background(), "ako-vks-cluster-webhook", metav1.GetOptions{})
				return err == nil
			},
			description: "MutatingWebhookConfiguration exists",
		},
		{
			name: "ClusterSecret",
			checkFunc: func() bool {
				_, err := kubeClient.CoreV1().Secrets("e2e-test-ns").Get(
					context.Background(), "e2e-cluster-avi-secret", metav1.GetOptions{})
				return err == nil
			},
			description: "Cluster secret exists",
		},
	}

	for _, check := range resourceChecks {
		g.Expect(check.checkFunc()).To(gomega.BeTrue(), check.description+" should be present")
		t.Logf("‚úÖ %s validated", check.description)
	}

	t.Log("üßπ Phase 4: VKS Cleanup Simulation")

	close(stopCh)
	t.Log("‚úÖ Shutdown signal sent")

	t.Log("üîß Executing webhook cleanup...")
	err = webhook.CleanupWebhookConfiguration(kubeClient)
	if err != nil {
		t.Fatalf("Failed to cleanup webhook configuration: %v", err)
	}
	t.Log("‚úÖ Webhook configuration cleaned up")

	t.Log("üîß Executing addon cleanup...")
	err = addon.CleanupGlobalAddonInstall()
	if err != nil {
		t.Fatalf("Failed to cleanup global addon install: %v", err)
	}
	t.Log("‚úÖ Global AddonInstall cleaned up")

	t.Log("üîç Phase 5: Cleanup Verification")
	g.Eventually(func() bool {
		_, err := kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().Get(
			context.Background(), "ako-vks-cluster-webhook", metav1.GetOptions{})
		return err != nil // Should be deleted
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("‚úÖ MutatingWebhookConfiguration deletion verified")

	// Verify AddonInstall was deleted
	g.Eventually(func() bool {
		_, err := dynamicClient.Resource(AddonInstallGVR).
			Namespace(addon.VKSPublicNamespace).
			Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
		return err != nil // Should be deleted
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("‚úÖ Global AddonInstall deletion verified")

	// === Phase 6: Cluster Secret Cleanup (Cluster Deletion) ===
	t.Log("üóëÔ∏è Phase 6: Cluster Secret Cleanup")

	// Step 9: Delete cluster (simulates cluster deletion)
	err = dynamicClient.Resource(ClusterGVR).Namespace("e2e-test-ns").Delete(context.Background(), "e2e-cluster", metav1.DeleteOptions{})
	if err != nil {
		t.Fatalf("Failed to delete cluster: %v", err)
	}

	// Process cluster DELETE event
	clusterWatcher.EnqueueCluster(cluster, "DELETE")
	processed = clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())

	// Verify cluster secret was deleted
	g.Eventually(func() bool {
		_, err := kubeClient.CoreV1().Secrets("e2e-test-ns").Get(
			context.Background(), "e2e-cluster-avi-secret", metav1.GetOptions{})
		return err != nil // Should be deleted
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("‚úÖ Cluster secret deletion verified")

	// Stop cluster watcher
	clusterWatcher.Stop()
	t.Log("‚úÖ Cluster watcher stopped")

	// === Final Verification ===
	t.Log("üéØ Final State Verification")

	finalChecks := []struct {
		name        string
		checkFunc   func() bool
		description string
	}{
		{
			name: "AddonInstall_Deleted",
			checkFunc: func() bool {
				_, err := dynamicClient.Resource(AddonInstallGVR).
					Namespace(addon.VKSPublicNamespace).
					Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
				return err != nil // Should be deleted
			},
			description: "AddonInstall is deleted",
		},
		{
			name: "WebhookConfiguration_Deleted",
			checkFunc: func() bool {
				_, err := kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().Get(
					context.Background(), "ako-vks-cluster-webhook", metav1.GetOptions{})
				return err != nil // Should be deleted
			},
			description: "MutatingWebhookConfiguration is deleted",
		},
		{
			name: "ClusterSecret_Deleted",
			checkFunc: func() bool {
				_, err := kubeClient.CoreV1().Secrets("e2e-test-ns").Get(
					context.Background(), "e2e-cluster-avi-secret", metav1.GetOptions{})
				return err != nil // Should be deleted
			},
			description: "Cluster secret is deleted",
		},
	}

	for _, check := range finalChecks {
		g.Expect(check.checkFunc()).To(gomega.BeTrue(), check.description)
		t.Logf("‚úÖ %s verified", check.description)
	}

	t.Log("üéâ === VKS E2E Creation-to-Cleanup test completed successfully ===")
	t.Log("üìã Test Summary:")
	t.Log("   ‚úÖ VKS infrastructure startup")
	t.Log("   ‚úÖ Global addon install creation and management")
	t.Log("   ‚úÖ Webhook configuration lifecycle")
	t.Log("   ‚úÖ Cluster secret creation and management")
	t.Log("   ‚úÖ Complete cleanup on AKO shutdown")
	t.Log("   ‚úÖ Cluster-specific resource cleanup on cluster deletion")
	t.Log("   ‚úÖ All resources properly cleaned up")
}
