/*
 * Copyright Â© 2025 Broadcom Inc. and/or its subsidiaries. All Rights Reserved.
 * All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*   http://www.apache.org/licenses/LICENSE-2.0
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

// @AI-Generated
// This test file was generated by Claude AI assistant.

package infratests

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"sync"
	"testing"
	"time"

	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-infra/addon"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-infra/ingestion"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-infra/webhook"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/k8s"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/lib"
	akoapisv1beta1 "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/apis/ako/v1beta1"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/utils"

	"github.com/onsi/gomega"

	v1beta1crdfake "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/client/v1beta1/clientset/versioned/fake"

	admissionv1 "k8s.io/api/admission/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/types"
	dynamicfake "k8s.io/client-go/dynamic/fake"
	k8sfake "k8s.io/client-go/kubernetes/fake"
	"k8s.io/client-go/tools/cache"
)

// Global sync.Once to ensure informers are started only once across all tests
var (
	informerStartOnce sync.Once
	stopChInformers   chan struct{}
)

var (
	// Use the existing SupervisorCapability GVR from lib for VKS capability detection
	AviInfraSettingGVR = schema.GroupVersionResource{
		Group:    "ako.vmware.com",
		Version:  "v1beta1",
		Resource: "aviinfrasettings",
	}
	ClusterBootstrapGVR = schema.GroupVersionResource{
		Group:    "run.tanzu.vmware.com",
		Version:  "v1alpha3",
		Resource: "clusterbootstraps",
	}
)

// Reuse existing GVRs from lib
var (
	SupervisorCapabilityGVR = lib.SupervisorCapabilityGVR
	AddonInstallGVR         = lib.AddonInstallGVR
	ClusterGVR              = lib.ClusterGVR
)

// forceInformerCacheSync manually syncs a secret into the informer cache for testing
func forceInformerCacheSync(secret *corev1.Secret) {
	// Add secret to the informer cache manually
	informer := utils.GetInformers().SecretInformer.Informer()
	informer.GetStore().Add(secret)
}

// startInformersOnce starts informers only once using sync.Once
func startInformersOnce() {
	informerStartOnce.Do(func() {
		// Initialize the stop channel for informers
		stopChInformers = make(chan struct{})

		// Start the secret informer
		go func() {
			utils.GetInformers().SecretInformer.Informer().Run(stopChInformers)
		}()

		// Wait for secret informer cache to sync
		if !cache.WaitForCacheSync(stopChInformers, utils.GetInformers().SecretInformer.Informer().HasSynced) {
			// Log warning but don't fail - this is expected in test environment
			fmt.Printf("Warning: secret informer cache sync timed out (expected in test environment)\n")
		}
	})
}

// setupVKSIntegrationTest sets up the environment for VKS integration tests
func setupVKSIntegrationTest(t *testing.T) (*k8sfake.Clientset, *dynamicfake.FakeDynamicClient) {
	kubeClient := k8sfake.NewSimpleClientset()

	// Create avi-secret with admin credentials
	aviSecret := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      lib.AviSecret,
			Namespace: utils.GetAKONamespace(),
		},
		Type: corev1.SecretTypeOpaque,
		Data: map[string][]byte{
			"username":                 []byte("admin"),
			"password":                 []byte("admin123"),
			"certificateAuthorityData": []byte("-----BEGIN CERTIFICATE-----\nMIICertificateData...\n-----END CERTIFICATE-----"),
		},
	}
	_, err := kubeClient.CoreV1().Secrets(utils.GetAKONamespace()).Create(context.Background(), aviSecret, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create avi-secret: %v", err)
	}

	// Set up dynamic client with custom list kinds
	gvrToKind := map[schema.GroupVersionResource]string{
		SupervisorCapabilityGVR: "capabilitiesList",
		AddonInstallGVR:         "addoninstallsList",
		ClusterGVR:              "clustersList",
		AviInfraSettingGVR:      "aviinfrasettingsList",
		ClusterBootstrapGVR:     "clusterbootstrapsList",
	}

	dynamicClient := dynamicfake.NewSimpleDynamicClientWithCustomListKinds(runtime.NewScheme(), gvrToKind)
	lib.SetDynamicClientSet(dynamicClient)
	lib.NewDynamicInformers(dynamicClient, true)

	// Initialize regular informers needed by VKS cluster watcher
	registeredInformers := []string{
		utils.SecretInformer,
	}
	utils.NewInformers(utils.KubeClientIntf{ClientSet: kubeClient}, registeredInformers, nil)

	// Start informers once using sync.Once to avoid multiple starts
	startInformersOnce()

	// Initialize CRD informers for AviInfraSetting
	akoControlConfig := lib.AKOControlConfig()

	// Create a test AviInfraSetting in the fake client
	testAviInfraSetting := createTypedAviInfraSetting("test-aviinfrasetting")
	v1beta1crdClient := v1beta1crdfake.NewSimpleClientset(testAviInfraSetting)
	akoControlConfig.SetCRDClientsetAndEnableInfraSettingParam(v1beta1crdClient)

	// Initialize CRD informers
	k8s.NewCRDInformers()

	// Start the AviInfraSetting informer and wait for cache sync
	stopCh := make(chan struct{})
	go func() {
		defer close(stopCh)
		time.Sleep(30 * time.Second) // Allow test to complete
	}()

	go lib.RunAviInfraSettingInformer(stopCh)

	// Give the informer time to sync
	time.Sleep(100 * time.Millisecond)

	// Set controller IP for testing
	lib.SetControllerIP("10.10.10.10")

	// Set up T1LR environment variable for tests
	os.Setenv("NSXT_T1_LR", "/orgs/test-org/projects/test-project/vpcs/test-vpc")

	return kubeClient, dynamicClient
}

// createAviInfraSetting creates an AviInfraSetting resource for testing
func createAviInfraSetting(name string) *unstructured.Unstructured {
	return &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "ako.vmware.com/v1beta1",
			"kind":       "AviInfraSetting",
			"metadata": map[string]interface{}{
				"name": name,
			},
			"spec": map[string]interface{}{
				"seGroup": map[string]interface{}{
					"name": "test-se-group",
				},
				"nsxSettings": map[string]interface{}{
					"t1lr": "/orgs/test-org/projects/test-project/vpcs/test-vpc",
				},
			},
		},
	}
}

// createTypedAviInfraSetting creates a typed AviInfraSetting for the fake CRD client
func createTypedAviInfraSetting(name string) *akoapisv1beta1.AviInfraSetting {
	t1lr := "/orgs/test-org/projects/test-project/vpcs/test-vpc"
	return &akoapisv1beta1.AviInfraSetting{
		TypeMeta: metav1.TypeMeta{
			APIVersion: "ako.vmware.com/v1beta1",
			Kind:       "AviInfraSetting",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name: name,
		},
		Spec: akoapisv1beta1.AviInfraSettingSpec{
			SeGroup: akoapisv1beta1.AviInfraSettingSeGroup{
				Name: "test-se-group",
			},
			NSXSettings: akoapisv1beta1.AviInfraNSXSettings{
				T1LR: &t1lr,
			},
		},
	}
}

// createClusterBootstrap creates a ClusterBootstrap resource for CNI detection
func createClusterBootstrap(name, namespace, cniRefName string) *unstructured.Unstructured {
	return &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "run.tanzu.vmware.com/v1alpha3",
			"kind":       "ClusterBootstrap",
			"metadata": map[string]interface{}{
				"name":      name,
				"namespace": namespace,
			},
			"spec": map[string]interface{}{
				"cni": map[string]interface{}{
					"refName": cniRefName,
				},
			},
		},
	}
}

// createVKSSupervisorCapability creates a VKS SupervisorCapability resource
// that matches the structure expected by lib.IsVKSCapabilityActivated()
func createVKSSupervisorCapability(name string) *unstructured.Unstructured {
	return &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "iaas.vmware.com/v1alpha1",
			"kind":       "SupervisorCapability",
			"metadata": map[string]interface{}{
				"name": name,
			},
			"spec": map[string]interface{}{
				"capability": "ako_vks",
				"version":    "v1.12.1",
			},
			"status": map[string]interface{}{
				"supervisor": map[string]interface{}{
					"supports_ako_vks_integration": map[string]interface{}{
						"activated": true,
					},
				},
			},
		},
	}
}

// createClusterResource creates a cluster.x-k8s.io Cluster resource
func createClusterResource(name, namespace, phase string, managed bool) *unstructured.Unstructured {
	cluster := &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "cluster.x-k8s.io/v1beta2",
			"kind":       "Cluster",
			"metadata": map[string]interface{}{
				"name":      name,
				"namespace": namespace,
				"uid":       "test-uid-123",
			},
			"status": map[string]interface{}{
				"phase": phase,
			},
		},
	}

	if managed {
		cluster.SetLabels(map[string]string{
			webhook.VKSManagedLabel: webhook.VKSManagedLabelValueTrue,
		})
	}

	return cluster
}

// TestVKSCapabilityToAddonFlow tests the full flow from VKS capability enablement to addon creation
func TestVKSCapabilityToAddonFlow(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	_, dynamicClient := setupVKSIntegrationTest(t)

	// Step 1: Create VKS SupervisorCapability
	capability := createVKSSupervisorCapability("ako-vks")
	_, err := dynamicClient.Resource(SupervisorCapabilityGVR).Create(context.Background(), capability, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create SupervisorCapability: %v", err)
	}

	// Step 2: Ensure global addon install is created
	err = addon.EnsureGlobalAddonInstall()
	if err != nil {
		t.Fatalf("Failed to ensure global addon install: %v", err)
	}

	// Step 3: Verify AddonInstall resource was created
	g.Eventually(func() bool {
		addonInstall, err := dynamicClient.Resource(AddonInstallGVR).
			Namespace(addon.VKSPublicNamespace).
			Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
		if err != nil {
			t.Logf("AddonInstall not found: %v", err)
			return false
		}

		// Verify basic addon structure
		name, _, _ := unstructured.NestedString(addonInstall.Object, "metadata", "name")
		namespace, _, _ := unstructured.NestedString(addonInstall.Object, "metadata", "namespace")

		return name == addon.AKOAddonInstallName && namespace == addon.VKSPublicNamespace
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))

	t.Log("â VKS Capability to Addon flow completed successfully")
}

// TestVKSWebhookFunctionality tests the VKS webhook validation and labeling
func TestVKSWebhookFunctionality(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, _ := setupVKSIntegrationTest(t)

	// Create a namespace with ServiceEngineGroup annotation
	namespace := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "test-cluster-ns",
			Annotations: map[string]string{
				"ako.vmware.com/wcp-se-group": "test-se-group",
			},
		},
	}
	_, err := kubeClient.CoreV1().Namespaces().Create(context.Background(), namespace, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create namespace: %v", err)
	}

	// Create VKS webhook
	webhook := webhook.NewVKSClusterWebhook(kubeClient)

	// Test cluster that should be managed by VKS
	clusterObj := createClusterResource("test-cluster", "test-cluster-ns", "Provisioned", false)
	clusterBytes, _ := json.Marshal(clusterObj)

	admissionRequest := &admissionv1.AdmissionRequest{
		UID:       types.UID("test-uid"),
		Kind:      metav1.GroupVersionKind{Group: "cluster.x-k8s.io", Version: "v1beta2", Kind: "Cluster"},
		Namespace: "test-cluster-ns",
		Object:    runtime.RawExtension{Raw: clusterBytes},
		Operation: admissionv1.Create,
	}

	// Process admission request
	response := webhook.ProcessAdmissionRequest(admissionRequest)

	// Verify response
	g.Expect(response.Allowed).To(gomega.BeTrue())
	g.Expect(len(response.Patch)).To(gomega.BeNumerically(">", 0))

	// Verify patch adds VKS managed label
	var patches []map[string]interface{}
	err = json.Unmarshal(response.Patch, &patches)
	g.Expect(err).To(gomega.BeNil())

	foundVKSLabel := false
	for _, patch := range patches {
		if path, ok := patch["path"].(string); ok && path == "/metadata/labels" {
			if valueMap, ok := patch["value"].(map[string]interface{}); ok {
				if vksValue, exists := valueMap["ako.kubernetes.vmware.com/install"]; exists && vksValue == "true" {
					foundVKSLabel = true
					break
				}
			}
		}
	}
	g.Expect(foundVKSLabel).To(gomega.BeTrue())

	t.Log("â VKS Webhook functionality validated successfully")
}

// TestVKSClusterLifecycleIntegration tests the full cluster lifecycle from creation to secret management
func TestVKSClusterLifecycleIntegration(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, dynamicClient := setupVKSIntegrationTest(t)

	// Step 1: Create required namespace with VKS annotations
	namespace := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "test-cluster-ns",
			Annotations: map[string]string{
				lib.WCPSEGroup:                 "test-se-group",
				lib.TenantAnnotation:           "test-tenant",
				lib.InfraSettingNameAnnotation: "test-aviinfrasetting",
			},
		},
	}
	_, err := kubeClient.CoreV1().Namespaces().Create(context.Background(), namespace, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create namespace: %v", err)
	}

	// Create AviInfraSetting resource in both clients
	aviInfraSetting := createAviInfraSetting("test-aviinfrasetting")
	_, err = dynamicClient.Resource(AviInfraSettingGVR).Create(context.Background(), aviInfraSetting, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create AviInfraSetting in dynamic client: %v", err)
	}

	// Create ClusterBootstrap for CNI detection
	clusterBootstrap := createClusterBootstrap("test-cluster", "test-cluster-ns", "antrea.tanzu.vmware.com.2.3.0+vmware.1-tkg.1")
	_, err = dynamicClient.Resource(ClusterBootstrapGVR).Namespace("test-cluster-ns").Create(context.Background(), clusterBootstrap, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create ClusterBootstrap: %v", err)
	}

	clusterWatcher := ingestion.NewVKSClusterWatcher(kubeClient, dynamicClient)
	clusterWatcher.SetTestMode(func(clusterNameWithUID, operationalTenant string) (*lib.ClusterCredentials, error) {
		return &lib.ClusterCredentials{
			Username: fmt.Sprintf("vks-cluster-%s-user", clusterNameWithUID),
			Password: "integration-test-password",
		}, nil
	})

	stopCh := make(chan struct{})
	defer close(stopCh)

	err = clusterWatcher.Start(stopCh)
	if err != nil {
		t.Fatalf("Failed to start cluster watcher: %v", err)
	}

	// Create a VKS-managed cluster
	cluster := createClusterResource("test-cluster", "test-cluster-ns", "Provisioned", true)
	_, err = dynamicClient.Resource(ClusterGVR).Namespace("test-cluster-ns").Create(context.Background(), cluster, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create cluster: %v", err)
	}

	clusterWatcher.EnqueueCluster(cluster, "ADD")
	processed := clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())

	// Verify cluster secret was created
	g.Eventually(func() bool {
		secretName := "test-cluster-avi-secret"
		secret, err := kubeClient.CoreV1().Secrets("test-cluster-ns").Get(context.Background(), secretName, metav1.GetOptions{})
		if err != nil {
			t.Logf("Secret not found: %v", err)
			return false
		}

		expectedFields := []string{"username", "controllerIP", "password"}
		for _, field := range expectedFields {
			if _, exists := secret.Data[field]; !exists {
				t.Logf("Secret missing field: %s", field)
				return false
			}
		}

		usernameBytes, exists := secret.Data["username"]
		if !exists {
			return false
		}

		expectedUsername := "vks-cluster-test-cluster-ns-test-cluster-test-uid-user"
		if string(usernameBytes) == expectedUsername {
			// Manually sync the secret to informer cache for testing
			forceInformerCacheSync(secret)
			return true
		}
		return false
	}, 15*time.Second, 1*time.Second).Should(gomega.Equal(true))

	// Test cluster opt-out
	cluster.SetLabels(map[string]string{
		webhook.VKSManagedLabel: webhook.VKSManagedLabelValueFalse,
	})
	_, err = dynamicClient.Resource(ClusterGVR).Namespace("test-cluster-ns").Update(context.Background(), cluster, metav1.UpdateOptions{})
	if err != nil {
		t.Fatalf("Failed to update cluster: %v", err)
	}

	clusterWatcher.EnqueueCluster(cluster, "UPDATE")
	processed = clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())

	// Verify secret was cleaned up
	g.Eventually(func() bool {
		secretName := "test-cluster-avi-secret"
		_, err := kubeClient.CoreV1().Secrets("test-cluster-ns").Get(context.Background(), secretName, metav1.GetOptions{})
		return err != nil // Secret should be deleted
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))

	// Test cluster deletion
	err = dynamicClient.Resource(ClusterGVR).Namespace("test-cluster-ns").Delete(context.Background(), "test-cluster", metav1.DeleteOptions{})
	if err != nil {
		t.Fatalf("Failed to delete cluster: %v", err)
	}

	clusterWatcher.EnqueueCluster(cluster, "DELETE")
	processed = clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())

	clusterWatcher.Stop()

	t.Log("â VKS Cluster lifecycle integration test completed successfully")
}

// TestVKSEndToEndIntegration tests the complete VKS integration flow
func TestVKSEndToEndIntegration(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, dynamicClient := setupVKSIntegrationTest(t)

	capability := createVKSSupervisorCapability("ako-vks")
	_, err := dynamicClient.Resource(SupervisorCapabilityGVR).Create(context.Background(), capability, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create SupervisorCapability: %v", err)
	}

	err = addon.EnsureGlobalAddonInstall()
	if err != nil {
		t.Fatalf("Failed to ensure global addon install: %v", err)
	}
	g.Eventually(func() bool {
		_, err := dynamicClient.Resource(AddonInstallGVR).
			Namespace(addon.VKSPublicNamespace).
			Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
		return err == nil
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))

	namespace := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "vks-test-ns",
			Annotations: map[string]string{
				lib.WCPSEGroup:                 "test-se-group",
				lib.TenantAnnotation:           "test-tenant",
				lib.InfraSettingNameAnnotation: "test-aviinfrasetting",
			},
		},
	}
	_, err = kubeClient.CoreV1().Namespaces().Create(context.Background(), namespace, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create namespace: %v", err)
	}

	// Create ClusterBootstrap for CNI detection
	clusterBootstrap := createClusterBootstrap("vks-cluster", "vks-test-ns", "antrea.tanzu.vmware.com.2.3.0+vmware.1-tkg.1")
	_, err = dynamicClient.Resource(ClusterBootstrapGVR).Namespace("vks-test-ns").Create(context.Background(), clusterBootstrap, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create ClusterBootstrap: %v", err)
	}

	clusterWatcher := ingestion.NewVKSClusterWatcher(kubeClient, dynamicClient)
	clusterWatcher.SetTestMode(func(clusterNameWithUID, operationalTenant string) (*lib.ClusterCredentials, error) {
		return &lib.ClusterCredentials{
			Username: fmt.Sprintf("vks-cluster-%s-user", clusterNameWithUID),
			Password: "integration-test-password",
		}, nil
	})

	stopCh := make(chan struct{})
	defer close(stopCh)

	err = clusterWatcher.Start(stopCh)
	if err != nil {
		t.Fatalf("Failed to start cluster watcher: %v", err)
	}

	cluster := createClusterResource("vks-cluster", "vks-test-ns", "Provisioned", true)
	_, err = dynamicClient.Resource(ClusterGVR).Namespace("vks-test-ns").Create(context.Background(), cluster, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create cluster: %v", err)
	}

	clusterWatcher.EnqueueCluster(cluster, "ADD")
	processed := clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())
	g.Eventually(func() bool {
		secretName := "vks-cluster-avi-secret"
		secret, err := kubeClient.CoreV1().Secrets("vks-test-ns").Get(context.Background(), secretName, metav1.GetOptions{})
		if err != nil {
			return false
		}

		requiredFields := []string{"username", "password", "controllerIP"}
		for _, field := range requiredFields {
			if _, exists := secret.Data[field]; !exists {
				t.Logf("Secret missing required field: %s", field)
				return false
			}
		}

		expectedLabels := map[string]string{
			"ako.kubernetes.vmware.com/cluster":    "vks-cluster",
			"ako.kubernetes.vmware.com/managed-by": "ako-infra",
		}

		for key, expectedValue := range expectedLabels {
			if actualValue, exists := secret.Labels[key]; !exists || actualValue != expectedValue {
				t.Logf("Secret label mismatch: %s expected=%s actual=%s", key, expectedValue, actualValue)
				return false
			}
		}

		return true
	}, 15*time.Second, 1*time.Second).Should(gomega.Equal(true))

	clusterWatcher.Stop()

	t.Log("â VKS End-to-End integration test completed successfully")
}

// TestVKSErrorHandling tests error scenarios in VKS integration
func TestVKSErrorHandling(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, dynamicClient := setupVKSIntegrationTest(t)

	unmanageableNamespace := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "unmanageable-ns",
		},
	}
	_, err := kubeClient.CoreV1().Namespaces().Create(context.Background(), unmanageableNamespace, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create namespace: %v", err)
	}

	webhookHandler := webhook.NewVKSClusterWebhook(kubeClient)

	cluster := createClusterResource("unmanageable-cluster", "unmanageable-ns", "Provisioned", false)
	clusterBytes, _ := json.Marshal(cluster)

	admissionRequest := &admissionv1.AdmissionRequest{
		UID:       types.UID("test-uid"),
		Kind:      metav1.GroupVersionKind{Group: "cluster.x-k8s.io", Version: "v1beta2", Kind: "Cluster"},
		Namespace: "unmanageable-ns",
		Object:    runtime.RawExtension{Raw: clusterBytes},
		Operation: admissionv1.Create,
	}

	response := webhookHandler.ProcessAdmissionRequest(admissionRequest)

	g.Expect(response.Allowed).To(gomega.BeTrue())
	g.Expect(len(response.Patch)).To(gomega.Equal(0))

	// Test missing admin credentials
	err = kubeClient.CoreV1().Secrets(utils.GetAKONamespace()).Delete(context.Background(), lib.AviSecret, metav1.DeleteOptions{})
	if err != nil {
		t.Fatalf("Failed to delete avi-secret: %v", err)
	}

	clusterWatcher := ingestion.NewVKSClusterWatcher(kubeClient, dynamicClient)
	managedCluster := createClusterResource("test-cluster", "vks-test-ns", "Provisioned", true)

	ctx := context.Background()
	err = clusterWatcher.UpsertAviCredentialsSecret(ctx, managedCluster)
	g.Expect(err).To(gomega.HaveOccurred())
	g.Expect(err.Error()).To(gomega.ContainSubstring("failed to build cluster configuration"))

	t.Log("â VKS Error handling test completed successfully")
}

// TestVKSIdempotencyIntegration tests that VKS operations are idempotent
func TestVKSIdempotencyIntegration(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, dynamicClient := setupVKSIntegrationTest(t)

	// Create required namespace with VKS annotations
	namespace := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "test-ns",
			Annotations: map[string]string{
				lib.WCPSEGroup:                 "test-se-group",
				lib.TenantAnnotation:           "test-tenant",
				lib.InfraSettingNameAnnotation: "test-aviinfrasetting",
			},
		},
	}
	_, err := kubeClient.CoreV1().Namespaces().Create(context.Background(), namespace, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create namespace: %v", err)
	}

	// Create ClusterBootstrap for CNI detection
	clusterBootstrap := createClusterBootstrap("idempotent-cluster", "test-ns", "antrea.tanzu.vmware.com.2.3.0+vmware.1-tkg.1")
	_, err = dynamicClient.Resource(ClusterBootstrapGVR).Namespace("test-ns").Create(context.Background(), clusterBootstrap, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create ClusterBootstrap: %v", err)
	}

	err = addon.EnsureGlobalAddonInstall()
	if err != nil {
		t.Fatalf("First addon creation failed: %v", err)
	}

	err = addon.EnsureGlobalAddonInstall()
	if err != nil {
		t.Fatalf("Second addon creation failed: %v", err)
	}
	addons, err := dynamicClient.Resource(AddonInstallGVR).Namespace(addon.VKSPublicNamespace).List(context.Background(), metav1.ListOptions{})
	if err != nil {
		t.Fatalf("Failed to list addons: %v", err)
	}
	g.Expect(len(addons.Items)).To(gomega.Equal(1))

	clusterWatcher := ingestion.NewVKSClusterWatcher(kubeClient, dynamicClient)
	clusterWatcher.SetTestMode(func(clusterNameWithUID, operationalTenant string) (*lib.ClusterCredentials, error) {
		return &lib.ClusterCredentials{
			Username: fmt.Sprintf("vks-cluster-%s-user", clusterNameWithUID),
			Password: "integration-test-password",
		}, nil
	})

	cluster := createClusterResource("idempotent-cluster", "test-ns", "Provisioned", true)

	ctx := context.Background()

	err = clusterWatcher.UpsertAviCredentialsSecret(ctx, cluster)
	if err != nil {
		t.Fatalf("Expected secret creation to succeed with mock credentials, got: %v", err)
	}

	// Manually sync the created secret to the informer cache for testing
	secretName := "idempotent-cluster-avi-secret"
	secret, err := kubeClient.CoreV1().Secrets("test-ns").Get(ctx, secretName, metav1.GetOptions{})
	if err != nil {
		t.Fatalf("Failed to get created secret: %v", err)
	}
	forceInformerCacheSync(secret)

	err = clusterWatcher.UpsertAviCredentialsSecret(ctx, cluster)
	if err != nil {
		t.Fatalf("Expected second secret creation to be idempotent, got: %v", err)
	}

	t.Log("â VKS Idempotency test completed - validated secret creation idempotency")
}

// TestVKSE2ECreationToCleanup tests the full E2E flow from VKS infrastructure startup to complete cleanup
func TestVKSE2ECreationToCleanup(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, dynamicClient := setupVKSIntegrationTest(t)

	t.Log("ð Phase 1: VKS Infrastructure Startup")

	capability := createVKSSupervisorCapability("ako-vks")
	_, err := dynamicClient.Resource(SupervisorCapabilityGVR).Create(context.Background(), capability, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create SupervisorCapability: %v", err)
	}
	t.Log("â VKS SupervisorCapability created")

	err = addon.EnsureGlobalAddonInstall()
	if err != nil {
		t.Fatalf("Failed to ensure global addon install: %v", err)
	}
	g.Eventually(func() bool {
		_, err := dynamicClient.Resource(AddonInstallGVR).
			Namespace(addon.VKSPublicNamespace).
			Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
		return err == nil
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("â Global AddonInstall created")

	err = webhook.CreateWebhookConfiguration(kubeClient)
	if err != nil {
		t.Fatalf("Failed to create webhook configuration: %v", err)
	}
	g.Eventually(func() bool {
		_, err := kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().Get(
			context.Background(), "ako-vks-cluster-webhook", metav1.GetOptions{})
		return err == nil
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("â VKS webhook configuration created")

	t.Log("ð Phase 2: Cluster Lifecycle Management")
	namespace := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "e2e-test-ns",
			Annotations: map[string]string{
				lib.WCPSEGroup:                 "test-se-group",
				lib.TenantAnnotation:           "test-tenant",
				lib.InfraSettingNameAnnotation: "test-aviinfrasetting",
			},
		},
	}
	_, err = kubeClient.CoreV1().Namespaces().Create(context.Background(), namespace, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create namespace: %v", err)
	}

	// Create ClusterBootstrap for CNI detection
	clusterBootstrap := createClusterBootstrap("e2e-cluster", "e2e-test-ns", "antrea.tanzu.vmware.com.2.3.0+vmware.1-tkg.1")
	_, err = dynamicClient.Resource(ClusterBootstrapGVR).Namespace("e2e-test-ns").Create(context.Background(), clusterBootstrap, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create ClusterBootstrap: %v", err)
	}

	clusterWatcher := ingestion.NewVKSClusterWatcher(kubeClient, dynamicClient)
	clusterWatcher.SetTestMode(func(clusterNameWithUID, operationalTenant string) (*lib.ClusterCredentials, error) {
		return &lib.ClusterCredentials{
			Username: fmt.Sprintf("vks-cluster-%s-user", clusterNameWithUID),
			Password: "integration-test-password",
		}, nil
	})

	stopCh := make(chan struct{})

	err = clusterWatcher.Start(stopCh)
	if err != nil {
		t.Fatalf("Failed to start cluster watcher: %v", err)
	}
	t.Log("â VKS cluster watcher started")

	cluster := createClusterResource("e2e-cluster", "e2e-test-ns", "Provisioned", true)
	_, err = dynamicClient.Resource(ClusterGVR).Namespace("e2e-test-ns").Create(context.Background(), cluster, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create cluster: %v", err)
	}

	clusterWatcher.EnqueueCluster(cluster, "ADD")
	processed := clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())
	g.Eventually(func() bool {
		secretName := "e2e-cluster-avi-secret"
		secret, err := kubeClient.CoreV1().Secrets("e2e-test-ns").Get(context.Background(), secretName, metav1.GetOptions{})
		if err != nil {
			return false
		}

		requiredFields := []string{"username", "password", "controllerIP"}
		for _, field := range requiredFields {
			if _, exists := secret.Data[field]; !exists {
				return false
			}
		}

		expectedLabels := map[string]string{
			"ako.kubernetes.vmware.com/cluster":    "e2e-cluster",
			"ako.kubernetes.vmware.com/managed-by": "ako-infra",
		}
		for key, expectedValue := range expectedLabels {
			if actualValue, exists := secret.Labels[key]; !exists || actualValue != expectedValue {
				return false
			}
		}

		return true
	}, 15*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("â Cluster secret created successfully")

	t.Log("ð Phase 3: Resource State Validation")
	resourceChecks := []struct {
		name        string
		checkFunc   func() bool
		description string
	}{
		{
			name: "AddonInstall",
			checkFunc: func() bool {
				_, err := dynamicClient.Resource(AddonInstallGVR).
					Namespace(addon.VKSPublicNamespace).
					Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
				return err == nil
			},
			description: "Global AddonInstall exists",
		},
		{
			name: "WebhookConfiguration",
			checkFunc: func() bool {
				_, err := kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().Get(
					context.Background(), "ako-vks-cluster-webhook", metav1.GetOptions{})
				return err == nil
			},
			description: "MutatingWebhookConfiguration exists",
		},
		{
			name: "ClusterSecret",
			checkFunc: func() bool {
				_, err := kubeClient.CoreV1().Secrets("e2e-test-ns").Get(
					context.Background(), "e2e-cluster-avi-secret", metav1.GetOptions{})
				return err == nil
			},
			description: "Cluster secret exists",
		},
	}

	for _, check := range resourceChecks {
		g.Expect(check.checkFunc()).To(gomega.BeTrue(), check.description+" should be present")
		t.Logf("â %s validated", check.description)
	}

	t.Log("ð§¹ Phase 4: VKS Cleanup Simulation")

	close(stopCh)
	t.Log("â Shutdown signal sent")

	t.Log("ð§ Executing webhook cleanup...")
	err = webhook.CleanupWebhookConfiguration(kubeClient)
	if err != nil {
		t.Fatalf("Failed to cleanup webhook configuration: %v", err)
	}
	t.Log("â Webhook configuration cleaned up")

	t.Log("ð§ Executing addon cleanup...")
	err = addon.CleanupGlobalAddonInstall()
	if err != nil {
		t.Fatalf("Failed to cleanup global addon install: %v", err)
	}
	t.Log("â Global AddonInstall cleaned up")

	t.Log("ð Phase 5: Cleanup Verification")
	g.Eventually(func() bool {
		_, err := kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().Get(
			context.Background(), "ako-vks-cluster-webhook", metav1.GetOptions{})
		return err != nil // Should be deleted
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("â MutatingWebhookConfiguration deletion verified")

	// Verify AddonInstall was deleted
	g.Eventually(func() bool {
		_, err := dynamicClient.Resource(AddonInstallGVR).
			Namespace(addon.VKSPublicNamespace).
			Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
		return err != nil // Should be deleted
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("â Global AddonInstall deletion verified")

	// === Phase 6: Cluster Secret Cleanup (Cluster Deletion) ===
	t.Log("ðï¸ Phase 6: Cluster Secret Cleanup")

	// Step 9: Delete cluster (simulates cluster deletion)
	err = dynamicClient.Resource(ClusterGVR).Namespace("e2e-test-ns").Delete(context.Background(), "e2e-cluster", metav1.DeleteOptions{})
	if err != nil {
		t.Fatalf("Failed to delete cluster: %v", err)
	}

	// Process cluster DELETE event
	clusterWatcher.EnqueueCluster(cluster, "DELETE")
	processed = clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())

	// Verify cluster secret was deleted
	g.Eventually(func() bool {
		_, err := kubeClient.CoreV1().Secrets("e2e-test-ns").Get(
			context.Background(), "e2e-cluster-avi-secret", metav1.GetOptions{})
		return err != nil // Should be deleted
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("â Cluster secret deletion verified")

	// Stop cluster watcher
	clusterWatcher.Stop()
	t.Log("â Cluster watcher stopped")

	// === Final Verification ===
	t.Log("ð¯ Final State Verification")

	finalChecks := []struct {
		name        string
		checkFunc   func() bool
		description string
	}{
		{
			name: "AddonInstall_Deleted",
			checkFunc: func() bool {
				_, err := dynamicClient.Resource(AddonInstallGVR).
					Namespace(addon.VKSPublicNamespace).
					Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
				return err != nil // Should be deleted
			},
			description: "AddonInstall is deleted",
		},
		{
			name: "WebhookConfiguration_Deleted",
			checkFunc: func() bool {
				_, err := kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().Get(
					context.Background(), "ako-vks-cluster-webhook", metav1.GetOptions{})
				return err != nil // Should be deleted
			},
			description: "MutatingWebhookConfiguration is deleted",
		},
		{
			name: "ClusterSecret_Deleted",
			checkFunc: func() bool {
				_, err := kubeClient.CoreV1().Secrets("e2e-test-ns").Get(
					context.Background(), "e2e-cluster-avi-secret", metav1.GetOptions{})
				return err != nil // Should be deleted
			},
			description: "Cluster secret is deleted",
		},
	}

	for _, check := range finalChecks {
		g.Expect(check.checkFunc()).To(gomega.BeTrue(), check.description)
		t.Logf("â %s verified", check.description)
	}

	t.Log("ð === VKS E2E Creation-to-Cleanup test completed successfully ===")
	t.Log("ð Test Summary:")
	t.Log("   â VKS infrastructure startup")
	t.Log("   â Global addon install creation and management")
	t.Log("   â Webhook configuration lifecycle")
	t.Log("   â Cluster secret creation and management")
	t.Log("   â Complete cleanup on AKO shutdown")
	t.Log("   â Cluster-specific resource cleanup on cluster deletion")
	t.Log("   â All resources properly cleaned up")
}
