/*
 * Copyright ¬© 2025 Broadcom Inc. and/or its subsidiaries. All Rights Reserved.
 * All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*   http://www.apache.org/licenses/LICENSE-2.0
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

// @AI-Generated
// This test file was generated by Claude AI assistant.

package infratests

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"strings"
	"sync"
	"testing"
	"time"

	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-infra/addon"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-infra/ingestion"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-infra/webhook"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/k8s"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/lib"
	akoapisv1beta1 "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/apis/ako/v1beta1"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/utils"

	"github.com/onsi/gomega"

	v1beta1crdfake "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/client/v1beta1/clientset/versioned/fake"

	admissionv1 "k8s.io/api/admission/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/types"
	dynamicfake "k8s.io/client-go/dynamic/fake"
	"k8s.io/client-go/kubernetes"
	k8sfake "k8s.io/client-go/kubernetes/fake"
	"k8s.io/client-go/tools/cache"
)

// Global sync.Once to ensure informers are started only once across all tests
var (
	informerStartOnce sync.Once
	stopChInformers   chan struct{}
)

var (
	// Use the existing SupervisorCapability GVR from lib for VKS capability detection
	AviInfraSettingGVR = schema.GroupVersionResource{
		Group:    "ako.vmware.com",
		Version:  "v1beta1",
		Resource: "aviinfrasettings",
	}
	ClusterBootstrapGVR = schema.GroupVersionResource{
		Group:    "run.tanzu.vmware.com",
		Version:  "v1alpha3",
		Resource: "clusterbootstraps",
	}
)

// Reuse existing GVRs from lib
var (
	SupervisorCapabilityGVR = lib.SupervisorCapabilityGVR
	AddonInstallGVR         = lib.AddonInstallGVR
	ClusterGVR              = lib.ClusterGVR
)

// forceInformerCacheSync manually syncs a secret into the informer cache for testing
func forceInformerCacheSync(secret *corev1.Secret) {
	// Add secret to the informer cache manually
	informer := utils.GetInformers().SecretInformer.Informer()
	informer.GetStore().Add(secret)
}

// startInformersOnce starts informers only once using sync.Once
func startInformersOnce() {
	informerStartOnce.Do(func() {
		// Initialize the stop channel for informers
		stopChInformers = make(chan struct{})

		// Start the secret informer
		go func() {
			utils.GetInformers().SecretInformer.Informer().Run(stopChInformers)
		}()

		// Wait for secret informer cache to sync
		if !cache.WaitForCacheSync(stopChInformers, utils.GetInformers().SecretInformer.Informer().HasSynced) {
			// Log warning but don't fail - this is expected in test environment
			fmt.Printf("Warning: secret informer cache sync timed out (expected in test environment)\n")
		}
	})
}

// setupVKSIntegrationTest sets up the environment for VKS integration tests
func setupVKSIntegrationTest(t *testing.T) (*k8sfake.Clientset, *dynamicfake.FakeDynamicClient) {
	// Set VCF_CLUSTER environment variable to enable dynamic informers
	oldVCFCluster := os.Getenv("VCF_CLUSTER")
	os.Setenv("VCF_CLUSTER", "true")
	t.Cleanup(func() {
		if oldVCFCluster == "" {
			os.Unsetenv("VCF_CLUSTER")
		} else {
			os.Setenv("VCF_CLUSTER", oldVCFCluster)
		}
	})

	kubeClient := k8sfake.NewSimpleClientset()

	// Create avi-secret with admin credentials
	aviSecret := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      lib.AviSecret,
			Namespace: utils.GetAKONamespace(),
		},
		Type: corev1.SecretTypeOpaque,
		Data: map[string][]byte{
			"username":                 []byte("admin"),
			"password":                 []byte("admin123"),
			"certificateAuthorityData": []byte("-----BEGIN CERTIFICATE-----\nMIICertificateData...\n-----END CERTIFICATE-----"),
		},
	}
	_, err := kubeClient.CoreV1().Secrets(utils.GetAKONamespace()).Create(context.Background(), aviSecret, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create avi-secret: %v", err)
	}

	// Set up dynamic client with custom list kinds
	gvrToKind := map[schema.GroupVersionResource]string{
		SupervisorCapabilityGVR: "capabilitiesList",
		AddonInstallGVR:         "addoninstallsList",
		ClusterGVR:              "clustersList",
		AviInfraSettingGVR:      "aviinfrasettingsList",
		ClusterBootstrapGVR:     "clusterbootstrapsList",
	}

	dynamicClient := dynamicfake.NewSimpleDynamicClientWithCustomListKinds(runtime.NewScheme(), gvrToKind)
	lib.SetDynamicClientSet(dynamicClient)
	lib.NewDynamicInformers(dynamicClient, true)

	// Initialize regular informers needed by VKS cluster watcher (including namespace informer)
	registeredInformers := []string{
		utils.SecretInformer,
		utils.NSInformer,
	}
	utils.NewInformers(utils.KubeClientIntf{ClientSet: kubeClient}, registeredInformers, nil)

	// Start informers once using sync.Once to avoid multiple starts
	startInformersOnce()

	// Initialize CRD informers for AviInfraSetting
	akoControlConfig := lib.AKOControlConfig()

	// Create a test AviInfraSetting in the fake client
	testAviInfraSetting := createTypedAviInfraSetting("test-aviinfrasetting")
	v1beta1crdClient := v1beta1crdfake.NewSimpleClientset(testAviInfraSetting)
	akoControlConfig.SetCRDClientsetAndEnableInfraSettingParam(v1beta1crdClient)

	// Initialize CRD informers
	k8s.NewCRDInformers()

	// Start the AviInfraSetting informer and wait for cache sync
	stopCh := make(chan struct{})
	go func() {
		defer close(stopCh)
		time.Sleep(30 * time.Second) // Allow test to complete
	}()

	go lib.RunAviInfraSettingInformer(stopCh)

	// Give the informer time to sync
	time.Sleep(100 * time.Millisecond)

	// Set controller IP for testing
	lib.SetControllerIP("10.10.10.10")

	// Set up T1LR environment variable for tests
	os.Setenv("NSXT_T1_LR", "/orgs/test-org/projects/test-project/vpcs/test-vpc")

	return kubeClient, dynamicClient
}

// addClusterToInformerCache adds a cluster to the dynamic informer cache for tests
func addClusterToInformerCache(t *testing.T, cluster *unstructured.Unstructured) {
	if lib.GetDynamicInformers() != nil && lib.GetDynamicInformers().ClusterInformer != nil {
		err := lib.GetDynamicInformers().ClusterInformer.Informer().GetStore().Add(cluster)
		if err != nil {
			t.Logf("Warning: Failed to add cluster to dynamic informer cache: %v", err)
		}
	}
}

// addNamespaceToInformerCache adds a namespace to the namespace informer cache for tests
func addNamespaceToInformerCache(t *testing.T, namespace *corev1.Namespace) {
	if utils.GetInformers() != nil && utils.GetInformers().NSInformer != nil {
		err := utils.GetInformers().NSInformer.Informer().GetStore().Add(namespace)
		if err != nil {
			t.Logf("Warning: Failed to add namespace to informer cache: %v", err)
		}
	}
}

// waitForSecretInCache waits for a secret to appear in the informer cache or adds it manually for fake clients
func waitForSecretInCache(t *testing.T, secretName, namespace string, kubeClient kubernetes.Interface) {
	// In real environments, the secret should appear in cache automatically via watch events
	// In test environments with fake clients, we need to add it manually
	secret, err := kubeClient.CoreV1().Secrets(namespace).Get(context.Background(), secretName, metav1.GetOptions{})
	if err == nil && utils.GetInformers() != nil && utils.GetInformers().SecretInformer != nil {
		// Try to get from cache first
		_, err := utils.GetInformers().SecretInformer.Lister().Secrets(namespace).Get(secretName)
		if err != nil {
			// Not in cache, add it manually for tests
			err = utils.GetInformers().SecretInformer.Informer().GetStore().Add(secret)
			if err != nil {
				t.Logf("Warning: Failed to add secret %s/%s to informer cache: %v", namespace, secretName, err)
			}
		}
	}
}

// createAviInfraSetting creates an AviInfraSetting resource for testing
func createAviInfraSetting(name string) *unstructured.Unstructured {
	return &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "ako.vmware.com/v1beta1",
			"kind":       "AviInfraSetting",
			"metadata": map[string]interface{}{
				"name": name,
			},
			"spec": map[string]interface{}{
				"seGroup": map[string]interface{}{
					"name": "test-se-group",
				},
				"nsxSettings": map[string]interface{}{
					"t1lr": "/orgs/test-org/projects/test-project/vpcs/test-vpc",
				},
			},
		},
	}
}

// createTypedAviInfraSetting creates a typed AviInfraSetting for the fake CRD client
func createTypedAviInfraSetting(name string) *akoapisv1beta1.AviInfraSetting {
	t1lr := "/orgs/test-org/projects/test-project/vpcs/test-vpc"
	return &akoapisv1beta1.AviInfraSetting{
		TypeMeta: metav1.TypeMeta{
			APIVersion: "ako.vmware.com/v1beta1",
			Kind:       "AviInfraSetting",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name: name,
		},
		Spec: akoapisv1beta1.AviInfraSettingSpec{
			SeGroup: akoapisv1beta1.AviInfraSettingSeGroup{
				Name: "test-se-group",
			},
			NSXSettings: akoapisv1beta1.AviInfraNSXSettings{
				T1LR: &t1lr,
			},
		},
	}
}

// createClusterBootstrap creates a ClusterBootstrap resource for CNI detection
func createClusterBootstrap(name, namespace, cniRefName string) *unstructured.Unstructured {
	return &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "run.tanzu.vmware.com/v1alpha3",
			"kind":       "ClusterBootstrap",
			"metadata": map[string]interface{}{
				"name":      name,
				"namespace": namespace,
			},
			"spec": map[string]interface{}{
				"cni": map[string]interface{}{
					"refName": cniRefName,
				},
			},
		},
	}
}

// createVKSSupervisorCapability creates a VKS SupervisorCapability resource
// that matches the structure expected by lib.IsVKSCapabilityActivated()
func createVKSSupervisorCapability(name string) *unstructured.Unstructured {
	return &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "iaas.vmware.com/v1alpha1",
			"kind":       "SupervisorCapability",
			"metadata": map[string]interface{}{
				"name": name,
			},
			"spec": map[string]interface{}{
				"capability": "ako_vks",
				"version":    "v1.12.1",
			},
			"status": map[string]interface{}{
				"supervisor": map[string]interface{}{
					"supports_ako_vks_integration": map[string]interface{}{
						"activated": true,
					},
				},
			},
		},
	}
}

// createClusterResource creates a cluster.x-k8s.io Cluster resource
func createClusterResource(name, namespace, phase string, managed bool) *unstructured.Unstructured {
	cluster := &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "cluster.x-k8s.io/v1beta2",
			"kind":       "Cluster",
			"metadata": map[string]interface{}{
				"name":      name,
				"namespace": namespace,
				"uid":       "test-uid-123",
			},
			"status": map[string]interface{}{
				"phase": phase,
			},
		},
	}

	if managed {
		cluster.SetLabels(map[string]string{
			webhook.VKSManagedLabel: webhook.VKSManagedLabelValueTrue,
		})
	}

	return cluster
}

// TestVKSCapabilityToAddonFlow tests the full flow from VKS capability enablement to addon creation
func TestVKSCapabilityToAddonFlow(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	_, dynamicClient := setupVKSIntegrationTest(t)

	// Step 1: Create VKS SupervisorCapability
	capability := createVKSSupervisorCapability("ako-vks")
	_, err := dynamicClient.Resource(SupervisorCapabilityGVR).Create(context.Background(), capability, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create SupervisorCapability: %v", err)
	}

	// Step 2: Ensure global addon install is created
	err = addon.EnsureGlobalAddonInstall()
	if err != nil {
		t.Fatalf("Failed to ensure global addon install: %v", err)
	}

	// Step 3: Verify AddonInstall resource was created
	g.Eventually(func() bool {
		addonInstall, err := dynamicClient.Resource(AddonInstallGVR).
			Namespace(addon.VKSPublicNamespace).
			Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
		if err != nil {
			t.Logf("AddonInstall not found: %v", err)
			return false
		}

		// Verify basic addon structure
		name, _, _ := unstructured.NestedString(addonInstall.Object, "metadata", "name")
		namespace, _, _ := unstructured.NestedString(addonInstall.Object, "metadata", "namespace")

		return name == addon.AKOAddonInstallName && namespace == addon.VKSPublicNamespace
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))

	t.Log("‚úÖ VKS Capability to Addon flow completed successfully")
}

// TestVKSWebhookFunctionality tests the VKS webhook validation and labeling
func TestVKSWebhookFunctionality(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, _ := setupVKSIntegrationTest(t)

	// Create a namespace with ServiceEngineGroup annotation
	namespace := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "test-cluster-ns",
			Annotations: map[string]string{
				"ako.vmware.com/wcp-se-group": "test-se-group",
			},
		},
	}
	_, err := kubeClient.CoreV1().Namespaces().Create(context.Background(), namespace, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create namespace: %v", err)
	}

	// Create VKS webhook
	webhook := webhook.NewVKSClusterWebhook(kubeClient)

	// Test cluster that should be managed by VKS
	clusterObj := createClusterResource("test-cluster", "test-cluster-ns", "Provisioned", false)
	clusterBytes, _ := json.Marshal(clusterObj)

	admissionRequest := &admissionv1.AdmissionRequest{
		UID:       types.UID("test-uid"),
		Kind:      metav1.GroupVersionKind{Group: "cluster.x-k8s.io", Version: "v1beta2", Kind: "Cluster"},
		Namespace: "test-cluster-ns",
		Object:    runtime.RawExtension{Raw: clusterBytes},
		Operation: admissionv1.Create,
	}

	// Process admission request
	response := webhook.ProcessAdmissionRequest(admissionRequest)

	// Verify response
	g.Expect(response.Allowed).To(gomega.BeTrue())
	g.Expect(len(response.Patch)).To(gomega.BeNumerically(">", 0))

	// Verify patch adds VKS managed label
	var patches []map[string]interface{}
	err = json.Unmarshal(response.Patch, &patches)
	g.Expect(err).To(gomega.BeNil())

	foundVKSLabel := false
	for _, patch := range patches {
		if path, ok := patch["path"].(string); ok && path == "/metadata/labels" {
			if valueMap, ok := patch["value"].(map[string]interface{}); ok {
				if vksValue, exists := valueMap["ako.kubernetes.vmware.com/install"]; exists && vksValue == "true" {
					foundVKSLabel = true
					break
				}
			}
		}
	}
	g.Expect(foundVKSLabel).To(gomega.BeTrue())

	t.Log("‚úÖ VKS Webhook functionality validated successfully")
}

// TestVKSClusterLifecycleIntegration tests the full cluster lifecycle from creation to secret management
func TestVKSClusterLifecycleIntegration(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, dynamicClient := setupVKSIntegrationTest(t)

	// Step 1: Create required namespace with VKS annotations
	namespace := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "test-cluster-ns",
			Annotations: map[string]string{
				lib.WCPSEGroup:                 "test-se-group",
				lib.TenantAnnotation:           "test-tenant",
				lib.InfraSettingNameAnnotation: "test-aviinfrasetting",
			},
		},
	}
	_, err := kubeClient.CoreV1().Namespaces().Create(context.Background(), namespace, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create namespace: %v", err)
	}
	// Add namespace to informer cache
	addNamespaceToInformerCache(t, namespace)

	// Create AviInfraSetting resource in both clients
	aviInfraSetting := createAviInfraSetting("test-aviinfrasetting")
	_, err = dynamicClient.Resource(AviInfraSettingGVR).Create(context.Background(), aviInfraSetting, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create AviInfraSetting in dynamic client: %v", err)
	}

	// Create ClusterBootstrap for CNI detection
	clusterBootstrap := createClusterBootstrap("test-cluster", "test-cluster-ns", "antrea.tanzu.vmware.com.2.3.0+vmware.1-tkg.1")
	_, err = dynamicClient.Resource(ClusterBootstrapGVR).Namespace("test-cluster-ns").Create(context.Background(), clusterBootstrap, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create ClusterBootstrap: %v", err)
	}

	clusterWatcher := ingestion.NewVKSClusterWatcher(kubeClient, dynamicClient)
	clusterWatcher.SetTestMode(func(clusterNameWithUID, operationalTenant string) (*lib.ClusterCredentials, error) {
		return &lib.ClusterCredentials{
			Username: fmt.Sprintf("vks-cluster-%s-user", clusterNameWithUID),
			Password: "integration-test-password",
		}, nil
	})

	stopCh := make(chan struct{})
	defer close(stopCh)

	err = clusterWatcher.Start()
	if err != nil {
		t.Fatalf("Failed to start cluster watcher: %v", err)
	}

	// Create a VKS-managed cluster
	cluster := createClusterResource("test-cluster", "test-cluster-ns", "Provisioned", true)
	_, err = dynamicClient.Resource(ClusterGVR).Namespace("test-cluster-ns").Create(context.Background(), cluster, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create cluster: %v", err)
	}
	// Add cluster to informer cache
	addClusterToInformerCache(t, cluster)

	clusterWatcher.EnqueueCluster(cluster, "ADD")
	processed := clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())

	// Verify cluster secret was created
	g.Eventually(func() bool {
		secretName := "test-cluster-avi-secret"
		secret, err := kubeClient.CoreV1().Secrets("test-cluster-ns").Get(context.Background(), secretName, metav1.GetOptions{})
		if err != nil {
			t.Logf("Secret not found: %v", err)
			return false
		}

		expectedFields := []string{"username", "controllerIP", "password"}
		for _, field := range expectedFields {
			if _, exists := secret.Data[field]; !exists {
				t.Logf("Secret missing field: %s", field)
				return false
			}
		}

		usernameBytes, exists := secret.Data["username"]
		if !exists {
			return false
		}

		actualUsername := string(usernameBytes)
		if strings.HasPrefix(actualUsername, "vks-cluster-test-cluster-") && strings.HasSuffix(actualUsername, "-user") {
			// Manually sync the secret to informer cache for testing
			forceInformerCacheSync(secret)
			return true
		}
		return false
	}, 15*time.Second, 1*time.Second).Should(gomega.Equal(true))

	// Test cluster opt-out
	cluster.SetLabels(map[string]string{
		webhook.VKSManagedLabel: webhook.VKSManagedLabelValueFalse,
	})
	_, err = dynamicClient.Resource(ClusterGVR).Namespace("test-cluster-ns").Update(context.Background(), cluster, metav1.UpdateOptions{})
	if err != nil {
		t.Fatalf("Failed to update cluster: %v", err)
	}

	clusterWatcher.EnqueueCluster(cluster, "UPDATE")
	processed = clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())

	// Verify secret was cleaned up
	g.Eventually(func() bool {
		secretName := "test-cluster-avi-secret"
		_, err := kubeClient.CoreV1().Secrets("test-cluster-ns").Get(context.Background(), secretName, metav1.GetOptions{})
		return err != nil // Secret should be deleted
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))

	// Test cluster deletion
	err = dynamicClient.Resource(ClusterGVR).Namespace("test-cluster-ns").Delete(context.Background(), "test-cluster", metav1.DeleteOptions{})
	if err != nil {
		t.Fatalf("Failed to delete cluster: %v", err)
	}

	clusterWatcher.EnqueueCluster(cluster, "DELETE")
	processed = clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())

	clusterWatcher.Stop()

	t.Log("‚úÖ VKS Cluster lifecycle integration test completed successfully")
}

// TestVKSEndToEndIntegration tests the complete VKS integration flow
func TestVKSEndToEndIntegration(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, dynamicClient := setupVKSIntegrationTest(t)

	capability := createVKSSupervisorCapability("ako-vks")
	_, err := dynamicClient.Resource(SupervisorCapabilityGVR).Create(context.Background(), capability, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create SupervisorCapability: %v", err)
	}

	err = addon.EnsureGlobalAddonInstall()
	if err != nil {
		t.Fatalf("Failed to ensure global addon install: %v", err)
	}
	g.Eventually(func() bool {
		_, err := dynamicClient.Resource(AddonInstallGVR).
			Namespace(addon.VKSPublicNamespace).
			Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
		return err == nil
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))

	namespace := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "vks-test-ns",
			Annotations: map[string]string{
				lib.WCPSEGroup:                 "test-se-group",
				lib.TenantAnnotation:           "test-tenant",
				lib.InfraSettingNameAnnotation: "test-aviinfrasetting",
			},
		},
	}
	_, err = kubeClient.CoreV1().Namespaces().Create(context.Background(), namespace, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create namespace: %v", err)
	}
	// Add namespace to informer cache
	addNamespaceToInformerCache(t, namespace)

	// Create ClusterBootstrap for CNI detection
	clusterBootstrap := createClusterBootstrap("vks-cluster", "vks-test-ns", "antrea.tanzu.vmware.com.2.3.0+vmware.1-tkg.1")
	_, err = dynamicClient.Resource(ClusterBootstrapGVR).Namespace("vks-test-ns").Create(context.Background(), clusterBootstrap, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create ClusterBootstrap: %v", err)
	}

	clusterWatcher := ingestion.NewVKSClusterWatcher(kubeClient, dynamicClient)
	clusterWatcher.SetTestMode(func(clusterNameWithUID, operationalTenant string) (*lib.ClusterCredentials, error) {
		return &lib.ClusterCredentials{
			Username: fmt.Sprintf("vks-cluster-%s-user", clusterNameWithUID),
			Password: "integration-test-password",
		}, nil
	})

	stopCh := make(chan struct{})
	defer close(stopCh)

	err = clusterWatcher.Start()
	if err != nil {
		t.Fatalf("Failed to start cluster watcher: %v", err)
	}

	cluster := createClusterResource("vks-cluster", "vks-test-ns", "Provisioned", true)
	_, err = dynamicClient.Resource(ClusterGVR).Namespace("vks-test-ns").Create(context.Background(), cluster, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create cluster: %v", err)
	}
	// Add cluster to informer cache
	addClusterToInformerCache(t, cluster)

	clusterWatcher.EnqueueCluster(cluster, "ADD")
	processed := clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())
	g.Eventually(func() bool {
		secretName := "vks-cluster-avi-secret"
		secret, err := kubeClient.CoreV1().Secrets("vks-test-ns").Get(context.Background(), secretName, metav1.GetOptions{})
		if err != nil {
			return false
		}

		requiredFields := []string{"username", "password", "controllerIP"}
		for _, field := range requiredFields {
			if _, exists := secret.Data[field]; !exists {
				t.Logf("Secret missing required field: %s", field)
				return false
			}
		}

		expectedLabels := map[string]string{
			"ako.kubernetes.vmware.com/cluster":    "vks-cluster",
			"ako.kubernetes.vmware.com/managed-by": "ako-infra",
		}

		for key, expectedValue := range expectedLabels {
			if actualValue, exists := secret.Labels[key]; !exists || actualValue != expectedValue {
				t.Logf("Secret label mismatch: %s expected=%s actual=%s", key, expectedValue, actualValue)
				return false
			}
		}

		return true
	}, 15*time.Second, 1*time.Second).Should(gomega.Equal(true))

	clusterWatcher.Stop()

	t.Log("‚úÖ VKS End-to-End integration test completed successfully")
}

// TestVKSErrorHandling tests error scenarios in VKS integration
func TestVKSErrorHandling(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, dynamicClient := setupVKSIntegrationTest(t)

	unmanageableNamespace := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "unmanageable-ns",
		},
	}
	_, err := kubeClient.CoreV1().Namespaces().Create(context.Background(), unmanageableNamespace, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create namespace: %v", err)
	}

	webhookHandler := webhook.NewVKSClusterWebhook(kubeClient)

	cluster := createClusterResource("unmanageable-cluster", "unmanageable-ns", "Provisioned", false)
	clusterBytes, _ := json.Marshal(cluster)

	admissionRequest := &admissionv1.AdmissionRequest{
		UID:       types.UID("test-uid"),
		Kind:      metav1.GroupVersionKind{Group: "cluster.x-k8s.io", Version: "v1beta2", Kind: "Cluster"},
		Namespace: "unmanageable-ns",
		Object:    runtime.RawExtension{Raw: clusterBytes},
		Operation: admissionv1.Create,
	}

	response := webhookHandler.ProcessAdmissionRequest(admissionRequest)

	g.Expect(response.Allowed).To(gomega.BeTrue())
	g.Expect(len(response.Patch)).To(gomega.Equal(0))

	// Test missing admin credentials
	err = kubeClient.CoreV1().Secrets(utils.GetAKONamespace()).Delete(context.Background(), lib.AviSecret, metav1.DeleteOptions{})
	if err != nil {
		t.Fatalf("Failed to delete avi-secret: %v", err)
	}

	clusterWatcher := ingestion.NewVKSClusterWatcher(kubeClient, dynamicClient)
	managedCluster := createClusterResource("test-cluster", "vks-test-ns", "Provisioned", true)

	ctx := context.Background()
	err = clusterWatcher.UpsertAviCredentialsSecret(ctx, managedCluster)
	g.Expect(err).To(gomega.HaveOccurred())
	g.Expect(err.Error()).To(gomega.ContainSubstring("failed to build cluster configuration"))

	t.Log("‚úÖ VKS Error handling test completed successfully")
}

// TestVKSIdempotencyIntegration tests that VKS operations are idempotent
func TestVKSIdempotencyIntegration(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, dynamicClient := setupVKSIntegrationTest(t)

	// Create required namespace with VKS annotations
	namespace := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "test-ns",
			Annotations: map[string]string{
				lib.WCPSEGroup:                 "test-se-group",
				lib.TenantAnnotation:           "test-tenant",
				lib.InfraSettingNameAnnotation: "test-aviinfrasetting",
			},
		},
	}
	_, err := kubeClient.CoreV1().Namespaces().Create(context.Background(), namespace, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create namespace: %v", err)
	}
	// Add namespace to informer cache
	addNamespaceToInformerCache(t, namespace)

	// Create ClusterBootstrap for CNI detection
	clusterBootstrap := createClusterBootstrap("idempotent-cluster", "test-ns", "antrea.tanzu.vmware.com.2.3.0+vmware.1-tkg.1")
	_, err = dynamicClient.Resource(ClusterBootstrapGVR).Namespace("test-ns").Create(context.Background(), clusterBootstrap, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create ClusterBootstrap: %v", err)
	}

	err = addon.EnsureGlobalAddonInstall()
	if err != nil {
		t.Fatalf("First addon creation failed: %v", err)
	}

	err = addon.EnsureGlobalAddonInstall()
	if err != nil {
		t.Fatalf("Second addon creation failed: %v", err)
	}
	addons, err := dynamicClient.Resource(AddonInstallGVR).Namespace(addon.VKSPublicNamespace).List(context.Background(), metav1.ListOptions{})
	if err != nil {
		t.Fatalf("Failed to list addons: %v", err)
	}
	g.Expect(len(addons.Items)).To(gomega.Equal(1))

	clusterWatcher := ingestion.NewVKSClusterWatcher(kubeClient, dynamicClient)
	clusterWatcher.SetTestMode(func(clusterNameWithUID, operationalTenant string) (*lib.ClusterCredentials, error) {
		return &lib.ClusterCredentials{
			Username: fmt.Sprintf("vks-cluster-%s-user", clusterNameWithUID),
			Password: "integration-test-password",
		}, nil
	})

	cluster := createClusterResource("idempotent-cluster", "test-ns", "Provisioned", true)

	ctx := context.Background()

	err = clusterWatcher.UpsertAviCredentialsSecret(ctx, cluster)
	if err != nil {
		t.Fatalf("Expected secret creation to succeed with mock credentials, got: %v", err)
	}

	// Manually sync the created secret to the informer cache for testing
	secretName := "idempotent-cluster-avi-secret"
	secret, err := kubeClient.CoreV1().Secrets("test-ns").Get(ctx, secretName, metav1.GetOptions{})
	if err != nil {
		t.Fatalf("Failed to get created secret: %v", err)
	}
	forceInformerCacheSync(secret)

	err = clusterWatcher.UpsertAviCredentialsSecret(ctx, cluster)
	if err != nil {
		t.Fatalf("Expected second secret creation to be idempotent, got: %v", err)
	}

	t.Log("‚úÖ VKS Idempotency test completed - validated secret creation idempotency")
}

// TestVKSE2ECreationToCleanup tests the full E2E flow from VKS infrastructure startup to complete cleanup
func TestVKSE2ECreationToCleanup(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, dynamicClient := setupVKSIntegrationTest(t)

	t.Log("üöÄ Phase 1: VKS Infrastructure Startup")

	capability := createVKSSupervisorCapability("ako-vks")
	_, err := dynamicClient.Resource(SupervisorCapabilityGVR).Create(context.Background(), capability, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create SupervisorCapability: %v", err)
	}
	t.Log("‚úÖ VKS SupervisorCapability created")

	err = addon.EnsureGlobalAddonInstall()
	if err != nil {
		t.Fatalf("Failed to ensure global addon install: %v", err)
	}
	g.Eventually(func() bool {
		_, err := dynamicClient.Resource(AddonInstallGVR).
			Namespace(addon.VKSPublicNamespace).
			Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
		return err == nil
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("‚úÖ Global AddonInstall created")

	err = webhook.CreateWebhookConfiguration(kubeClient)
	if err != nil {
		t.Fatalf("Failed to create webhook configuration: %v", err)
	}
	g.Eventually(func() bool {
		_, err := kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().Get(
			context.Background(), "ako-vks-cluster-webhook", metav1.GetOptions{})
		return err == nil
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("‚úÖ VKS webhook configuration created")

	t.Log("üîÑ Phase 2: Cluster Lifecycle Management")
	namespace := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "e2e-test-ns",
			Annotations: map[string]string{
				lib.WCPSEGroup:                 "test-se-group",
				lib.TenantAnnotation:           "test-tenant",
				lib.InfraSettingNameAnnotation: "test-aviinfrasetting",
			},
		},
	}
	_, err = kubeClient.CoreV1().Namespaces().Create(context.Background(), namespace, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create namespace: %v", err)
	}
	// Add namespace to informer cache
	addNamespaceToInformerCache(t, namespace)

	// Create ClusterBootstrap for CNI detection
	clusterBootstrap := createClusterBootstrap("e2e-cluster", "e2e-test-ns", "antrea.tanzu.vmware.com.2.3.0+vmware.1-tkg.1")
	_, err = dynamicClient.Resource(ClusterBootstrapGVR).Namespace("e2e-test-ns").Create(context.Background(), clusterBootstrap, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create ClusterBootstrap: %v", err)
	}

	clusterWatcher := ingestion.NewVKSClusterWatcher(kubeClient, dynamicClient)
	clusterWatcher.SetTestMode(func(clusterNameWithUID, operationalTenant string) (*lib.ClusterCredentials, error) {
		return &lib.ClusterCredentials{
			Username: fmt.Sprintf("vks-cluster-%s-user", clusterNameWithUID),
			Password: "integration-test-password",
		}, nil
	})

	stopCh := make(chan struct{})

	err = clusterWatcher.Start()
	if err != nil {
		t.Fatalf("Failed to start cluster watcher: %v", err)
	}
	t.Log("‚úÖ VKS cluster watcher started")

	cluster := createClusterResource("e2e-cluster", "e2e-test-ns", "Provisioned", true)
	_, err = dynamicClient.Resource(ClusterGVR).Namespace("e2e-test-ns").Create(context.Background(), cluster, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create cluster: %v", err)
	}
	// Add cluster to informer cache
	addClusterToInformerCache(t, cluster)

	clusterWatcher.EnqueueCluster(cluster, "ADD")
	processed := clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())
	g.Eventually(func() bool {
		secretName := "e2e-cluster-avi-secret"
		secret, err := kubeClient.CoreV1().Secrets("e2e-test-ns").Get(context.Background(), secretName, metav1.GetOptions{})
		if err != nil {
			return false
		}

		requiredFields := []string{"username", "password", "controllerIP"}
		for _, field := range requiredFields {
			if _, exists := secret.Data[field]; !exists {
				return false
			}
		}

		expectedLabels := map[string]string{
			"ako.kubernetes.vmware.com/cluster":    "e2e-cluster",
			"ako.kubernetes.vmware.com/managed-by": "ako-infra",
		}
		for key, expectedValue := range expectedLabels {
			if actualValue, exists := secret.Labels[key]; !exists || actualValue != expectedValue {
				return false
			}
		}

		return true
	}, 15*time.Second, 1*time.Second).Should(gomega.Equal(true))

	// Ensure secret is in informer cache for fake client tests
	waitForSecretInCache(t, "e2e-cluster-avi-secret", "e2e-test-ns", kubeClient)

	t.Log("‚úÖ Cluster secret created successfully")

	t.Log("üîç Phase 3: Resource State Validation")
	resourceChecks := []struct {
		name        string
		checkFunc   func() bool
		description string
	}{
		{
			name: "AddonInstall",
			checkFunc: func() bool {
				_, err := dynamicClient.Resource(AddonInstallGVR).
					Namespace(addon.VKSPublicNamespace).
					Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
				return err == nil
			},
			description: "Global AddonInstall exists",
		},
		{
			name: "WebhookConfiguration",
			checkFunc: func() bool {
				_, err := kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().Get(
					context.Background(), "ako-vks-cluster-webhook", metav1.GetOptions{})
				return err == nil
			},
			description: "MutatingWebhookConfiguration exists",
		},
		{
			name: "ClusterSecret",
			checkFunc: func() bool {
				_, err := kubeClient.CoreV1().Secrets("e2e-test-ns").Get(
					context.Background(), "e2e-cluster-avi-secret", metav1.GetOptions{})
				return err == nil
			},
			description: "Cluster secret exists",
		},
	}

	for _, check := range resourceChecks {
		g.Expect(check.checkFunc()).To(gomega.BeTrue(), check.description+" should be present")
		t.Logf("‚úÖ %s validated", check.description)
	}

	t.Log("üßπ Phase 4: VKS Cleanup Simulation")

	close(stopCh)
	t.Log("‚úÖ Shutdown signal sent")

	t.Log("üîß Executing webhook cleanup...")
	err = webhook.CleanupWebhookConfiguration(kubeClient)
	if err != nil {
		t.Fatalf("Failed to cleanup webhook configuration: %v", err)
	}
	t.Log("‚úÖ Webhook configuration cleaned up")

	t.Log("üîß Executing addon cleanup...")
	err = addon.CleanupGlobalAddonInstall()
	if err != nil {
		t.Fatalf("Failed to cleanup global addon install: %v", err)
	}
	t.Log("‚úÖ Global AddonInstall cleaned up")

	t.Log("üîç Phase 5: Cleanup Verification")
	g.Eventually(func() bool {
		_, err := kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().Get(
			context.Background(), "ako-vks-cluster-webhook", metav1.GetOptions{})
		return err != nil // Should be deleted
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("‚úÖ MutatingWebhookConfiguration deletion verified")

	// Verify AddonInstall was deleted
	g.Eventually(func() bool {
		_, err := dynamicClient.Resource(AddonInstallGVR).
			Namespace(addon.VKSPublicNamespace).
			Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
		return err != nil // Should be deleted
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("‚úÖ Global AddonInstall deletion verified")

	// === Phase 6: Cluster Secret Cleanup (Cluster Deletion) ===
	t.Log("üóëÔ∏è Phase 6: Cluster Secret Cleanup")

	// Step 9: Delete cluster (simulates cluster deletion)
	err = dynamicClient.Resource(ClusterGVR).Namespace("e2e-test-ns").Delete(context.Background(), "e2e-cluster", metav1.DeleteOptions{})
	if err != nil {
		t.Fatalf("Failed to delete cluster: %v", err)
	}

	// Remove cluster from informer cache to simulate real deletion
	if lib.GetDynamicInformers() != nil && lib.GetDynamicInformers().ClusterInformer != nil {
		err = lib.GetDynamicInformers().ClusterInformer.Informer().GetStore().Delete(cluster)
		if err != nil {
			t.Logf("Warning: Failed to remove cluster from dynamic informer cache: %v", err)
		}
	}

	// Process cluster DELETE event
	clusterWatcher.EnqueueCluster(cluster, "DELETE")
	processed = clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())

	// Verify cluster secret was deleted
	g.Eventually(func() bool {
		_, err := kubeClient.CoreV1().Secrets("e2e-test-ns").Get(
			context.Background(), "e2e-cluster-avi-secret", metav1.GetOptions{})
		return err != nil // Should be deleted
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("‚úÖ Cluster secret deletion verified")

	// Stop cluster watcher
	clusterWatcher.Stop()
	t.Log("‚úÖ Cluster watcher stopped")

	// === Final Verification ===
	t.Log("üéØ Final State Verification")

	finalChecks := []struct {
		name        string
		checkFunc   func() bool
		description string
	}{
		{
			name: "AddonInstall_Deleted",
			checkFunc: func() bool {
				_, err := dynamicClient.Resource(AddonInstallGVR).
					Namespace(addon.VKSPublicNamespace).
					Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
				return err != nil // Should be deleted
			},
			description: "AddonInstall is deleted",
		},
		{
			name: "WebhookConfiguration_Deleted",
			checkFunc: func() bool {
				_, err := kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().Get(
					context.Background(), "ako-vks-cluster-webhook", metav1.GetOptions{})
				return err != nil // Should be deleted
			},
			description: "MutatingWebhookConfiguration is deleted",
		},
		{
			name: "ClusterSecret_Deleted",
			checkFunc: func() bool {
				_, err := kubeClient.CoreV1().Secrets("e2e-test-ns").Get(
					context.Background(), "e2e-cluster-avi-secret", metav1.GetOptions{})
				return err != nil // Should be deleted
			},
			description: "Cluster secret is deleted",
		},
	}

	for _, check := range finalChecks {
		g.Expect(check.checkFunc()).To(gomega.BeTrue(), check.description)
		t.Logf("‚úÖ %s verified", check.description)
	}

	t.Log("üéâ === VKS E2E Creation-to-Cleanup test completed successfully ===")
	t.Log("üìã Test Summary:")
	t.Log("   ‚úÖ VKS infrastructure startup")
	t.Log("   ‚úÖ Global addon install creation and management")
	t.Log("   ‚úÖ Webhook configuration lifecycle")
	t.Log("   ‚úÖ Cluster secret creation and management")
	t.Log("   ‚úÖ Complete cleanup on AKO shutdown")
	t.Log("   ‚úÖ Cluster-specific resource cleanup on cluster deletion")
	t.Log("   ‚úÖ All resources properly cleaned up")
}
