/*
 * Copyright © 2025 Broadcom Inc. and/or its subsidiaries. All Rights Reserved.
 * All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*   http://www.apache.org/licenses/LICENSE-2.0
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

// @AI-Generated
// This test file was generated by Claude AI assistant.

package infratests

import (
	"context"
	"encoding/json"
	"testing"
	"time"

	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-infra/addon"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-infra/ingestion"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-infra/webhook"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/lib"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/utils"

	"github.com/onsi/gomega"
	admissionv1 "k8s.io/api/admission/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/types"
	dynamicfake "k8s.io/client-go/dynamic/fake"
	k8sfake "k8s.io/client-go/kubernetes/fake"
)

// VKS GVRs for testing
var (
	SupervisorCapabilityGVR = schema.GroupVersionResource{
		Group:    "run.tanzu.vmware.com",
		Version:  "v1alpha3",
		Resource: "supervisorcapabilities",
	}
	AddonInstallGVR = schema.GroupVersionResource{
		Group:    "addons.kubernetes.vmware.com",
		Version:  "v1alpha1",
		Resource: "addoninstalls",
	}
	ClusterGVR = schema.GroupVersionResource{
		Group:    "cluster.x-k8s.io",
		Version:  "v1beta2",
		Resource: "clusters",
	}
)

// setupVKSIntegrationTest sets up the environment for VKS integration tests
func setupVKSIntegrationTest(t *testing.T) (*k8sfake.Clientset, *dynamicfake.FakeDynamicClient) {
	kubeClient := k8sfake.NewSimpleClientset()

	// Create avi-secret with admin credentials
	aviSecret := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      lib.AviSecret,
			Namespace: utils.GetAKONamespace(),
		},
		Type: corev1.SecretTypeOpaque,
		Data: map[string][]byte{
			"username":                 []byte("admin"),
			"password":                 []byte("admin123"),
			"authtoken":                []byte("test-auth-token-12345"),
			"certificateAuthorityData": []byte("-----BEGIN CERTIFICATE-----\nMIICertificateData...\n-----END CERTIFICATE-----"),
		},
	}
	_, err := kubeClient.CoreV1().Secrets(utils.GetAKONamespace()).Create(context.Background(), aviSecret, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create avi-secret: %v", err)
	}

	// Set up dynamic client with custom list kinds
	gvrToKind := map[schema.GroupVersionResource]string{
		SupervisorCapabilityGVR: "supervisorcapabilitiesList",
		AddonInstallGVR:         "addoninstallsList",
		ClusterGVR:              "clustersList",
	}

	dynamicClient := dynamicfake.NewSimpleDynamicClientWithCustomListKinds(runtime.NewScheme(), gvrToKind)
	lib.SetDynamicClientSet(dynamicClient)
	lib.NewDynamicInformers(dynamicClient, true)

	// Set controller IP for testing
	lib.SetControllerIP("10.10.10.10")

	return kubeClient, dynamicClient
}

// createVKSSupervisorCapability creates a VKS SupervisorCapability resource
func createVKSSupervisorCapability(name string) *unstructured.Unstructured {
	return &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "run.tanzu.vmware.com/v1alpha3",
			"kind":       "SupervisorCapability",
			"metadata": map[string]interface{}{
				"name": name,
			},
			"spec": map[string]interface{}{
				"capability": "ako_vks",
				"version":    "v1.12.1",
			},
		},
	}
}

// createClusterResource creates a cluster.x-k8s.io Cluster resource
func createClusterResource(name, namespace, phase string, managed bool) *unstructured.Unstructured {
	cluster := &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "cluster.x-k8s.io/v1beta1",
			"kind":       "Cluster",
			"metadata": map[string]interface{}{
				"name":      name,
				"namespace": namespace,
			},
			"status": map[string]interface{}{
				"phase": phase,
			},
		},
	}

	if managed {
		cluster.SetLabels(map[string]string{
			webhook.VKSManagedLabel: webhook.VKSManagedLabelValueTrue,
		})
	}

	return cluster
}

// TestVKSCapabilityToAddonFlow tests the full flow from VKS capability enablement to addon creation
func TestVKSCapabilityToAddonFlow(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	_, dynamicClient := setupVKSIntegrationTest(t)

	// Step 1: Create VKS SupervisorCapability
	capability := createVKSSupervisorCapability("ako-vks")
	_, err := dynamicClient.Resource(SupervisorCapabilityGVR).Create(context.Background(), capability, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create SupervisorCapability: %v", err)
	}

	// Step 2: Ensure global addon install is created
	err = addon.EnsureGlobalAddonInstall()
	if err != nil {
		t.Fatalf("Failed to ensure global addon install: %v", err)
	}

	// Step 3: Verify AddonInstall resource was created
	g.Eventually(func() bool {
		addonInstall, err := dynamicClient.Resource(AddonInstallGVR).
			Namespace(addon.VKSPublicNamespace).
			Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
		if err != nil {
			t.Logf("AddonInstall not found: %v", err)
			return false
		}

		// Verify basic addon structure
		name, _, _ := unstructured.NestedString(addonInstall.Object, "metadata", "name")
		namespace, _, _ := unstructured.NestedString(addonInstall.Object, "metadata", "namespace")

		return name == addon.AKOAddonInstallName && namespace == addon.VKSPublicNamespace
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))

	t.Log("✅ VKS Capability to Addon flow completed successfully")
}

// TestVKSWebhookFunctionality tests the VKS webhook validation and labeling
func TestVKSWebhookFunctionality(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, _ := setupVKSIntegrationTest(t)

	// Create a namespace with ServiceEngineGroup annotation
	namespace := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "test-cluster-ns",
			Annotations: map[string]string{
				"ako.vmware.com/wcp-se-group": "test-se-group",
			},
		},
	}
	_, err := kubeClient.CoreV1().Namespaces().Create(context.Background(), namespace, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create namespace: %v", err)
	}

	// Create VKS webhook
	webhook := webhook.NewVKSClusterWebhook(kubeClient)

	// Test cluster that should be managed by VKS
	clusterObj := createClusterResource("test-cluster", "test-cluster-ns", "Provisioned", false)
	clusterBytes, _ := json.Marshal(clusterObj)

	admissionRequest := &admissionv1.AdmissionRequest{
		UID:       types.UID("test-uid"),
		Kind:      metav1.GroupVersionKind{Group: "cluster.x-k8s.io", Version: "v1beta2", Kind: "Cluster"},
		Namespace: "test-cluster-ns",
		Object:    runtime.RawExtension{Raw: clusterBytes},
		Operation: admissionv1.Create,
	}

	// Process admission request
	response := webhook.ProcessAdmissionRequest(admissionRequest)

	// Verify response
	g.Expect(response.Allowed).To(gomega.BeTrue())
	g.Expect(len(response.Patch)).To(gomega.BeNumerically(">", 0))

	// Verify patch adds VKS managed label
	var patches []map[string]interface{}
	err = json.Unmarshal(response.Patch, &patches)
	g.Expect(err).To(gomega.BeNil())

	foundVKSLabel := false
	for _, patch := range patches {
		if path, ok := patch["path"].(string); ok && path == "/metadata/labels" {
			if valueMap, ok := patch["value"].(map[string]interface{}); ok {
				if vksValue, exists := valueMap["ako.kubernetes.vmware.com/install"]; exists && vksValue == "true" {
					foundVKSLabel = true
					break
				}
			}
		}
	}
	g.Expect(foundVKSLabel).To(gomega.BeTrue())

	t.Log("✅ VKS Webhook functionality validated successfully")
}

// TestVKSClusterLifecycleIntegration tests the full cluster lifecycle from creation to secret management
func TestVKSClusterLifecycleIntegration(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, dynamicClient := setupVKSIntegrationTest(t)

	// Step 1: Create VKS cluster watcher
	clusterWatcher := ingestion.NewVKSClusterWatcher(kubeClient, dynamicClient)

	// Start the watcher
	stopCh := make(chan struct{})
	defer close(stopCh)

	err := clusterWatcher.Start(stopCh)
	if err != nil {
		t.Fatalf("Failed to start cluster watcher: %v", err)
	}

	// Step 2: Create a VKS-managed cluster
	cluster := createClusterResource("test-cluster", "test-cluster-ns", "Provisioned", true)
	_, err = dynamicClient.Resource(ClusterGVR).Namespace("test-cluster-ns").Create(context.Background(), cluster, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create cluster: %v", err)
	}

	// Step 3: Simulate cluster event processing
	clusterWatcher.EnqueueCluster(cluster, "ADD")

	// Process the event
	processed := clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())

	// Step 4: Verify cluster secret was created
	g.Eventually(func() bool {
		secretName := "test-cluster-avi-secret"
		secret, err := kubeClient.CoreV1().Secrets("test-cluster-ns").Get(context.Background(), secretName, metav1.GetOptions{})
		if err != nil {
			t.Logf("Secret not found: %v", err)
			return false
		}

		// Verify secret contains expected fields
		expectedFields := []string{"username", "controllerIP", "authtoken"}
		for _, field := range expectedFields {
			if _, exists := secret.Data[field]; !exists {
				t.Logf("Secret missing field: %s", field)
				return false
			}
		}

		// Verify username is from admin credentials
		usernameBytes, exists := secret.Data["username"]
		if !exists {
			return false
		}

		// The secret data is stored as raw bytes (not base64 encoded)
		return string(usernameBytes) == "admin"
	}, 15*time.Second, 1*time.Second).Should(gomega.Equal(true))

	// Step 5: Test cluster opt-out (change label to false)
	cluster.SetLabels(map[string]string{
		webhook.VKSManagedLabel: webhook.VKSManagedLabelValueFalse,
	})
	_, err = dynamicClient.Resource(ClusterGVR).Namespace("test-cluster-ns").Update(context.Background(), cluster, metav1.UpdateOptions{})
	if err != nil {
		t.Fatalf("Failed to update cluster: %v", err)
	}

	// Simulate UPDATE event
	clusterWatcher.EnqueueCluster(cluster, "UPDATE")
	processed = clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())

	// Step 6: Verify secret was cleaned up
	g.Eventually(func() bool {
		secretName := "test-cluster-avi-secret"
		_, err := kubeClient.CoreV1().Secrets("test-cluster-ns").Get(context.Background(), secretName, metav1.GetOptions{})
		return err != nil // Secret should be deleted
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))

	// Step 7: Test cluster deletion
	err = dynamicClient.Resource(ClusterGVR).Namespace("test-cluster-ns").Delete(context.Background(), "test-cluster", metav1.DeleteOptions{})
	if err != nil {
		t.Fatalf("Failed to delete cluster: %v", err)
	}

	// Simulate DELETE event
	clusterWatcher.EnqueueCluster(cluster, "DELETE")
	processed = clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())

	clusterWatcher.Stop()

	t.Log("✅ VKS Cluster lifecycle integration test completed successfully")
}

// TestVKSEndToEndIntegration tests the complete VKS integration flow
func TestVKSEndToEndIntegration(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, dynamicClient := setupVKSIntegrationTest(t)

	// Step 1: Enable VKS capability
	capability := createVKSSupervisorCapability("ako-vks")
	_, err := dynamicClient.Resource(SupervisorCapabilityGVR).Create(context.Background(), capability, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create SupervisorCapability: %v", err)
	}

	// Step 2: Ensure global addon is created
	err = addon.EnsureGlobalAddonInstall()
	if err != nil {
		t.Fatalf("Failed to ensure global addon install: %v", err)
	}

	// Step 3: Verify addon was created
	g.Eventually(func() bool {
		_, err := dynamicClient.Resource(AddonInstallGVR).
			Namespace(addon.VKSPublicNamespace).
			Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
		return err == nil
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))

	// Step 4: Create namespace with required annotations
	namespace := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "vks-test-ns",
			Annotations: map[string]string{
				"ako.vmware.com/wcp-se-group": "test-se-group",
			},
		},
	}
	_, err = kubeClient.CoreV1().Namespaces().Create(context.Background(), namespace, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create namespace: %v", err)
	}

	// Step 5: Create and start cluster watcher
	clusterWatcher := ingestion.NewVKSClusterWatcher(kubeClient, dynamicClient)
	stopCh := make(chan struct{})
	defer close(stopCh)

	err = clusterWatcher.Start(stopCh)
	if err != nil {
		t.Fatalf("Failed to start cluster watcher: %v", err)
	}

	// Step 6: Create a cluster (simulating webhook labeling)
	cluster := createClusterResource("vks-cluster", "vks-test-ns", "Provisioned", true)
	_, err = dynamicClient.Resource(ClusterGVR).Namespace("vks-test-ns").Create(context.Background(), cluster, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create cluster: %v", err)
	}

	// Step 7: Process cluster event
	clusterWatcher.EnqueueCluster(cluster, "ADD")
	processed := clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())

	// Step 8: Verify end-to-end flow - cluster secret was created with admin credentials
	g.Eventually(func() bool {
		secretName := "vks-cluster-avi-secret"
		secret, err := kubeClient.CoreV1().Secrets("vks-test-ns").Get(context.Background(), secretName, metav1.GetOptions{})
		if err != nil {
			return false
		}

		// Verify secret has all required fields
		requiredFields := []string{"username", "password", "authtoken", "controllerIP"}
		for _, field := range requiredFields {
			if _, exists := secret.Data[field]; !exists {
				t.Logf("Secret missing required field: %s", field)
				return false
			}
		}

		// Verify it has proper labels
		expectedLabels := map[string]string{
			"ako.kubernetes.vmware.com/cluster":    "vks-cluster",
			"ako.kubernetes.vmware.com/managed-by": "ako-infra",
		}

		for key, expectedValue := range expectedLabels {
			if actualValue, exists := secret.Labels[key]; !exists || actualValue != expectedValue {
				t.Logf("Secret label mismatch: %s expected=%s actual=%s", key, expectedValue, actualValue)
				return false
			}
		}

		return true
	}, 15*time.Second, 1*time.Second).Should(gomega.Equal(true))

	clusterWatcher.Stop()

	t.Log("✅ VKS End-to-End integration test completed successfully")
}

// TestVKSErrorHandling tests error scenarios in VKS integration
func TestVKSErrorHandling(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, dynamicClient := setupVKSIntegrationTest(t)

	// Test 1: Cluster in namespace without ServiceEngineGroup annotation should not be managed
	unmanageableNamespace := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "unmanageable-ns",
			// No ServiceEngineGroup annotation
		},
	}
	_, err := kubeClient.CoreV1().Namespaces().Create(context.Background(), unmanageableNamespace, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create namespace: %v", err)
	}

	// Create webhook to test validation
	webhookHandler := webhook.NewVKSClusterWebhook(kubeClient)

	cluster := createClusterResource("unmanageable-cluster", "unmanageable-ns", "Provisioned", false)
	clusterBytes, _ := json.Marshal(cluster)

	admissionRequest := &admissionv1.AdmissionRequest{
		UID:       types.UID("test-uid"),
		Kind:      metav1.GroupVersionKind{Group: "cluster.x-k8s.io", Version: "v1beta2", Kind: "Cluster"},
		Namespace: "unmanageable-ns",
		Object:    runtime.RawExtension{Raw: clusterBytes},
		Operation: admissionv1.Create,
	}

	response := webhookHandler.ProcessAdmissionRequest(admissionRequest)

	// Should be allowed but no VKS label should be added
	g.Expect(response.Allowed).To(gomega.BeTrue())
	g.Expect(len(response.Patch)).To(gomega.Equal(0)) // No patch should be applied

	// Test 2: Cluster watcher should handle missing admin credentials gracefully
	// Remove the avi-secret
	err = kubeClient.CoreV1().Secrets(utils.GetAKONamespace()).Delete(context.Background(), lib.AviSecret, metav1.DeleteOptions{})
	if err != nil {
		t.Fatalf("Failed to delete avi-secret: %v", err)
	}

	clusterWatcher := ingestion.NewVKSClusterWatcher(kubeClient, dynamicClient)

	// Create VKS-managed cluster
	managedCluster := createClusterResource("test-cluster", "vks-test-ns", "Provisioned", true)

	// This should fail gracefully when trying to generate secret
	ctx := context.Background()
	err = clusterWatcher.GenerateClusterSecret(ctx, managedCluster)
	g.Expect(err).To(gomega.HaveOccurred())
	g.Expect(err.Error()).To(gomega.ContainSubstring("failed to get ako-infra admin credentials"))

	t.Log("✅ VKS Error handling test completed successfully")
}

// TestVKSIdempotencyIntegration tests that VKS operations are idempotent
func TestVKSIdempotencyIntegration(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, dynamicClient := setupVKSIntegrationTest(t)

	// Test addon creation idempotency
	err := addon.EnsureGlobalAddonInstall()
	if err != nil {
		t.Fatalf("First addon creation failed: %v", err)
	}

	// Call again - should be idempotent
	err = addon.EnsureGlobalAddonInstall()
	if err != nil {
		t.Fatalf("Second addon creation failed: %v", err)
	}

	// Verify only one addon exists
	addons, err := dynamicClient.Resource(AddonInstallGVR).Namespace(addon.VKSPublicNamespace).List(context.Background(), metav1.ListOptions{})
	if err != nil {
		t.Fatalf("Failed to list addons: %v", err)
	}
	g.Expect(len(addons.Items)).To(gomega.Equal(1))

	// Test cluster secret creation idempotency
	clusterWatcher := ingestion.NewVKSClusterWatcher(kubeClient, dynamicClient)
	cluster := createClusterResource("idempotent-cluster", "test-ns", "Provisioned", true)

	ctx := context.Background()

	// First creation
	err = clusterWatcher.GenerateClusterSecret(ctx, cluster)
	if err != nil {
		t.Fatalf("First secret creation failed: %v", err)
	}

	// Get original secret
	secretName := "idempotent-cluster-avi-secret"
	originalSecret, err := kubeClient.CoreV1().Secrets("test-ns").Get(ctx, secretName, metav1.GetOptions{})
	if err != nil {
		t.Fatalf("Failed to get original secret: %v", err)
	}

	// Handle the same cluster again (should be idempotent)
	err = clusterWatcher.HandleProvisionedCluster(cluster)
	if err != nil {
		t.Fatalf("Second HandleProvisionedCluster failed: %v", err)
	}

	// Verify secret wasn't modified
	currentSecret, err := kubeClient.CoreV1().Secrets("test-ns").Get(ctx, secretName, metav1.GetOptions{})
	if err != nil {
		t.Fatalf("Failed to get current secret: %v", err)
	}

	g.Expect(originalSecret.ResourceVersion).To(gomega.Equal(currentSecret.ResourceVersion))

	t.Log("✅ VKS Idempotency integration test completed successfully")
}

// TestVKSE2ECreationToCleanup tests the full E2E flow from VKS infrastructure startup to complete cleanup
func TestVKSE2ECreationToCleanup(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, dynamicClient := setupVKSIntegrationTest(t)

	// === Phase 1: VKS Infrastructure Startup ===
	t.Log("🚀 Phase 1: VKS Infrastructure Startup")

	// Step 1: Enable VKS capability (simulates capability activation)
	capability := createVKSSupervisorCapability("ako-vks")
	_, err := dynamicClient.Resource(SupervisorCapabilityGVR).Create(context.Background(), capability, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create SupervisorCapability: %v", err)
	}
	t.Log("✅ VKS SupervisorCapability created")

	// Step 2: Global addon install creation
	err = addon.EnsureGlobalAddonInstall()
	if err != nil {
		t.Fatalf("Failed to ensure global addon install: %v", err)
	}

	// Verify AddonInstall was created
	g.Eventually(func() bool {
		_, err := dynamicClient.Resource(AddonInstallGVR).
			Namespace(addon.VKSPublicNamespace).
			Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
		return err == nil
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("✅ Global AddonInstall created")

	// Step 3: Webhook configuration creation
	err = webhook.CreateWebhookConfiguration(kubeClient)
	if err != nil {
		t.Fatalf("Failed to create webhook configuration: %v", err)
	}

	// Verify MutatingWebhookConfiguration was created
	g.Eventually(func() bool {
		_, err := kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().Get(
			context.Background(), "ako-vks-cluster-webhook", metav1.GetOptions{})
		return err == nil
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("✅ VKS webhook configuration created")

	// === Phase 2: Cluster Lifecycle Management ===
	t.Log("🔄 Phase 2: Cluster Lifecycle Management")

	// Step 4: Create namespace with required annotations
	namespace := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "e2e-test-ns",
			Annotations: map[string]string{
				"ako.vmware.com/wcp-se-group": "test-se-group",
			},
		},
	}
	_, err = kubeClient.CoreV1().Namespaces().Create(context.Background(), namespace, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create namespace: %v", err)
	}

	// Step 5: Start cluster watcher
	clusterWatcher := ingestion.NewVKSClusterWatcher(kubeClient, dynamicClient)
	stopCh := make(chan struct{})

	err = clusterWatcher.Start(stopCh)
	if err != nil {
		t.Fatalf("Failed to start cluster watcher: %v", err)
	}
	t.Log("✅ VKS cluster watcher started")

	// Step 6: Create VKS-managed cluster
	cluster := createClusterResource("e2e-cluster", "e2e-test-ns", "Provisioned", true)
	_, err = dynamicClient.Resource(ClusterGVR).Namespace("e2e-test-ns").Create(context.Background(), cluster, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create cluster: %v", err)
	}

	// Process cluster ADD event
	clusterWatcher.EnqueueCluster(cluster, "ADD")
	processed := clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())

	// Verify cluster secret was created
	g.Eventually(func() bool {
		secretName := "e2e-cluster-avi-secret"
		secret, err := kubeClient.CoreV1().Secrets("e2e-test-ns").Get(context.Background(), secretName, metav1.GetOptions{})
		if err != nil {
			return false
		}

		// Verify all required fields are present
		requiredFields := []string{"username", "password", "authtoken", "controllerIP"}
		for _, field := range requiredFields {
			if _, exists := secret.Data[field]; !exists {
				return false
			}
		}

		// Verify proper labels
		expectedLabels := map[string]string{
			"ako.kubernetes.vmware.com/cluster":    "e2e-cluster",
			"ako.kubernetes.vmware.com/managed-by": "ako-infra",
		}
		for key, expectedValue := range expectedLabels {
			if actualValue, exists := secret.Labels[key]; !exists || actualValue != expectedValue {
				return false
			}
		}

		return true
	}, 15*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("✅ Cluster secret created successfully")

	// === Phase 3: Resource State Validation ===
	t.Log("🔍 Phase 3: Resource State Validation")

	// Verify all VKS resources are present
	resourceChecks := []struct {
		name        string
		checkFunc   func() bool
		description string
	}{
		{
			name: "AddonInstall",
			checkFunc: func() bool {
				_, err := dynamicClient.Resource(AddonInstallGVR).
					Namespace(addon.VKSPublicNamespace).
					Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
				return err == nil
			},
			description: "Global AddonInstall exists",
		},
		{
			name: "WebhookConfiguration",
			checkFunc: func() bool {
				_, err := kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().Get(
					context.Background(), "ako-vks-cluster-webhook", metav1.GetOptions{})
				return err == nil
			},
			description: "MutatingWebhookConfiguration exists",
		},
		{
			name: "ClusterSecret",
			checkFunc: func() bool {
				_, err := kubeClient.CoreV1().Secrets("e2e-test-ns").Get(
					context.Background(), "e2e-cluster-avi-secret", metav1.GetOptions{})
				return err == nil
			},
			description: "Cluster secret exists",
		},
	}

	for _, check := range resourceChecks {
		g.Expect(check.checkFunc()).To(gomega.BeTrue(), check.description+" should be present")
		t.Logf("✅ %s validated", check.description)
	}

	// === Phase 4: Cleanup Simulation (AKO Shutdown) ===
	t.Log("🧹 Phase 4: VKS Cleanup Simulation")

	// Step 7: Simulate AKO shutdown by closing stopCh and triggering cleanup
	close(stopCh)
	t.Log("✅ Shutdown signal sent")

	// Step 8: Execute cleanup functions (simulates the cleanup goroutine in vcf_k8s_controller.go)
	t.Log("🔧 Executing webhook cleanup...")
	err = webhook.CleanupWebhookConfiguration(kubeClient)
	if err != nil {
		t.Fatalf("Failed to cleanup webhook configuration: %v", err)
	}
	t.Log("✅ Webhook configuration cleaned up")

	t.Log("🔧 Executing addon cleanup...")
	err = addon.CleanupGlobalAddonInstall()
	if err != nil {
		t.Fatalf("Failed to cleanup global addon install: %v", err)
	}
	t.Log("✅ Global AddonInstall cleaned up")

	// === Phase 5: Cleanup Verification ===
	t.Log("🔍 Phase 5: Cleanup Verification")

	// Verify webhook configuration was deleted
	g.Eventually(func() bool {
		_, err := kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().Get(
			context.Background(), "ako-vks-cluster-webhook", metav1.GetOptions{})
		return err != nil // Should be deleted
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("✅ MutatingWebhookConfiguration deletion verified")

	// Verify AddonInstall was deleted
	g.Eventually(func() bool {
		_, err := dynamicClient.Resource(AddonInstallGVR).
			Namespace(addon.VKSPublicNamespace).
			Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
		return err != nil // Should be deleted
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("✅ Global AddonInstall deletion verified")

	// === Phase 6: Cluster Secret Cleanup (Cluster Deletion) ===
	t.Log("🗑️ Phase 6: Cluster Secret Cleanup")

	// Step 9: Delete cluster (simulates cluster deletion)
	err = dynamicClient.Resource(ClusterGVR).Namespace("e2e-test-ns").Delete(context.Background(), "e2e-cluster", metav1.DeleteOptions{})
	if err != nil {
		t.Fatalf("Failed to delete cluster: %v", err)
	}

	// Process cluster DELETE event
	clusterWatcher.EnqueueCluster(cluster, "DELETE")
	processed = clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())

	// Verify cluster secret was deleted
	g.Eventually(func() bool {
		_, err := kubeClient.CoreV1().Secrets("e2e-test-ns").Get(
			context.Background(), "e2e-cluster-avi-secret", metav1.GetOptions{})
		return err != nil // Should be deleted
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("✅ Cluster secret deletion verified")

	// Stop cluster watcher
	clusterWatcher.Stop()
	t.Log("✅ Cluster watcher stopped")

	// === Final Verification ===
	t.Log("🎯 Final State Verification")

	finalChecks := []struct {
		name        string
		checkFunc   func() bool
		description string
	}{
		{
			name: "AddonInstall_Deleted",
			checkFunc: func() bool {
				_, err := dynamicClient.Resource(AddonInstallGVR).
					Namespace(addon.VKSPublicNamespace).
					Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
				return err != nil // Should be deleted
			},
			description: "AddonInstall is deleted",
		},
		{
			name: "WebhookConfiguration_Deleted",
			checkFunc: func() bool {
				_, err := kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().Get(
					context.Background(), "ako-vks-cluster-webhook", metav1.GetOptions{})
				return err != nil // Should be deleted
			},
			description: "MutatingWebhookConfiguration is deleted",
		},
		{
			name: "ClusterSecret_Deleted",
			checkFunc: func() bool {
				_, err := kubeClient.CoreV1().Secrets("e2e-test-ns").Get(
					context.Background(), "e2e-cluster-avi-secret", metav1.GetOptions{})
				return err != nil // Should be deleted
			},
			description: "Cluster secret is deleted",
		},
	}

	for _, check := range finalChecks {
		g.Expect(check.checkFunc()).To(gomega.BeTrue(), check.description)
		t.Logf("✅ %s verified", check.description)
	}

	t.Log("🎉 === VKS E2E Creation-to-Cleanup test completed successfully ===")
	t.Log("📋 Test Summary:")
	t.Log("   ✅ VKS infrastructure startup")
	t.Log("   ✅ Global addon install creation and management")
	t.Log("   ✅ Webhook configuration lifecycle")
	t.Log("   ✅ Cluster secret creation and management")
	t.Log("   ✅ Complete cleanup on AKO shutdown")
	t.Log("   ✅ Cluster-specific resource cleanup on cluster deletion")
	t.Log("   ✅ All resources properly cleaned up")
}
