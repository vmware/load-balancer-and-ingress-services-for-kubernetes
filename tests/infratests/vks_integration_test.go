/*
 * Copyright ¬© 2025 Broadcom Inc. and/or its subsidiaries. All Rights Reserved.
 * All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*   http://www.apache.org/licenses/LICENSE-2.0
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

// @AI-Generated
// This test file was generated by Claude AI assistant.

package infratests

import (
	"context"
	"encoding/json"
	"testing"
	"time"

	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-infra/addon"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-infra/ingestion"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-infra/webhook"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/lib"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/utils"

	"github.com/onsi/gomega"
	admissionv1 "k8s.io/api/admission/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/types"
	dynamicfake "k8s.io/client-go/dynamic/fake"
	k8sfake "k8s.io/client-go/kubernetes/fake"
)

// VKS GVRs for testing
var (
	SupervisorCapabilityGVR = schema.GroupVersionResource{
		Group:    "run.tanzu.vmware.com",
		Version:  "v1alpha3",
		Resource: "supervisorcapabilities",
	}
	AddonInstallGVR = schema.GroupVersionResource{
		Group:    "addons.kubernetes.vmware.com",
		Version:  "v1alpha1",
		Resource: "addoninstalls",
	}
	ClusterGVR = schema.GroupVersionResource{
		Group:    "cluster.x-k8s.io",
		Version:  "v1beta2",
		Resource: "clusters",
	}
)

// setupVKSIntegrationTest sets up the environment for VKS integration tests
func setupVKSIntegrationTest(t *testing.T) (*k8sfake.Clientset, *dynamicfake.FakeDynamicClient) {
	kubeClient := k8sfake.NewSimpleClientset()

	// Create avi-secret with admin credentials
	aviSecret := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      lib.AviSecret,
			Namespace: utils.GetAKONamespace(),
		},
		Type: corev1.SecretTypeOpaque,
		Data: map[string][]byte{
			"username":                 []byte("admin"),
			"password":                 []byte("admin123"),
			"authtoken":                []byte("test-auth-token-12345"),
			"certificateAuthorityData": []byte("-----BEGIN CERTIFICATE-----\nMIICertificateData...\n-----END CERTIFICATE-----"),
		},
	}
	_, err := kubeClient.CoreV1().Secrets(utils.GetAKONamespace()).Create(context.Background(), aviSecret, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create avi-secret: %v", err)
	}

	// Set up dynamic client with custom list kinds
	gvrToKind := map[schema.GroupVersionResource]string{
		SupervisorCapabilityGVR: "supervisorcapabilitiesList",
		AddonInstallGVR:         "addoninstallsList",
		ClusterGVR:              "clustersList",
	}

	dynamicClient := dynamicfake.NewSimpleDynamicClientWithCustomListKinds(runtime.NewScheme(), gvrToKind)
	lib.SetDynamicClientSet(dynamicClient)
	lib.NewDynamicInformers(dynamicClient, true)

	// Set controller IP for testing
	lib.SetControllerIP("10.10.10.10")

	return kubeClient, dynamicClient
}

// createVKSSupervisorCapability creates a VKS SupervisorCapability resource
func createVKSSupervisorCapability(name string) *unstructured.Unstructured {
	return &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "run.tanzu.vmware.com/v1alpha3",
			"kind":       "SupervisorCapability",
			"metadata": map[string]interface{}{
				"name": name,
			},
			"spec": map[string]interface{}{
				"capability": "ako_vks",
				"version":    "v1.12.1",
			},
		},
	}
}

// createClusterResource creates a cluster.x-k8s.io Cluster resource
func createClusterResource(name, namespace, phase string, managed bool) *unstructured.Unstructured {
	cluster := &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "cluster.x-k8s.io/v1beta1",
			"kind":       "Cluster",
			"metadata": map[string]interface{}{
				"name":      name,
				"namespace": namespace,
			},
			"status": map[string]interface{}{
				"phase": phase,
			},
		},
	}

	if managed {
		cluster.SetLabels(map[string]string{
			webhook.VKSManagedLabel: webhook.VKSManagedLabelValueTrue,
		})
	}

	return cluster
}

// TestVKSCapabilityToAddonFlow tests the full flow from VKS capability enablement to addon creation
func TestVKSCapabilityToAddonFlow(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	_, dynamicClient := setupVKSIntegrationTest(t)

	// Step 1: Create VKS SupervisorCapability
	capability := createVKSSupervisorCapability("ako-vks")
	_, err := dynamicClient.Resource(SupervisorCapabilityGVR).Create(context.Background(), capability, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create SupervisorCapability: %v", err)
	}

	// Step 2: Ensure global addon install is created
	err = addon.EnsureGlobalAddonInstall()
	if err != nil {
		t.Fatalf("Failed to ensure global addon install: %v", err)
	}

	// Step 3: Verify AddonInstall resource was created
	g.Eventually(func() bool {
		addonInstall, err := dynamicClient.Resource(AddonInstallGVR).
			Namespace(addon.VKSPublicNamespace).
			Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
		if err != nil {
			t.Logf("AddonInstall not found: %v", err)
			return false
		}

		// Verify basic addon structure
		name, _, _ := unstructured.NestedString(addonInstall.Object, "metadata", "name")
		namespace, _, _ := unstructured.NestedString(addonInstall.Object, "metadata", "namespace")

		return name == addon.AKOAddonInstallName && namespace == addon.VKSPublicNamespace
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))

	t.Log("‚úÖ VKS Capability to Addon flow completed successfully")
}

// TestVKSWebhookFunctionality tests the VKS webhook validation and labeling
func TestVKSWebhookFunctionality(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, _ := setupVKSIntegrationTest(t)

	// Create a namespace with ServiceEngineGroup annotation
	namespace := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "test-cluster-ns",
			Annotations: map[string]string{
				"ako.vmware.com/wcp-se-group": "test-se-group",
			},
		},
	}
	_, err := kubeClient.CoreV1().Namespaces().Create(context.Background(), namespace, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create namespace: %v", err)
	}

	// Create VKS webhook
	webhook := webhook.NewVKSClusterWebhook(kubeClient)

	// Test cluster that should be managed by VKS
	clusterObj := createClusterResource("test-cluster", "test-cluster-ns", "Provisioned", false)
	clusterBytes, _ := json.Marshal(clusterObj)

	admissionRequest := &admissionv1.AdmissionRequest{
		UID:       types.UID("test-uid"),
		Kind:      metav1.GroupVersionKind{Group: "cluster.x-k8s.io", Version: "v1beta2", Kind: "Cluster"},
		Namespace: "test-cluster-ns",
		Object:    runtime.RawExtension{Raw: clusterBytes},
		Operation: admissionv1.Create,
	}

	// Process admission request
	response := webhook.ProcessAdmissionRequest(admissionRequest)

	// Verify response
	g.Expect(response.Allowed).To(gomega.BeTrue())
	g.Expect(len(response.Patch)).To(gomega.BeNumerically(">", 0))

	// Verify patch adds VKS managed label
	var patches []map[string]interface{}
	err = json.Unmarshal(response.Patch, &patches)
	g.Expect(err).To(gomega.BeNil())

	foundVKSLabel := false
	for _, patch := range patches {
		if path, ok := patch["path"].(string); ok && path == "/metadata/labels" {
			if valueMap, ok := patch["value"].(map[string]interface{}); ok {
				if vksValue, exists := valueMap["ako.kubernetes.vmware.com/install"]; exists && vksValue == "true" {
					foundVKSLabel = true
					break
				}
			}
		}
	}
	g.Expect(foundVKSLabel).To(gomega.BeTrue())

	t.Log("‚úÖ VKS Webhook functionality validated successfully")
}

// TestVKSClusterLifecycleIntegration tests the full cluster lifecycle from creation to secret management
func TestVKSClusterLifecycleIntegration(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, dynamicClient := setupVKSIntegrationTest(t)

	// Step 1: Create VKS cluster watcher
	clusterWatcher := ingestion.NewVKSClusterWatcher(kubeClient, dynamicClient)

	// Start the watcher
	stopCh := make(chan struct{})
	defer close(stopCh)

	err := clusterWatcher.Start(stopCh)
	if err != nil {
		t.Fatalf("Failed to start cluster watcher: %v", err)
	}

	// Step 2: Create a VKS-managed cluster
	cluster := createClusterResource("test-cluster", "test-cluster-ns", "Provisioned", true)
	_, err = dynamicClient.Resource(ClusterGVR).Namespace("test-cluster-ns").Create(context.Background(), cluster, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create cluster: %v", err)
	}

	// Step 3: Simulate cluster event processing
	clusterWatcher.EnqueueCluster(cluster, "ADD")

	// Process the event
	processed := clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())

	// Step 4: Verify cluster secret was created
	g.Eventually(func() bool {
		secretName := "test-cluster-avi-secret"
		secret, err := kubeClient.CoreV1().Secrets("test-cluster-ns").Get(context.Background(), secretName, metav1.GetOptions{})
		if err != nil {
			t.Logf("Secret not found: %v", err)
			return false
		}

		// Verify secret contains expected fields
		expectedFields := []string{"username", "controllerIP", "authtoken"}
		for _, field := range expectedFields {
			if _, exists := secret.Data[field]; !exists {
				t.Logf("Secret missing field: %s", field)
				return false
			}
		}

		// Verify username is from admin credentials
		usernameBytes, exists := secret.Data["username"]
		if !exists {
			return false
		}

		// The secret data is stored as raw bytes (not base64 encoded)
		return string(usernameBytes) == "admin"
	}, 15*time.Second, 1*time.Second).Should(gomega.Equal(true))

	// Step 5: Test cluster opt-out (change label to false)
	cluster.SetLabels(map[string]string{
		webhook.VKSManagedLabel: webhook.VKSManagedLabelValueFalse,
	})
	_, err = dynamicClient.Resource(ClusterGVR).Namespace("test-cluster-ns").Update(context.Background(), cluster, metav1.UpdateOptions{})
	if err != nil {
		t.Fatalf("Failed to update cluster: %v", err)
	}

	// Simulate UPDATE event
	clusterWatcher.EnqueueCluster(cluster, "UPDATE")
	processed = clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())

	// Step 6: Verify secret was cleaned up
	g.Eventually(func() bool {
		secretName := "test-cluster-avi-secret"
		_, err := kubeClient.CoreV1().Secrets("test-cluster-ns").Get(context.Background(), secretName, metav1.GetOptions{})
		return err != nil // Secret should be deleted
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))

	// Step 7: Test cluster deletion
	err = dynamicClient.Resource(ClusterGVR).Namespace("test-cluster-ns").Delete(context.Background(), "test-cluster", metav1.DeleteOptions{})
	if err != nil {
		t.Fatalf("Failed to delete cluster: %v", err)
	}

	// Simulate DELETE event
	clusterWatcher.EnqueueCluster(cluster, "DELETE")
	processed = clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())

	clusterWatcher.Stop()

	t.Log("‚úÖ VKS Cluster lifecycle integration test completed successfully")
}

// TestVKSEndToEndIntegration tests the complete VKS integration flow
func TestVKSEndToEndIntegration(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, dynamicClient := setupVKSIntegrationTest(t)

	// Step 1: Enable VKS capability
	capability := createVKSSupervisorCapability("ako-vks")
	_, err := dynamicClient.Resource(SupervisorCapabilityGVR).Create(context.Background(), capability, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create SupervisorCapability: %v", err)
	}

	// Step 2: Ensure global addon is created
	err = addon.EnsureGlobalAddonInstall()
	if err != nil {
		t.Fatalf("Failed to ensure global addon install: %v", err)
	}

	// Step 3: Verify addon was created
	g.Eventually(func() bool {
		_, err := dynamicClient.Resource(AddonInstallGVR).
			Namespace(addon.VKSPublicNamespace).
			Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
		return err == nil
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))

	// Step 4: Create namespace with required annotations
	namespace := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "vks-test-ns",
			Annotations: map[string]string{
				"ako.vmware.com/wcp-se-group": "test-se-group",
			},
		},
	}
	_, err = kubeClient.CoreV1().Namespaces().Create(context.Background(), namespace, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create namespace: %v", err)
	}

	// Step 5: Create and start cluster watcher
	clusterWatcher := ingestion.NewVKSClusterWatcher(kubeClient, dynamicClient)
	stopCh := make(chan struct{})
	defer close(stopCh)

	err = clusterWatcher.Start(stopCh)
	if err != nil {
		t.Fatalf("Failed to start cluster watcher: %v", err)
	}

	// Step 6: Create a cluster (simulating webhook labeling)
	cluster := createClusterResource("vks-cluster", "vks-test-ns", "Provisioned", true)
	_, err = dynamicClient.Resource(ClusterGVR).Namespace("vks-test-ns").Create(context.Background(), cluster, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create cluster: %v", err)
	}

	// Step 7: Process cluster event
	clusterWatcher.EnqueueCluster(cluster, "ADD")
	processed := clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())

	// Step 8: Verify end-to-end flow - cluster secret was created with admin credentials
	g.Eventually(func() bool {
		secretName := "vks-cluster-avi-secret"
		secret, err := kubeClient.CoreV1().Secrets("vks-test-ns").Get(context.Background(), secretName, metav1.GetOptions{})
		if err != nil {
			return false
		}

		// Verify secret has all required fields
		requiredFields := []string{"username", "password", "authtoken", "controllerIP"}
		for _, field := range requiredFields {
			if _, exists := secret.Data[field]; !exists {
				t.Logf("Secret missing required field: %s", field)
				return false
			}
		}

		// Verify it has proper labels
		expectedLabels := map[string]string{
			"ako.kubernetes.vmware.com/cluster":    "vks-cluster",
			"ako.kubernetes.vmware.com/managed-by": "ako-infra",
		}

		for key, expectedValue := range expectedLabels {
			if actualValue, exists := secret.Labels[key]; !exists || actualValue != expectedValue {
				t.Logf("Secret label mismatch: %s expected=%s actual=%s", key, expectedValue, actualValue)
				return false
			}
		}

		return true
	}, 15*time.Second, 1*time.Second).Should(gomega.Equal(true))

	clusterWatcher.Stop()

	t.Log("‚úÖ VKS End-to-End integration test completed successfully")
}

// TestVKSErrorHandling tests error scenarios in VKS integration
func TestVKSErrorHandling(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, dynamicClient := setupVKSIntegrationTest(t)

	// Test 1: Cluster in namespace without ServiceEngineGroup annotation should not be managed
	unmanageableNamespace := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "unmanageable-ns",
			// No ServiceEngineGroup annotation
		},
	}
	_, err := kubeClient.CoreV1().Namespaces().Create(context.Background(), unmanageableNamespace, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create namespace: %v", err)
	}

	// Create webhook to test validation
	webhookHandler := webhook.NewVKSClusterWebhook(kubeClient)

	cluster := createClusterResource("unmanageable-cluster", "unmanageable-ns", "Provisioned", false)
	clusterBytes, _ := json.Marshal(cluster)

	admissionRequest := &admissionv1.AdmissionRequest{
		UID:       types.UID("test-uid"),
		Kind:      metav1.GroupVersionKind{Group: "cluster.x-k8s.io", Version: "v1beta2", Kind: "Cluster"},
		Namespace: "unmanageable-ns",
		Object:    runtime.RawExtension{Raw: clusterBytes},
		Operation: admissionv1.Create,
	}

	response := webhookHandler.ProcessAdmissionRequest(admissionRequest)

	// Should be allowed but no VKS label should be added
	g.Expect(response.Allowed).To(gomega.BeTrue())
	g.Expect(len(response.Patch)).To(gomega.Equal(0)) // No patch should be applied

	// Test 2: Cluster watcher should handle missing admin credentials gracefully
	// Remove the avi-secret
	err = kubeClient.CoreV1().Secrets(utils.GetAKONamespace()).Delete(context.Background(), lib.AviSecret, metav1.DeleteOptions{})
	if err != nil {
		t.Fatalf("Failed to delete avi-secret: %v", err)
	}

	clusterWatcher := ingestion.NewVKSClusterWatcher(kubeClient, dynamicClient)

	// Create VKS-managed cluster
	managedCluster := createClusterResource("test-cluster", "vks-test-ns", "Provisioned", true)

	// This should fail gracefully when trying to generate secret
	ctx := context.Background()
	err = clusterWatcher.GenerateClusterSecret(ctx, managedCluster)
	g.Expect(err).To(gomega.HaveOccurred())
	g.Expect(err.Error()).To(gomega.ContainSubstring("failed to get ako-infra admin credentials"))

	t.Log("‚úÖ VKS Error handling test completed successfully")
}

// TestVKSIdempotencyIntegration tests that VKS operations are idempotent
func TestVKSIdempotencyIntegration(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, dynamicClient := setupVKSIntegrationTest(t)

	// Test addon creation idempotency
	err := addon.EnsureGlobalAddonInstall()
	if err != nil {
		t.Fatalf("First addon creation failed: %v", err)
	}

	// Call again - should be idempotent
	err = addon.EnsureGlobalAddonInstall()
	if err != nil {
		t.Fatalf("Second addon creation failed: %v", err)
	}

	// Verify only one addon exists
	addons, err := dynamicClient.Resource(AddonInstallGVR).Namespace(addon.VKSPublicNamespace).List(context.Background(), metav1.ListOptions{})
	if err != nil {
		t.Fatalf("Failed to list addons: %v", err)
	}
	g.Expect(len(addons.Items)).To(gomega.Equal(1))

	// Test cluster secret creation idempotency
	clusterWatcher := ingestion.NewVKSClusterWatcher(kubeClient, dynamicClient)
	cluster := createClusterResource("idempotent-cluster", "test-ns", "Provisioned", true)

	ctx := context.Background()

	// First creation
	err = clusterWatcher.GenerateClusterSecret(ctx, cluster)
	if err != nil {
		t.Fatalf("First secret creation failed: %v", err)
	}

	// Get original secret
	secretName := "idempotent-cluster-avi-secret"
	originalSecret, err := kubeClient.CoreV1().Secrets("test-ns").Get(ctx, secretName, metav1.GetOptions{})
	if err != nil {
		t.Fatalf("Failed to get original secret: %v", err)
	}

	// Handle the same cluster again (should be idempotent)
	err = clusterWatcher.HandleProvisionedCluster(cluster)
	if err != nil {
		t.Fatalf("Second HandleProvisionedCluster failed: %v", err)
	}

	// Verify secret wasn't modified
	currentSecret, err := kubeClient.CoreV1().Secrets("test-ns").Get(ctx, secretName, metav1.GetOptions{})
	if err != nil {
		t.Fatalf("Failed to get current secret: %v", err)
	}

	g.Expect(originalSecret.ResourceVersion).To(gomega.Equal(currentSecret.ResourceVersion))

	t.Log("‚úÖ VKS Idempotency integration test completed successfully")
}

// TestVKSE2ECreationToCleanup tests the full E2E flow from VKS infrastructure startup to complete cleanup
func TestVKSE2ECreationToCleanup(t *testing.T) {
	g := gomega.NewGomegaWithT(t)
	kubeClient, dynamicClient := setupVKSIntegrationTest(t)

	// === Phase 1: VKS Infrastructure Startup ===
	t.Log("üöÄ Phase 1: VKS Infrastructure Startup")

	// Step 1: Enable VKS capability (simulates capability activation)
	capability := createVKSSupervisorCapability("ako-vks")
	_, err := dynamicClient.Resource(SupervisorCapabilityGVR).Create(context.Background(), capability, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create SupervisorCapability: %v", err)
	}
	t.Log("‚úÖ VKS SupervisorCapability created")

	// Step 2: Global addon install creation
	err = addon.EnsureGlobalAddonInstall()
	if err != nil {
		t.Fatalf("Failed to ensure global addon install: %v", err)
	}

	// Verify AddonInstall was created
	g.Eventually(func() bool {
		_, err := dynamicClient.Resource(AddonInstallGVR).
			Namespace(addon.VKSPublicNamespace).
			Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
		return err == nil
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("‚úÖ Global AddonInstall created")

	// Step 3: Webhook configuration creation
	err = webhook.CreateWebhookConfiguration(kubeClient)
	if err != nil {
		t.Fatalf("Failed to create webhook configuration: %v", err)
	}

	// Verify MutatingWebhookConfiguration was created
	g.Eventually(func() bool {
		_, err := kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().Get(
			context.Background(), "ako-vks-cluster-webhook", metav1.GetOptions{})
		return err == nil
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("‚úÖ VKS webhook configuration created")

	// === Phase 2: Cluster Lifecycle Management ===
	t.Log("üîÑ Phase 2: Cluster Lifecycle Management")

	// Step 4: Create namespace with required annotations
	namespace := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: "e2e-test-ns",
			Annotations: map[string]string{
				"ako.vmware.com/wcp-se-group": "test-se-group",
			},
		},
	}
	_, err = kubeClient.CoreV1().Namespaces().Create(context.Background(), namespace, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create namespace: %v", err)
	}

	// Step 5: Start cluster watcher
	clusterWatcher := ingestion.NewVKSClusterWatcher(kubeClient, dynamicClient)
	stopCh := make(chan struct{})

	err = clusterWatcher.Start(stopCh)
	if err != nil {
		t.Fatalf("Failed to start cluster watcher: %v", err)
	}
	t.Log("‚úÖ VKS cluster watcher started")

	// Step 6: Create VKS-managed cluster
	cluster := createClusterResource("e2e-cluster", "e2e-test-ns", "Provisioned", true)
	_, err = dynamicClient.Resource(ClusterGVR).Namespace("e2e-test-ns").Create(context.Background(), cluster, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create cluster: %v", err)
	}

	// Process cluster ADD event
	clusterWatcher.EnqueueCluster(cluster, "ADD")
	processed := clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())

	// Verify cluster secret was created
	g.Eventually(func() bool {
		secretName := "e2e-cluster-avi-secret"
		secret, err := kubeClient.CoreV1().Secrets("e2e-test-ns").Get(context.Background(), secretName, metav1.GetOptions{})
		if err != nil {
			return false
		}

		// Verify all required fields are present
		requiredFields := []string{"username", "password", "authtoken", "controllerIP"}
		for _, field := range requiredFields {
			if _, exists := secret.Data[field]; !exists {
				return false
			}
		}

		// Verify proper labels
		expectedLabels := map[string]string{
			"ako.kubernetes.vmware.com/cluster":    "e2e-cluster",
			"ako.kubernetes.vmware.com/managed-by": "ako-infra",
		}
		for key, expectedValue := range expectedLabels {
			if actualValue, exists := secret.Labels[key]; !exists || actualValue != expectedValue {
				return false
			}
		}

		return true
	}, 15*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("‚úÖ Cluster secret created successfully")

	// === Phase 3: Resource State Validation ===
	t.Log("üîç Phase 3: Resource State Validation")

	// Verify all VKS resources are present
	resourceChecks := []struct {
		name        string
		checkFunc   func() bool
		description string
	}{
		{
			name: "AddonInstall",
			checkFunc: func() bool {
				_, err := dynamicClient.Resource(AddonInstallGVR).
					Namespace(addon.VKSPublicNamespace).
					Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
				return err == nil
			},
			description: "Global AddonInstall exists",
		},
		{
			name: "WebhookConfiguration",
			checkFunc: func() bool {
				_, err := kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().Get(
					context.Background(), "ako-vks-cluster-webhook", metav1.GetOptions{})
				return err == nil
			},
			description: "MutatingWebhookConfiguration exists",
		},
		{
			name: "ClusterSecret",
			checkFunc: func() bool {
				_, err := kubeClient.CoreV1().Secrets("e2e-test-ns").Get(
					context.Background(), "e2e-cluster-avi-secret", metav1.GetOptions{})
				return err == nil
			},
			description: "Cluster secret exists",
		},
	}

	for _, check := range resourceChecks {
		g.Expect(check.checkFunc()).To(gomega.BeTrue(), check.description+" should be present")
		t.Logf("‚úÖ %s validated", check.description)
	}

	// === Phase 4: Cleanup Simulation (AKO Shutdown) ===
	t.Log("üßπ Phase 4: VKS Cleanup Simulation")

	// Step 7: Simulate AKO shutdown by closing stopCh and triggering cleanup
	close(stopCh)
	t.Log("‚úÖ Shutdown signal sent")

	// Step 8: Execute cleanup functions (simulates the cleanup goroutine in vcf_k8s_controller.go)
	t.Log("üîß Executing webhook cleanup...")
	err = webhook.CleanupWebhookConfiguration(kubeClient)
	if err != nil {
		t.Fatalf("Failed to cleanup webhook configuration: %v", err)
	}
	t.Log("‚úÖ Webhook configuration cleaned up")

	t.Log("üîß Executing addon cleanup...")
	err = addon.CleanupGlobalAddonInstall()
	if err != nil {
		t.Fatalf("Failed to cleanup global addon install: %v", err)
	}
	t.Log("‚úÖ Global AddonInstall cleaned up")

	// === Phase 5: Cleanup Verification ===
	t.Log("üîç Phase 5: Cleanup Verification")

	// Verify webhook configuration was deleted
	g.Eventually(func() bool {
		_, err := kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().Get(
			context.Background(), "ako-vks-cluster-webhook", metav1.GetOptions{})
		return err != nil // Should be deleted
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("‚úÖ MutatingWebhookConfiguration deletion verified")

	// Verify AddonInstall was deleted
	g.Eventually(func() bool {
		_, err := dynamicClient.Resource(AddonInstallGVR).
			Namespace(addon.VKSPublicNamespace).
			Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
		return err != nil // Should be deleted
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("‚úÖ Global AddonInstall deletion verified")

	// === Phase 6: Cluster Secret Cleanup (Cluster Deletion) ===
	t.Log("üóëÔ∏è Phase 6: Cluster Secret Cleanup")

	// Step 9: Delete cluster (simulates cluster deletion)
	err = dynamicClient.Resource(ClusterGVR).Namespace("e2e-test-ns").Delete(context.Background(), "e2e-cluster", metav1.DeleteOptions{})
	if err != nil {
		t.Fatalf("Failed to delete cluster: %v", err)
	}

	// Process cluster DELETE event
	clusterWatcher.EnqueueCluster(cluster, "DELETE")
	processed = clusterWatcher.ProcessNextWorkItem()
	g.Expect(processed).To(gomega.BeTrue())

	// Verify cluster secret was deleted
	g.Eventually(func() bool {
		_, err := kubeClient.CoreV1().Secrets("e2e-test-ns").Get(
			context.Background(), "e2e-cluster-avi-secret", metav1.GetOptions{})
		return err != nil // Should be deleted
	}, 10*time.Second, 1*time.Second).Should(gomega.Equal(true))
	t.Log("‚úÖ Cluster secret deletion verified")

	// Stop cluster watcher
	clusterWatcher.Stop()
	t.Log("‚úÖ Cluster watcher stopped")

	// === Final Verification ===
	t.Log("üéØ Final State Verification")

	finalChecks := []struct {
		name        string
		checkFunc   func() bool
		description string
	}{
		{
			name: "AddonInstall_Deleted",
			checkFunc: func() bool {
				_, err := dynamicClient.Resource(AddonInstallGVR).
					Namespace(addon.VKSPublicNamespace).
					Get(context.Background(), addon.AKOAddonInstallName, metav1.GetOptions{})
				return err != nil // Should be deleted
			},
			description: "AddonInstall is deleted",
		},
		{
			name: "WebhookConfiguration_Deleted",
			checkFunc: func() bool {
				_, err := kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().Get(
					context.Background(), "ako-vks-cluster-webhook", metav1.GetOptions{})
				return err != nil // Should be deleted
			},
			description: "MutatingWebhookConfiguration is deleted",
		},
		{
			name: "ClusterSecret_Deleted",
			checkFunc: func() bool {
				_, err := kubeClient.CoreV1().Secrets("e2e-test-ns").Get(
					context.Background(), "e2e-cluster-avi-secret", metav1.GetOptions{})
				return err != nil // Should be deleted
			},
			description: "Cluster secret is deleted",
		},
	}

	for _, check := range finalChecks {
		g.Expect(check.checkFunc()).To(gomega.BeTrue(), check.description)
		t.Logf("‚úÖ %s verified", check.description)
	}

	t.Log("üéâ === VKS E2E Creation-to-Cleanup test completed successfully ===")
	t.Log("üìã Test Summary:")
	t.Log("   ‚úÖ VKS infrastructure startup")
	t.Log("   ‚úÖ Global addon install creation and management")
	t.Log("   ‚úÖ Webhook configuration lifecycle")
	t.Log("   ‚úÖ Cluster secret creation and management")
	t.Log("   ‚úÖ Complete cleanup on AKO shutdown")
	t.Log("   ‚úÖ Cluster-specific resource cleanup on cluster deletion")
	t.Log("   ‚úÖ All resources properly cleaned up")
}
