/*
 * Copyright Â© 2025 Broadcom Inc. and/or its subsidiaries. All Rights Reserved.
 * All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// @AI-Generated
// [Generated by Cursor claude-4-sonnet]

package miscellaneous

import (
	"errors"
	"os"
	"strings"
	"testing"

	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/utils"
)

func TestWebSyncError(t *testing.T) {
	tests := []struct {
		name              string
		err               error
		operation         string
		expectedErrString string
	}{
		{
			name:              "POST operation error",
			err:               errors.New("connection timeout"),
			operation:         "POST",
			expectedErrString: "Error during POST: connection timeout",
		},
		{
			name:              "PUT operation error",
			err:               errors.New("invalid request"),
			operation:         "PUT",
			expectedErrString: "Error during PUT: invalid request",
		},
		{
			name:              "DELETE operation error",
			err:               errors.New("resource not found"),
			operation:         "DELETE",
			expectedErrString: "Error during DELETE: resource not found",
		},
		{
			name:              "GET operation error",
			err:               errors.New("unauthorized"),
			operation:         "GET",
			expectedErrString: "Error during GET: unauthorized",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			webErr := &utils.WebSyncError{
				Err:       tt.err,
				Operation: tt.operation,
			}

			// Test Error() method
			if webErr.Error() != tt.expectedErrString {
				t.Errorf("WebSyncError.Error() = %v, want %v", webErr.Error(), tt.expectedErrString)
			}

			// Test GetWebAPIError() method
			if webErr.GetWebAPIError() != tt.err {
				t.Errorf("WebSyncError.GetWebAPIError() = %v, want %v", webErr.GetWebAPIError(), tt.err)
			}

			// Test Unwrap() method
			if webErr.Unwrap() != tt.err {
				t.Errorf("WebSyncError.Unwrap() = %v, want %v", webErr.Unwrap(), tt.err)
			}
		})
	}
}

func TestWebSyncErrorUnwrap(t *testing.T) {
	originalErr := errors.New("original error")
	webErr := &utils.WebSyncError{
		Err:       originalErr,
		Operation: "POST",
	}

	// Test that errors.Is works with Unwrap
	if !errors.Is(webErr, originalErr) {
		t.Error("errors.Is should work with WebSyncError.Unwrap()")
	}
}

func TestSkipSyncError(t *testing.T) {
	tests := []struct {
		name        string
		msg         string
		expectedMsg string
	}{
		{
			name:        "Simple message",
			msg:         "skipping sync",
			expectedMsg: "skipping sync",
		},
		{
			name:        "Detailed message",
			msg:         "skipping sync due to invalid configuration",
			expectedMsg: "skipping sync due to invalid configuration",
		},
		{
			name:        "Empty message",
			msg:         "",
			expectedMsg: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			skipErr := &utils.SkipSyncError{
				Msg: tt.msg,
			}

			if skipErr.Error() != tt.expectedMsg {
				t.Errorf("SkipSyncError.Error() = %v, want %v", skipErr.Error(), tt.expectedMsg)
			}
		})
	}
}

func TestSetCloudName(t *testing.T) {
	tests := []struct {
		name      string
		cloudName string
	}{
		{
			name:      "Set to AWS",
			cloudName: "AWS",
		},
		{
			name:      "Set to Azure",
			cloudName: "Azure",
		},
		{
			name:      "Set to GCP",
			cloudName: "GCP",
		},
		{
			name:      "Set to Default-Cloud",
			cloudName: "Default-Cloud",
		},
		{
			name:      "Set to empty string",
			cloudName: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			utils.SetCloudName(tt.cloudName)
			// Note: We can't directly test the value since CloudName is not exported
			// This test ensures the function doesn't panic
		})
	}
}

func TestSetCloudUUID(t *testing.T) {
	tests := []struct {
		name      string
		cloudUUID string
	}{
		{
			name:      "Set valid UUID",
			cloudUUID: "cloud-uuid-12345",
		},
		{
			name:      "Set another UUID",
			cloudUUID: "uuid-abcdef",
		},
		{
			name:      "Set empty UUID",
			cloudUUID: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			utils.SetCloudUUID(tt.cloudUUID)
			// Note: We can't directly test the value since CloudUUID is not exported
			// This test ensures the function doesn't panic
		})
	}
}

func TestCloudNameInitialization(t *testing.T) {
	// Test that CloudName is initialized from environment or defaults to "Default-Cloud"
	// This is tested indirectly through the init() function

	// Save original env var
	originalCloudName := os.Getenv("CLOUD_NAME")
	defer func() {
		if originalCloudName != "" {
			os.Setenv("CLOUD_NAME", originalCloudName)
		} else {
			os.Unsetenv("CLOUD_NAME")
		}
	}()

	// The init() function has already run, so we can't test it directly
	// But we can verify the functions work
	testCloudName := "TestCloud"
	utils.SetCloudName(testCloudName)

	// Verify function doesn't panic
	utils.SetCloudUUID("test-uuid")
}

func TestRestMethodConstants(t *testing.T) {
	// Test that RestMethod constants are defined correctly
	tests := []struct {
		name     string
		method   utils.RestMethod
		expected string
	}{
		{
			name:     "POST method",
			method:   utils.RestPost,
			expected: "POST",
		},
		{
			name:     "PUT method",
			method:   utils.RestPut,
			expected: "PUT",
		},
		{
			name:     "DELETE method",
			method:   utils.RestDelete,
			expected: "DELETE",
		},
		{
			name:     "PATCH method",
			method:   utils.RestPatch,
			expected: "PATCH",
		},
		{
			name:     "GET method",
			method:   utils.RestGet,
			expected: "GET",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if string(tt.method) != tt.expected {
				t.Errorf("RestMethod %s = %v, want %v", tt.name, tt.method, tt.expected)
			}
		})
	}
}

func TestEvTypeConstants(t *testing.T) {
	// Test that EvType constants are defined correctly
	tests := []struct {
		name     string
		evType   utils.EvType
		expected string
	}{
		{
			name:     "CREATE event",
			evType:   utils.CreateEv,
			expected: "CREATE",
		},
		{
			name:     "UPDATE event",
			evType:   utils.UpdateEv,
			expected: "UPDATE",
		},
		{
			name:     "DELETE event",
			evType:   utils.DeleteEv,
			expected: "DELETE",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if string(tt.evType) != tt.expected {
				t.Errorf("EvType %s = %v, want %v", tt.name, tt.evType, tt.expected)
			}
		})
	}
}

func TestPatchOpConstants(t *testing.T) {
	tests := []struct {
		name     string
		constant string
		expected string
	}{
		{
			name:     "PatchAddOp",
			constant: utils.PatchAddOp,
			expected: "add",
		},
		{
			name:     "PatchReplaceOp",
			constant: utils.PatchReplaceOp,
			expected: "replace",
		},
		{
			name:     "PatchDeleteOp",
			constant: utils.PatchDeleteOp,
			expected: "delete",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.constant != tt.expected {
				t.Errorf("%s = %v, want %v", tt.name, tt.constant, tt.expected)
			}
		})
	}
}

func TestHealthMonitorConstants(t *testing.T) {
	tests := []struct {
		name     string
		constant string
		expected string
	}{
		{
			name:     "AVI_DEFAULT_TCP_HM",
			constant: utils.AVI_DEFAULT_TCP_HM,
			expected: "System-TCP",
		},
		{
			name:     "AVI_DEFAULT_UDP_HM",
			constant: utils.AVI_DEFAULT_UDP_HM,
			expected: "System-UDP",
		},
		{
			name:     "AVI_DEFAULT_SCTP_HM",
			constant: utils.AVI_DEFAULT_SCTP_HM,
			expected: "System-SCTP",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.constant != tt.expected {
				t.Errorf("%s = %v, want %v", tt.name, tt.constant, tt.expected)
			}
		})
	}
}

func TestInformerConstants(t *testing.T) {
	tests := []struct {
		name     string
		constant string
		expected string
	}{
		{
			name:     "INFORMERS_INSTANTIATE_ONCE",
			constant: utils.INFORMERS_INSTANTIATE_ONCE,
			expected: "instantiateOnce",
		},
		{
			name:     "INFORMERS_OPENSHIFT_CLIENT",
			constant: utils.INFORMERS_OPENSHIFT_CLIENT,
			expected: "oshiftClient",
		},
		{
			name:     "INFORMERS_AKO_CLIENT",
			constant: utils.INFORMERS_AKO_CLIENT,
			expected: "akoClient",
		},
		{
			name:     "INFORMERS_NAMESPACE",
			constant: utils.INFORMERS_NAMESPACE,
			expected: "namespace",
		},
		{
			name:     "INFORMERS_ADVANCED_L4",
			constant: utils.INFORMERS_ADVANCED_L4,
			expected: "informersAdvL4",
		},
		{
			name:     "VMWARE_SYSTEM_AKO",
			constant: utils.VMWARE_SYSTEM_AKO,
			expected: "vmware-system-ako",
		},
		{
			name:     "AKO_DEFAULT_NS",
			constant: utils.AKO_DEFAULT_NS,
			expected: "avi-system",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.constant != tt.expected {
				t.Errorf("%s = %v, want %v", tt.name, tt.constant, tt.expected)
			}
		})
	}
}

func TestNumWorkersConstants(t *testing.T) {
	if utils.NumWorkersIngestion != 2 {
		t.Errorf("NumWorkersIngestion = %v, want 2", utils.NumWorkersIngestion)
	}

	if utils.NumWorkersGraph != 2 {
		t.Errorf("NumWorkersGraph = %v, want 2", utils.NumWorkersGraph)
	}
}

func TestWebSyncErrorAsError(t *testing.T) {
	// Test that WebSyncError implements error interface
	var _ error = &utils.WebSyncError{}

	webErr := &utils.WebSyncError{
		Err:       errors.New("test error"),
		Operation: "TEST",
	}

	// Should be usable as error - webErr is never nil since it's a concrete type
	if !strings.Contains(webErr.Error(), "TEST") {
		t.Error("WebSyncError.Error() should contain operation name")
	}
}

func TestSkipSyncErrorAsError(t *testing.T) {
	// Test that SkipSyncError implements error interface
	var _ error = &utils.SkipSyncError{}

	skipErr := &utils.SkipSyncError{
		Msg: "test skip message",
	}

	// Should be usable as error - skipErr is never nil since it's a concrete type
	if skipErr.Error() != "test skip message" {
		t.Errorf("SkipSyncError.Error() = %v, want 'test skip message'", skipErr.Error())
	}
}

func TestUtilsNamespaceNameStruct(t *testing.T) {
	// Test NamespaceName struct
	nn := utils.NamespaceName{
		Namespace: "default",
		Name:      "my-service",
	}

	if nn.Namespace != "default" {
		t.Errorf("NamespaceName.Namespace = %v, want default", nn.Namespace)
	}

	if nn.Name != "my-service" {
		t.Errorf("NamespaceName.Name = %v, want my-service", nn.Name)
	}
}

func TestRestOpStruct(t *testing.T) {
	// Test RestOp struct initialization
	restOp := utils.RestOp{
		Path:    "/api/virtualservice",
		Method:  utils.RestPost,
		Tenant:  "admin",
		PatchOp: utils.PatchAddOp,
		Model:   "VirtualService",
		Version: "v1",
		ObjName: "test-vs",
		Caller:  "test-caller",
		Message: "test message",
	}

	if restOp.Path != "/api/virtualservice" {
		t.Errorf("RestOp.Path = %v, want /api/virtualservice", restOp.Path)
	}

	if restOp.Method != utils.RestPost {
		t.Errorf("RestOp.Method = %v, want POST", restOp.Method)
	}

	if restOp.Tenant != "admin" {
		t.Errorf("RestOp.Tenant = %v, want admin", restOp.Tenant)
	}

	if restOp.Model != "VirtualService" {
		t.Errorf("RestOp.Model = %v, want VirtualService", restOp.Model)
	}
}
