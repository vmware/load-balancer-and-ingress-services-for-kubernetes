/*
 * Copyright Â© 2025 Broadcom Inc. and/or its subsidiaries. All Rights Reserved.
 * All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// @AI-Generated
// [Generated by Cursor claude-4-sonnet]

package miscellaneous

import (
	"context"
	"fmt"
	"net"
	"os"
	"regexp"
	"testing"

	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	dynamicfake "k8s.io/client-go/dynamic/fake"
	k8sfake "k8s.io/client-go/kubernetes/fake"

	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/k8s"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/lib"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/objects"
	akov1alpha1 "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/apis/ako/v1alpha1"
	akov1alpha2 "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/apis/ako/v1alpha2"
	akov1beta1 "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/apis/ako/v1beta1"
	crdfake "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/client/v1alpha1/clientset/versioned/fake"
	v1alpha2crdfake "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/client/v1alpha2/clientset/versioned/fake"
	v1beta1crdfake "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/client/v1beta1/clientset/versioned/fake"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/utils"
)

var (
	kubeClient        *k8sfake.Clientset
	crdClient         *crdfake.Clientset
	v1alpha2CRDClient *v1alpha2crdfake.Clientset
	v1beta1CRDClient  *v1beta1crdfake.Clientset
	dynamicClient     *dynamicfake.FakeDynamicClient
)

// TestMain sets up the test environment
func TestMain(m *testing.M) {
	// Setup environment variables
	os.Setenv("CLUSTER_NAME", "test-cluster")
	os.Setenv("CLOUD_NAME", "CLOUD_VCENTER")
	os.Setenv("SEG_NAME", "Default-Group")
	os.Setenv("POD_NAMESPACE", utils.AKO_DEFAULT_NS)
	os.Setenv("SHARD_VS_SIZE", "LARGE")
	os.Setenv("POD_NAME", "ako-0")
	os.Setenv("SERVICE_TYPE", "ClusterIP")

	// Initialize fake clients
	kubeClient = k8sfake.NewSimpleClientset()
	crdClient = crdfake.NewSimpleClientset()
	v1alpha2CRDClient = v1alpha2crdfake.NewSimpleClientset()
	v1beta1CRDClient = v1beta1crdfake.NewSimpleClientset()

	// Setup GVR to Kind mapping for dynamic client
	gvrToKind := map[schema.GroupVersionResource]string{
		{
			Group:    "ako.vmware.com",
			Version:  "v1alpha1",
			Resource: "healthmonitors",
		}: "HealthMonitorList",
	}

	scheme := runtime.NewScheme()
	dynamicClient = dynamicfake.NewSimpleDynamicClientWithCustomListKinds(scheme, gvrToKind)

	// Initialize AKO control config
	akoControlConfig := lib.AKOControlConfig()
	akoControlConfig.SetCRDClientset(crdClient)
	akoControlConfig.Setv1alpha2CRDClientset(v1alpha2CRDClient)
	akoControlConfig.Setv1beta1CRDClientset(v1beta1CRDClient)
	akoControlConfig.SetAKOInstanceFlag(true)
	akoControlConfig.SetIsLeaderFlag(true)
	akoControlConfig.SetEventRecorder(lib.AKOEventComponent, kubeClient, true)

	// Set dynamic client
	lib.SetDynamicClientSet(dynamicClient)

	// Create avi-secret for authentication
	data := map[string][]byte{
		"username": []byte("admin"),
		"password": []byte("admin"),
	}
	object := metav1.ObjectMeta{Name: "avi-secret", Namespace: utils.GetAKONamespace()}
	secret := &corev1.Secret{Data: data, ObjectMeta: object}
	kubeClient.CoreV1().Secrets(utils.GetAKONamespace()).Create(context.TODO(), secret, metav1.CreateOptions{})

	// Initialize informers
	registeredInformers := []string{
		utils.ServiceInformer,
		utils.SecretInformer,
		utils.NSInformer,
	}
	utils.NewInformers(utils.KubeClientIntf{ClientSet: kubeClient}, registeredInformers, nil)

	// Initialize CRD informers
	k8s.NewCRDInformers()

	// Initialize shared CRD lister
	objects.SharedCRDLister()

	// Run tests
	exitCode := m.Run()
	os.Exit(exitCode)
}

// setupTestValidator creates a validator for testing
func setupTestValidator(isLeader bool) k8s.Validator {
	lib.AKOControlConfig().SetIsLeaderFlag(isLeader)
	return k8s.NewValidator()
}

// IntPtr returns a pointer to an int
func IntPtr(i int) *int {
	return &i
}

// TestNewValidator tests the validator factory function
func TestNewValidator(t *testing.T) {
	tests := []struct {
		name     string
		isLeader bool
	}{
		{
			name:     "Create leader validator",
			isLeader: true,
		},
		{
			name:     "Create follower validator",
			isLeader: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			validator := setupTestValidator(tt.isLeader)
			if validator == nil {
				t.Fatal("Expected validator to be non-nil")
			}
			t.Logf("Successfully created validator with isLeader: %v", tt.isLeader)
		})
	}
}

// TestFollowerValidatorNoOp tests that follower validators don't perform validation
func TestFollowerValidatorNoOp(t *testing.T) {
	validator := setupTestValidator(false) // Create follower validator

	// Test that follower validators return nil for all validation methods
	t.Run("ValidateHTTPRuleObj", func(t *testing.T) {
		httprule := &akov1beta1.HTTPRule{
			ObjectMeta: metav1.ObjectMeta{Name: "test", Namespace: "default"},
		}
		err := validator.ValidateHTTPRuleObj("test-key", httprule)
		if err != nil {
			t.Errorf("Follower validator should return nil, got: %v", err)
		}
	})

	t.Run("ValidateHostRuleObj", func(t *testing.T) {
		hostrule := &akov1beta1.HostRule{
			ObjectMeta: metav1.ObjectMeta{Name: "test", Namespace: "default"},
		}
		err := validator.ValidateHostRuleObj("test-key", hostrule)
		if err != nil {
			t.Errorf("Follower validator should return nil, got: %v", err)
		}
	})

	t.Run("ValidateAviInfraSetting", func(t *testing.T) {
		infraSetting := &akov1beta1.AviInfraSetting{
			ObjectMeta: metav1.ObjectMeta{Name: "test", Namespace: "default"},
		}
		err := validator.ValidateAviInfraSetting("test-key", infraSetting)
		if err != nil {
			t.Errorf("Follower validator should return nil, got: %v", err)
		}
	})

	t.Run("ValidateMultiClusterIngressObj", func(t *testing.T) {
		mci := &akov1alpha1.MultiClusterIngress{
			ObjectMeta: metav1.ObjectMeta{Name: "test", Namespace: "default"},
		}
		err := validator.ValidateMultiClusterIngressObj("test-key", mci)
		if err != nil {
			t.Errorf("Follower validator should return nil, got: %v", err)
		}
	})

	t.Run("ValidateServiceImportObj", func(t *testing.T) {
		si := &akov1alpha1.ServiceImport{
			ObjectMeta: metav1.ObjectMeta{Name: "test", Namespace: "default"},
		}
		err := validator.ValidateServiceImportObj("test-key", si)
		if err != nil {
			t.Errorf("Follower validator should return nil, got: %v", err)
		}
	})

	t.Run("ValidateSSORuleObj", func(t *testing.T) {
		ssoRule := &akov1alpha2.SSORule{
			ObjectMeta: metav1.ObjectMeta{Name: "test", Namespace: "default"},
		}
		err := validator.ValidateSSORuleObj("test-key", ssoRule)
		if err != nil {
			t.Errorf("Follower validator should return nil, got: %v", err)
		}
	})

	t.Run("ValidateL4RuleObj", func(t *testing.T) {
		l4Rule := &akov1alpha2.L4Rule{
			ObjectMeta: metav1.ObjectMeta{Name: "test", Namespace: "default"},
		}
		err := validator.ValidateL4RuleObj("test-key", l4Rule)
		if err != nil {
			t.Errorf("Follower validator should return nil, got: %v", err)
		}
	})

	t.Run("ValidateL7RuleObj", func(t *testing.T) {
		l7Rule := &akov1alpha2.L7Rule{
			ObjectMeta: metav1.ObjectMeta{Name: "test", Namespace: "default"},
		}
		err := validator.ValidateL7RuleObj("test-key", l7Rule)
		if err != nil {
			t.Errorf("Follower validator should return nil, got: %v", err)
		}
	})
}

func TestIPValidation(t *testing.T) {
	tests := []struct {
		name    string
		ip      string
		isValid bool
	}{
		{
			name:    "Valid IPv4",
			ip:      "192.168.1.1",
			isValid: true,
		},
		{
			name:    "Valid IPv4 with zeros",
			ip:      "10.0.0.1",
			isValid: true,
		},
		{
			name:    "Invalid IP - text",
			ip:      "invalid-ip",
			isValid: false,
		},
		{
			name:    "Invalid IP - out of range",
			ip:      "256.1.1.1",
			isValid: false,
		},
		{
			name:    "Invalid IP - incomplete",
			ip:      "192.168.1",
			isValid: false,
		},
		{
			name:    "Empty IP",
			ip:      "",
			isValid: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Test IP validation using net.ParseIP
			result := net.ParseIP(tt.ip)
			isValid := result != nil
			if isValid != tt.isValid {
				t.Errorf("IP validation for %s: got %v, want %v", tt.ip, isValid, tt.isValid)
			}
		})
	}
}

// TestCIDRValidation tests CIDR validation in AviInfraSetting
func TestCIDRValidation(t *testing.T) {
	tests := []struct {
		name    string
		cidr    string
		isIPv6  bool
		isValid bool
	}{
		{
			name:    "Valid IPv4 CIDR",
			cidr:    "192.168.1.0/24",
			isIPv6:  false,
			isValid: true,
		},
		{
			name:    "Valid IPv4 CIDR with /32",
			cidr:    "10.0.0.1/32",
			isIPv6:  false,
			isValid: true,
		},
		{
			name:    "Valid IPv6 CIDR",
			cidr:    "2001:db8::/32",
			isIPv6:  true,
			isValid: true,
		},
		{
			name:    "Invalid IPv4 CIDR - no mask",
			cidr:    "192.168.1.0",
			isIPv6:  false,
			isValid: false,
		},
		{
			name:    "Invalid IPv4 CIDR - bad format",
			cidr:    "invalid-cidr/24",
			isIPv6:  false,
			isValid: false,
		},
		{
			name:    "Invalid IPv6 CIDR - bad format",
			cidr:    "invalid-ipv6/64",
			isIPv6:  true,
			isValid: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Test CIDR validation using regexp (as done in validator.go)
			var re *regexp.Regexp
			if tt.isIPv6 {
				re = regexp.MustCompile(lib.IPV6CIDRRegex)
			} else {
				re = regexp.MustCompile(lib.IPCIDRRegex)
			}
			isValid := re.MatchString(tt.cidr)
			if isValid != tt.isValid {
				t.Errorf("CIDR validation for %s: got %v, want %v", tt.cidr, isValid, tt.isValid)
			}
		})
	}
}

// TestDuplicateFQDNValidation tests duplicate FQDN detection

// TestRevokeVipRouteValidation tests RevokeVipRoute validation for L4Rule

// TestHealthMonitorCRDRefValidation tests HealthMonitor CRD reference validation

// TestL7RuleReferences tests L7Rule reference validation

// TestL4RuleWithHealthMonitorValidation tests L4Rule validation with HealthMonitor CRDs
func TestL4RuleWithHealthMonitorValidation(t *testing.T) {
	// Enable AKO CRD Operator
	os.Setenv("AKO_CRD_OPERATOR_ENABLED", "true")
	defer os.Unsetenv("AKO_CRD_OPERATOR_ENABLED")

	validator := setupTestValidator(true)

	tests := []struct {
		name          string
		l4Rule        *akov1alpha2.L4Rule
		healthMonitor *unstructured.Unstructured
		createHM      bool
		wantErr       bool
		errContains   string
	}{
		{
			name: "Valid L4Rule with TCP health monitor",
			l4Rule: &akov1alpha2.L4Rule{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "test-l4rule",
					Namespace: "default",
				},
				Spec: akov1alpha2.L4RuleSpec{
					BackendProperties: []*akov1alpha2.BackendProperties{
						{
							Protocol:             StringPtr("TCP"),
							HealthMonitorCrdRefs: []string{"tcp-hm"},
						},
					},
				},
			},
			healthMonitor: createHealthMonitorUnstructured("tcp-hm", "default", lib.AllowedTCPHealthMonitorType, true, true),
			createHM:      true,
			wantErr:       false,
		},
		{
			name: "L4Rule with missing health monitor",
			l4Rule: &akov1alpha2.L4Rule{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "test-l4rule",
					Namespace: "default",
				},
				Spec: akov1alpha2.L4RuleSpec{
					BackendProperties: []*akov1alpha2.BackendProperties{
						{
							Protocol:             StringPtr("TCP"),
							HealthMonitorCrdRefs: []string{"missing-hm"},
						},
					},
				},
			},
			createHM:    false,
			wantErr:     true,
			errContains: "not found",
		},
		{
			name: "L4Rule with empty health monitor name",
			l4Rule: &akov1alpha2.L4Rule{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "test-l4rule",
					Namespace: "default",
				},
				Spec: akov1alpha2.L4RuleSpec{
					BackendProperties: []*akov1alpha2.BackendProperties{
						{
							Protocol:             StringPtr("TCP"),
							HealthMonitorCrdRefs: []string{""},
						},
					},
				},
			},
			createHM:    false,
			wantErr:     true,
			errContains: "Empty HealthMonitor name",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create health monitor if needed
			if tt.createHM && tt.healthMonitor != nil {
				_, err := dynamicClient.Resource(lib.HealthMonitorGVR).Namespace(tt.healthMonitor.GetNamespace()).Create(
					context.TODO(), tt.healthMonitor, metav1.CreateOptions{})
				if err != nil {
					t.Fatalf("Failed to create health monitor: %v", err)
				}
				defer dynamicClient.Resource(lib.HealthMonitorGVR).Namespace(tt.healthMonitor.GetNamespace()).Delete(
					context.TODO(), tt.healthMonitor.GetName(), metav1.DeleteOptions{})
			}

			// Validate L4Rule
			err := validator.ValidateL4RuleObj(fmt.Sprintf("L4Rule/%s/%s", tt.l4Rule.Namespace, tt.l4Rule.Name), tt.l4Rule)

			if tt.wantErr {
				if err == nil {
					t.Errorf("Expected error containing %q, got nil", tt.errContains)
				} else if tt.errContains != "" && !contains(err.Error(), tt.errContains) {
					t.Errorf("Expected error containing %q, got %q", tt.errContains, err.Error())
				}
			} else {
				if err != nil {
					t.Errorf("Expected no error, got: %v", err)
				}
			}
		})
	}
}

// createHealthMonitorUnstructured creates an unstructured HealthMonitor for testing
func createHealthMonitorUnstructured(name, namespace, hmType string, processed, ready bool) *unstructured.Unstructured {
	status := "True"
	if !ready {
		status = "False"
	}

	hm := &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "ako.vmware.com/v1alpha1",
			"kind":       "HealthMonitor",
			"metadata": map[string]interface{}{
				"name":      name,
				"namespace": namespace,
			},
			"spec": map[string]interface{}{
				"type": hmType,
			},
			"status": map[string]interface{}{
				"tenant": "admin",
				"conditions": []interface{}{
					map[string]interface{}{
						"type":    "Programmed",
						"status":  status,
						"reason":  "Accepted",
						"message": "HealthMonitor has been successfully processed",
					},
				},
			},
		},
	}
	return hm
}

// contains checks if a string contains a substring
func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(substr) == 0 ||
		(len(s) > 0 && len(substr) > 0 && stringContains(s, substr)))
}

func stringContains(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}

// TestValidatorIntegration tests validator integration scenarios
func TestValidatorIntegration(t *testing.T) {
	tests := []struct {
		name    string
		setup   func()
		cleanup func()
	}{
		{
			name: "Initialize validator components",
			setup: func() {
				// Initialize shared CRD lister
				objects.SharedCRDLister()
			},
			cleanup: func() {
				// Cleanup if needed
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.setup != nil {
				tt.setup()
			}
			if tt.cleanup != nil {
				defer tt.cleanup()
			}
			t.Logf("Running integration test: %s", tt.name)
		})
	}
}

// TestSecretValidationWithK8sClient tests secret validation with actual K8s client
func TestSecretValidationWithK8sClient(t *testing.T) {
	// Create fake Kubernetes client
	kubeClient := k8sfake.NewSimpleClientset()

	// Create a test secret
	secret := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-secret",
			Namespace: "default",
		},
		Data: map[string][]byte{
			"tls.crt": []byte("test-cert"),
			"tls.key": []byte("test-key"),
		},
	}

	_, err := kubeClient.CoreV1().Secrets("default").Create(context.TODO(), secret, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create test secret: %v", err)
	}

	// Test secret retrieval
	retrievedSecret, err := kubeClient.CoreV1().Secrets("default").Get(context.TODO(), "test-secret", metav1.GetOptions{})
	if err != nil {
		t.Errorf("Failed to retrieve secret: %v", err)
	}

	if retrievedSecret.Name != "test-secret" {
		t.Errorf("Retrieved secret name mismatch: got %s, want test-secret", retrievedSecret.Name)
	}

	// Test non-existent secret
	_, err = kubeClient.CoreV1().Secrets("default").Get(context.TODO(), "missing-secret", metav1.GetOptions{})
	if err == nil {
		t.Error("Expected error for missing secret, got nil")
	}
}

// TestValidatorStatusUpdates tests status update scenarios
