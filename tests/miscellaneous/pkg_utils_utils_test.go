/*
 * Copyright Â© 2025 Broadcom Inc. and/or its subsidiaries. All Rights Reserved.
 * All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// @AI-Generated
// [Generated by Cursor claude-4-sonnet]

package miscellaneous

import (
	"encoding/json"
	"testing"

	corev1 "k8s.io/api/core/v1"
	discovery "k8s.io/api/discovery/v1"
	networkingv1 "k8s.io/api/networking/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/utils"
)

func TestIsV4(t *testing.T) {
	tests := []struct {
		name string
		addr string
		want bool
	}{
		{
			name: "Valid IPv4 address",
			addr: "192.168.1.1",
			want: true,
		},
		{
			name: "Valid IPv4 localhost",
			addr: "127.0.0.1",
			want: true,
		},
		{
			name: "Valid IPv4 zero address",
			addr: "0.0.0.0",
			want: true,
		},
		{
			name: "IPv6 address",
			addr: "2001:0db8:85a3:0000:0000:8a2e:0370:7334",
			want: false,
		},
		{
			name: "IPv6 localhost",
			addr: "::1",
			want: false,
		},
		{
			name: "Invalid IP address",
			addr: "invalid",
			want: false,
		},
		{
			name: "Empty string",
			addr: "",
			want: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := utils.IsV4(tt.addr); got != tt.want {
				t.Errorf("IsV4() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestIsSvcHttp(t *testing.T) {
	tests := []struct {
		name     string
		svcName  string
		port     int32
		expected bool
	}{
		{
			name:     "Service name is http",
			svcName:  "http",
			port:     9000,
			expected: true,
		},
		{
			name:     "Service name starts with http-",
			svcName:  "http-web",
			port:     9000,
			expected: true,
		},
		{
			name:     "Port 80",
			svcName:  "web",
			port:     80,
			expected: true,
		},
		{
			name:     "Port 443",
			svcName:  "web",
			port:     443,
			expected: true,
		},
		{
			name:     "Port 8080",
			svcName:  "web",
			port:     8080,
			expected: true,
		},
		{
			name:     "Port 8443",
			svcName:  "web",
			port:     8443,
			expected: true,
		},
		{
			name:     "Non-HTTP service and port",
			svcName:  "grpc",
			port:     9090,
			expected: false,
		},
		{
			name:     "Empty service name with non-standard port",
			svcName:  "",
			port:     9000,
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.IsSvcHttp(tt.svcName, tt.port)
			if got != tt.expected {
				t.Errorf("IsSvcHttp(%s, %d) = %v, want %v", tt.svcName, tt.port, got, tt.expected)
			}
		})
	}
}

func TestAviUrlToObjType(t *testing.T) {
	tests := []struct {
		name    string
		aviurl  string
		want    string
		wantErr bool
	}{
		{
			name:    "Valid virtualservice URL",
			aviurl:  "https://controller.local/api/virtualservice/virtualservice-123",
			want:    "virtualservice",
			wantErr: false,
		},
		{
			name:    "Valid pool URL",
			aviurl:  "https://controller.local/api/pool/pool-456",
			want:    "pool",
			wantErr: false,
		},
		{
			name:    "Valid poolgroup URL",
			aviurl:  "https://controller.local/api/poolgroup/pg-789",
			want:    "poolgroup",
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := utils.AviUrlToObjType(tt.aviurl)
			if (err != nil) != tt.wantErr {
				t.Errorf("AviUrlToObjType() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if got != tt.want {
				t.Errorf("AviUrlToObjType() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestHash(t *testing.T) {
	tests := []struct {
		name  string
		input string
	}{
		{
			name:  "Simple string",
			input: "test",
		},
		{
			name:  "Empty string",
			input: "",
		},
		{
			name:  "Long string",
			input: "this is a very long string for testing hash function",
		},
		{
			name:  "String with special characters",
			input: "test@#$%^&*()",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			hash1 := utils.Hash(tt.input)
			hash2 := utils.Hash(tt.input)

			// Hash should be deterministic
			if hash1 != hash2 {
				t.Errorf("Hash() not deterministic: got %v and %v for same input", hash1, hash2)
			}
		})
	}

	// Test that different strings produce different hashes
	hash1 := utils.Hash("string1")
	hash2 := utils.Hash("string2")
	if hash1 == hash2 {
		t.Errorf("Hash() produced same hash for different strings")
	}
}

func TestBkt(t *testing.T) {
	tests := []struct {
		name        string
		key         string
		numWorkers  uint32
		expectRange bool
	}{
		{
			name:        "4 workers",
			key:         "test-key",
			numWorkers:  4,
			expectRange: true,
		},
		{
			name:        "8 workers",
			key:         "another-key",
			numWorkers:  8,
			expectRange: true,
		},
		{
			name:        "16 workers",
			key:         "namespace/name",
			numWorkers:  16,
			expectRange: true,
		},
		{
			name:        "1 worker",
			key:         "single",
			numWorkers:  1,
			expectRange: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.Bkt(tt.key, tt.numWorkers)

			// Result should be less than numWorkers
			if got >= tt.numWorkers {
				t.Errorf("Bkt() = %v, should be less than %v", got, tt.numWorkers)
			}

			// Same key should always return same bucket
			got2 := utils.Bkt(tt.key, tt.numWorkers)
			if got != got2 {
				t.Errorf("Bkt() not deterministic: got %v and %v for same input", got, got2)
			}
		})
	}
}

func TestDeepCopy(t *testing.T) {
	type TestStruct struct {
		Name  string
		Value int
		Tags  []string
	}

	tests := []struct {
		name string
		src  TestStruct
	}{
		{
			name: "Simple struct",
			src: TestStruct{
				Name:  "test",
				Value: 42,
				Tags:  []string{"tag1", "tag2"},
			},
		},
		{
			name: "Empty struct",
			src:  TestStruct{},
		},
		{
			name: "Struct with nil slice",
			src: TestStruct{
				Name:  "test",
				Value: 10,
				Tags:  nil,
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var dst TestStruct
			utils.DeepCopy(tt.src, &dst)

			// Check that values are copied
			if dst.Name != tt.src.Name {
				t.Errorf("DeepCopy() Name = %v, want %v", dst.Name, tt.src.Name)
			}
			if dst.Value != tt.src.Value {
				t.Errorf("DeepCopy() Value = %v, want %v", dst.Value, tt.src.Value)
			}

			// Verify it's a deep copy by modifying source
			tt.src.Name = "modified"
			if dst.Name == "modified" {
				t.Errorf("DeepCopy() did not create independent copy")
			}
		})
	}
}

func TestStringify(t *testing.T) {
	tests := []struct {
		name     string
		input    interface{}
		expected string
	}{
		{
			name:     "Simple map",
			input:    map[string]string{"key": "value"},
			expected: `{"key":"value"}`,
		},
		{
			name:     "Empty map",
			input:    map[string]string{},
			expected: `{}`,
		},
		{
			name:     "String",
			input:    "test",
			expected: `"test"`,
		},
		{
			name:     "Integer",
			input:    42,
			expected: `42`,
		},
		{
			name:     "Slice",
			input:    []string{"a", "b", "c"},
			expected: `["a","b","c"]`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.Stringify(tt.input)
			if got != tt.expected {
				t.Errorf("Stringify() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestExtractNamespaceObjectName(t *testing.T) {
	tests := []struct {
		name          string
		key           string
		wantNamespace string
		wantName      string
	}{
		{
			name:          "Two segments",
			key:           "default/my-service",
			wantNamespace: "default",
			wantName:      "my-service",
		},
		{
			name:          "Three segments",
			key:           "default/subpath/my-service",
			wantNamespace: "default",
			wantName:      "subpath/my-service",
		},
		{
			name:          "Single segment",
			key:           "single",
			wantNamespace: "",
			wantName:      "",
		},
		{
			name:          "Empty string",
			key:           "",
			wantNamespace: "",
			wantName:      "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gotNs, gotName := utils.ExtractNamespaceObjectName(tt.key)
			if gotNs != tt.wantNamespace {
				t.Errorf("ExtractNamespaceObjectName() namespace = %v, want %v", gotNs, tt.wantNamespace)
			}
			if gotName != tt.wantName {
				t.Errorf("ExtractNamespaceObjectName() name = %v, want %v", gotName, tt.wantName)
			}
		})
	}
}

func TestHasElem(t *testing.T) {
	tests := []struct {
		name  string
		slice interface{}
		elem  interface{}
		want  bool
	}{
		{
			name:  "Element exists in string slice",
			slice: []string{"a", "b", "c"},
			elem:  "b",
			want:  true,
		},
		{
			name:  "Element does not exist in string slice",
			slice: []string{"a", "b", "c"},
			elem:  "d",
			want:  false,
		},
		{
			name:  "Element exists in int slice",
			slice: []int{1, 2, 3},
			elem:  2,
			want:  true,
		},
		{
			name:  "Element does not exist in int slice",
			slice: []int{1, 2, 3},
			elem:  4,
			want:  false,
		},
		{
			name:  "Empty slice",
			slice: []string{},
			elem:  "a",
			want:  false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.HasElem(tt.slice, tt.elem)
			if got != tt.want {
				t.Errorf("HasElem() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRemove(t *testing.T) {
	tests := []struct {
		name     string
		arr      []string
		item     string
		expected []string
	}{
		{
			name:     "Remove existing item",
			arr:      []string{"a", "b", "c"},
			item:     "b",
			expected: []string{"a", "c"},
		},
		{
			name:     "Remove first item",
			arr:      []string{"a", "b", "c"},
			item:     "a",
			expected: []string{"b", "c"},
		},
		{
			name:     "Remove last item",
			arr:      []string{"a", "b", "c"},
			item:     "c",
			expected: []string{"a", "b"},
		},
		{
			name:     "Remove non-existing item",
			arr:      []string{"a", "b", "c"},
			item:     "d",
			expected: []string{"a", "b", "c"},
		},
		{
			name:     "Remove from empty slice",
			arr:      []string{},
			item:     "a",
			expected: []string{},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Make a copy to avoid modifying test data
			arrCopy := make([]string, len(tt.arr))
			copy(arrCopy, tt.arr)

			got := utils.Remove(arrCopy, tt.item)

			if len(got) != len(tt.expected) {
				t.Errorf("Remove() length = %v, want %v", len(got), len(tt.expected))
				return
			}

			for i := range got {
				if got[i] != tt.expected[i] {
					t.Errorf("Remove() = %v, want %v", got, tt.expected)
					break
				}
			}
		})
	}
}

func TestFindAndRemove(t *testing.T) {
	tests := []struct {
		name        string
		arr         []string
		item        string
		expectFound bool
		expectedArr []string
	}{
		{
			name:        "Find and remove existing item",
			arr:         []string{"a", "b", "c"},
			item:        "b",
			expectFound: true,
			expectedArr: []string{"a", "c"},
		},
		{
			name:        "Item not found",
			arr:         []string{"a", "b", "c"},
			item:        "d",
			expectFound: false,
			expectedArr: []string{"a", "b", "c"},
		},
		{
			name:        "Empty slice",
			arr:         []string{},
			item:        "a",
			expectFound: false,
			expectedArr: []string{},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Make a copy to avoid modifying test data
			arrCopy := make([]string, len(tt.arr))
			copy(arrCopy, tt.arr)

			found, got := utils.FindAndRemove(arrCopy, tt.item)

			if found != tt.expectFound {
				t.Errorf("FindAndRemove() found = %v, want %v", found, tt.expectFound)
			}

			if len(got) != len(tt.expectedArr) {
				t.Errorf("FindAndRemove() length = %v, want %v", len(got), len(tt.expectedArr))
				return
			}

			for i := range got {
				if got[i] != tt.expectedArr[i] {
					t.Errorf("FindAndRemove() = %v, want %v", got, tt.expectedArr)
					break
				}
			}
		})
	}
}

func TestRandomSeq(t *testing.T) {
	tests := []struct {
		name   string
		length int
	}{
		{
			name:   "Length 5",
			length: 5,
		},
		{
			name:   "Length 10",
			length: 10,
		},
		{
			name:   "Length 0",
			length: 0,
		},
		{
			name:   "Length 1",
			length: 1,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.RandomSeq(tt.length)

			if len(got) != tt.length {
				t.Errorf("RandomSeq(%d) length = %v, want %v", tt.length, len(got), tt.length)
			}

			// Verify all characters are from the allowed set
			allowedChars := "abcdefghijklmnopqrstuvwxyz1234567890"
			for _, char := range got {
				if !containsRune(allowedChars, char) {
					t.Errorf("RandomSeq() contains invalid character: %c", char)
				}
			}
		})
	}

	// Test that multiple calls produce different results (probabilistically)
	seq1 := utils.RandomSeq(10)
	seq2 := utils.RandomSeq(10)
	if seq1 == seq2 {
		// This could theoretically fail, but probability is very low
		t.Log("Warning: Two random sequences are identical (this is possible but unlikely)")
	}
}

func containsRune(s string, r rune) bool {
	for _, c := range s {
		if c == r {
			return true
		}
	}
	return false
}

func TestDeepCopyJSON(t *testing.T) {
	// Test that DeepCopy works with complex nested structures
	type Nested struct {
		Field1 string
		Field2 int
	}

	type Complex struct {
		Name   string
		Nested Nested
		List   []string
	}

	src := Complex{
		Name: "test",
		Nested: Nested{
			Field1: "nested",
			Field2: 42,
		},
		List: []string{"a", "b"},
	}

	var dst Complex
	utils.DeepCopy(src, &dst)

	// Verify deep copy
	if dst.Name != src.Name {
		t.Errorf("DeepCopy() Name not copied correctly")
	}
	if dst.Nested.Field1 != src.Nested.Field1 {
		t.Errorf("DeepCopy() Nested.Field1 not copied correctly")
	}
	if dst.Nested.Field2 != src.Nested.Field2 {
		t.Errorf("DeepCopy() Nested.Field2 not copied correctly")
	}

	// Modify source and verify destination is independent
	src.Nested.Field1 = "modified"
	if dst.Nested.Field1 == "modified" {
		t.Errorf("DeepCopy() did not create independent nested copy")
	}
}

func TestStringifyJSON(t *testing.T) {
	// Test that Stringify produces valid JSON
	input := map[string]interface{}{
		"string": "value",
		"number": 42,
		"bool":   true,
		"null":   nil,
	}

	result := utils.Stringify(input)

	// Verify it's valid JSON by unmarshaling
	var decoded map[string]interface{}
	err := json.Unmarshal([]byte(result), &decoded)
	if err != nil {
		t.Errorf("Stringify() produced invalid JSON: %v", err)
	}

	// Verify values
	if decoded["string"] != "value" {
		t.Errorf("Stringify() string value incorrect")
	}
	if decoded["number"].(float64) != 42 {
		t.Errorf("Stringify() number value incorrect")
	}
	if decoded["bool"] != true {
		t.Errorf("Stringify() bool value incorrect")
	}
}

func TestContainsDuplicate(t *testing.T) {
	tests := []struct {
		name     string
		arr      interface{}
		expected bool
	}{
		{
			name:     "String slice with duplicates",
			arr:      []string{"a", "b", "c", "b"},
			expected: true,
		},
		{
			name:     "String slice without duplicates",
			arr:      []string{"a", "b", "c"},
			expected: false,
		},
		{
			name:     "Int slice with duplicates",
			arr:      []int{1, 2, 3, 2},
			expected: true,
		},
		{
			name:     "Int slice without duplicates",
			arr:      []int{1, 2, 3},
			expected: false,
		},
		{
			name:     "Empty slice",
			arr:      []string{},
			expected: false,
		},
		{
			name:     "Single element",
			arr:      []string{"a"},
			expected: false,
		},
		{
			name:     "All duplicates",
			arr:      []int{5, 5, 5},
			expected: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.ContainsDuplicate(tt.arr)
			if got != tt.expected {
				t.Errorf("ContainsDuplicate() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestNewVersion(t *testing.T) {
	tests := []struct {
		name       string
		version    string
		wantErr    bool
		wantLength int
	}{
		{
			name:       "Simple version",
			version:    "1.2.3",
			wantErr:    false,
			wantLength: 3,
		},
		{
			name:       "Two part version",
			version:    "1.0",
			wantErr:    false,
			wantLength: 2,
		},
		{
			name:       "Four part version",
			version:    "1.2.3.4",
			wantErr:    false,
			wantLength: 4,
		},
		{
			name:       "Single digit",
			version:    "1",
			wantErr:    false,
			wantLength: 1,
		},
		{
			name:    "Invalid version with letter",
			version: "1.2.a",
			wantErr: true,
		},
		{
			name:    "Empty string",
			version: "",
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := utils.NewVersion(tt.version)
			if (err != nil) != tt.wantErr {
				t.Errorf("NewVersion() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !tt.wantErr && got == nil {
				t.Errorf("NewVersion() returned nil without error")
			}
		})
	}
}

func TestVersionCompare(t *testing.T) {
	tests := []struct {
		name     string
		version1 string
		version2 string
		expected int
	}{
		{
			name:     "Equal versions",
			version1: "1.2.3",
			version2: "1.2.3",
			expected: 0,
		},
		{
			name:     "First version greater",
			version1: "1.2.4",
			version2: "1.2.3",
			expected: 1,
		},
		{
			name:     "First version less",
			version1: "1.2.2",
			version2: "1.2.3",
			expected: -1,
		},
		{
			name:     "Different lengths - first longer and greater",
			version1: "1.2.3.1",
			version2: "1.2.3",
			expected: 1,
		},
		{
			name:     "Different lengths - first shorter and less",
			version1: "1.2",
			version2: "1.2.3",
			expected: -1,
		},
		{
			name:     "Major version difference",
			version1: "2.0.0",
			version2: "1.9.9",
			expected: 1,
		},
		{
			name:     "Minor version difference",
			version1: "1.3.0",
			version2: "1.2.9",
			expected: 1,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			v1, err := utils.NewVersion(tt.version1)
			if err != nil {
				t.Fatalf("Failed to create version1: %v", err)
			}
			v2, err := utils.NewVersion(tt.version2)
			if err != nil {
				t.Fatalf("Failed to create version2: %v", err)
			}

			got := v1.Compare(v2)
			if got != tt.expected {
				t.Errorf("Version.Compare() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestString(t *testing.T) {
	tests := []struct {
		name     string
		input    *string
		expected string
	}{
		{
			name:     "Non-nil string pointer",
			input:    StringPtr("test"),
			expected: "test",
		},
		{
			name:     "Empty string pointer",
			input:    StringPtr(""),
			expected: "",
		},
		{
			name:     "Nil string pointer",
			input:    nil,
			expected: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.String(tt.input)
			if got != tt.expected {
				t.Errorf("String() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestCheckSubdomainOverlapping(t *testing.T) {
	tests := []struct {
		name      string
		hostName1 string
		hostName2 string
		expected  bool
	}{
		{
			name:      "Exact match",
			hostName1: "example.com",
			hostName2: "example.com",
			expected:  true,
		},
		{
			name:      "Wildcard in first hostname",
			hostName1: "*.example.com",
			hostName2: "api.example.com",
			expected:  true,
		},
		{
			name:      "Wildcard in second hostname",
			hostName1: "api.example.com",
			hostName2: "*.example.com",
			expected:  true,
		},
		{
			name:      "Both wildcards",
			hostName1: "*.example.com",
			hostName2: "*.example.com",
			expected:  true,
		},
		{
			name:      "Different subdomains",
			hostName1: "api.example.com",
			hostName2: "web.example.com",
			expected:  false,
		},
		{
			name:      "Different domains",
			hostName1: "example.com",
			hostName2: "example.org",
			expected:  false,
		},
		{
			name:      "Subdomain vs root domain",
			hostName1: "api.example.com",
			hostName2: "example.com",
			expected:  true,
		},
		{
			name:      "Multi-level subdomains matching",
			hostName1: "api.v1.example.com",
			hostName2: "web.v1.example.com",
			expected:  false,
		},
		{
			name:      "Multi-level with wildcard",
			hostName1: "*.v1.example.com",
			hostName2: "api.v1.example.com",
			expected:  true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.CheckSubdomainOverlapping(tt.hostName1, tt.hostName2)
			if got != tt.expected {
				t.Errorf("CheckSubdomainOverlapping(%s, %s) = %v, want %v",
					tt.hostName1, tt.hostName2, got, tt.expected)
			}
		})
	}
}

func TestGetUriEncoded(t *testing.T) {
	tests := []struct {
		name     string
		uri      string
		expected string
	}{
		{
			name:     "URI without query parameters",
			uri:      "https://example.com/path",
			expected: "https://example.com/path",
		},
		{
			name:     "URI with simple query parameters",
			uri:      "https://example.com/path?key=value",
			expected: "https://example.com/path?key=value",
		},
		{
			name:     "URI with special characters in query",
			uri:      "https://example.com/path?key=value with spaces",
			expected: "https://example.com/path?key=value+with+spaces",
		},
		{
			name:     "URI with multiple query parameters",
			uri:      "https://example.com/path?key1=value1&key2=value2",
			expected: "https://example.com/path?key1=value1&key2=value2",
		},
		{
			name:     "URI with empty query value",
			uri:      "https://example.com/path?key=",
			expected: "https://example.com/path?key=",
		},
		{
			name:     "Simple path without scheme",
			uri:      "/path",
			expected: "/path",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.GetUriEncoded(tt.uri)
			if got != tt.expected {
				t.Errorf("GetUriEncoded() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestNewSet(t *testing.T) {
	t.Run("Create empty set", func(t *testing.T) {
		s := utils.NewSet[string]()
		if s.Size() != 0 {
			t.Errorf("NewSet() size = %v, want 0", s.Size())
		}
	})

	t.Run("Create set with initial values", func(t *testing.T) {
		s := utils.NewSet("a", "b", "c")
		if s.Size() != 3 {
			t.Errorf("NewSet() size = %v, want 3", s.Size())
		}
		if !s.Has("a") || !s.Has("b") || !s.Has("c") {
			t.Errorf("NewSet() missing expected elements")
		}
	})

	t.Run("Create set with duplicate values", func(t *testing.T) {
		s := utils.NewSet("a", "b", "a")
		if s.Size() != 2 {
			t.Errorf("NewSet() with duplicates size = %v, want 2", s.Size())
		}
	})
}

func TestSetAdd(t *testing.T) {
	t.Run("Add single element", func(t *testing.T) {
		s := utils.NewSet[string]()
		s.Add("a")
		if !s.Has("a") {
			t.Errorf("Set.Add() element not added")
		}
		if s.Size() != 1 {
			t.Errorf("Set.Add() size = %v, want 1", s.Size())
		}
	})

	t.Run("Add multiple elements", func(t *testing.T) {
		s := utils.NewSet[string]()
		s.Add("a", "b", "c")
		if s.Size() != 3 {
			t.Errorf("Set.Add() multiple elements size = %v, want 3", s.Size())
		}
	})

	t.Run("Add duplicate element", func(t *testing.T) {
		s := utils.NewSet("a")
		s.Add("a")
		if s.Size() != 1 {
			t.Errorf("Set.Add() duplicate size = %v, want 1", s.Size())
		}
	})
}

func TestSetRemove(t *testing.T) {
	t.Run("Remove existing element", func(t *testing.T) {
		s := utils.NewSet("a", "b", "c")
		s.Remove("b")
		if s.Has("b") {
			t.Errorf("Set.Remove() element still exists")
		}
		if s.Size() != 2 {
			t.Errorf("Set.Remove() size = %v, want 2", s.Size())
		}
	})

	t.Run("Remove non-existing element", func(t *testing.T) {
		s := utils.NewSet("a", "b")
		s.Remove("c")
		if s.Size() != 2 {
			t.Errorf("Set.Remove() non-existing changed size")
		}
	})

	t.Run("Remove multiple elements", func(t *testing.T) {
		s := utils.NewSet("a", "b", "c", "d")
		s.Remove("a", "c")
		if s.Size() != 2 {
			t.Errorf("Set.Remove() multiple size = %v, want 2", s.Size())
		}
		if s.Has("a") || s.Has("c") {
			t.Errorf("Set.Remove() elements still exist")
		}
	})
}

func TestSetHas(t *testing.T) {
	s := utils.NewSet("a", "b", "c")

	tests := []struct {
		name     string
		key      string
		expected bool
	}{
		{
			name:     "Existing element",
			key:      "a",
			expected: true,
		},
		{
			name:     "Non-existing element",
			key:      "d",
			expected: false,
		},
		{
			name:     "Empty string in set",
			key:      "",
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := s.Has(tt.key)
			if got != tt.expected {
				t.Errorf("Set.Has(%s) = %v, want %v", tt.key, got, tt.expected)
			}
		})
	}
}

func TestSetSize(t *testing.T) {
	tests := []struct {
		name     string
		elements []string
		expected int
	}{
		{
			name:     "Empty set",
			elements: []string{},
			expected: 0,
		},
		{
			name:     "Single element",
			elements: []string{"a"},
			expected: 1,
		},
		{
			name:     "Multiple elements",
			elements: []string{"a", "b", "c"},
			expected: 3,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s := utils.NewSet(tt.elements...)
			got := s.Size()
			if got != tt.expected {
				t.Errorf("Set.Size() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestSetKeys(t *testing.T) {
	t.Run("Get keys from set", func(t *testing.T) {
		s := utils.NewSet("a", "b", "c")
		keys := s.Keys()

		if len(keys) != 3 {
			t.Errorf("Set.Keys() length = %v, want 3", len(keys))
		}

		// Check all expected keys are present
		keyMap := make(map[string]bool)
		for _, k := range keys {
			keyMap[k] = true
		}

		if !keyMap["a"] || !keyMap["b"] || !keyMap["c"] {
			t.Errorf("Set.Keys() missing expected keys")
		}
	})

	t.Run("Get keys from empty set", func(t *testing.T) {
		s := utils.NewSet[string]()
		keys := s.Keys()

		if len(keys) != 0 {
			t.Errorf("Set.Keys() empty set length = %v, want 0", len(keys))
		}
	})
}

func TestUtilsRemoveNamespaceName(t *testing.T) {
	tests := []struct {
		name     string
		slice    []utils.NamespaceName
		remove   utils.NamespaceName
		expected []utils.NamespaceName
	}{
		{
			name: "Remove existing element",
			slice: []utils.NamespaceName{
				{Namespace: "ns1", Name: "name1"},
				{Namespace: "ns2", Name: "name2"},
				{Namespace: "ns3", Name: "name3"},
			},
			remove: utils.NamespaceName{Namespace: "ns2", Name: "name2"},
			expected: []utils.NamespaceName{
				{Namespace: "ns1", Name: "name1"},
				{Namespace: "ns3", Name: "name3"},
			},
		},
		{
			name: "Remove non-existing element",
			slice: []utils.NamespaceName{
				{Namespace: "ns1", Name: "name1"},
				{Namespace: "ns2", Name: "name2"},
			},
			remove: utils.NamespaceName{Namespace: "ns3", Name: "name3"},
			expected: []utils.NamespaceName{
				{Namespace: "ns1", Name: "name1"},
				{Namespace: "ns2", Name: "name2"},
			},
		},
		{
			name:     "Remove from empty slice",
			slice:    []utils.NamespaceName{},
			remove:   utils.NamespaceName{Namespace: "ns1", Name: "name1"},
			expected: []utils.NamespaceName{},
		},
		{
			name: "Remove first element",
			slice: []utils.NamespaceName{
				{Namespace: "ns1", Name: "name1"},
				{Namespace: "ns2", Name: "name2"},
			},
			remove: utils.NamespaceName{Namespace: "ns1", Name: "name1"},
			expected: []utils.NamespaceName{
				{Namespace: "ns2", Name: "name2"},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.RemoveNamespaceName(tt.slice, tt.remove)

			if len(got) != len(tt.expected) {
				t.Errorf("RemoveNamespaceName() length = %v, want %v", len(got), len(tt.expected))
				return
			}

			for i := range got {
				if got[i] != tt.expected[i] {
					t.Errorf("RemoveNamespaceName() = %v, want %v", got, tt.expected)
					break
				}
			}
		})
	}
}

func TestHasElemWithName(t *testing.T) {
	type TestStruct struct {
		Name  string
		Value int
	}

	tests := []struct {
		name     string
		slice    interface{}
		elem     interface{}
		expected int
	}{
		{
			name: "Element exists",
			slice: []TestStruct{
				{Name: "first", Value: 1},
				{Name: "second", Value: 2},
				{Name: "third", Value: 3},
			},
			elem:     TestStruct{Name: "second", Value: 999},
			expected: 1,
		},
		{
			name: "Element does not exist",
			slice: []TestStruct{
				{Name: "first", Value: 1},
				{Name: "second", Value: 2},
			},
			elem:     TestStruct{Name: "third", Value: 3},
			expected: -1,
		},
		{
			name:     "Empty slice",
			slice:    []TestStruct{},
			elem:     TestStruct{Name: "first", Value: 1},
			expected: -1,
		},
		{
			name: "First element match",
			slice: []TestStruct{
				{Name: "first", Value: 1},
				{Name: "second", Value: 2},
			},
			elem:     TestStruct{Name: "first", Value: 999},
			expected: 0,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.HasElemWithName(tt.slice, tt.elem)
			if got != tt.expected {
				t.Errorf("HasElemWithName() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestCrudHashKey(t *testing.T) {
	tests := []struct {
		name     string
		objType  string
		obj      interface{}
		expected string
	}{
		{
			name:    "EndpointSlice",
			objType: "EndpointSlice",
			obj: &discovery.EndpointSlice{
				ObjectMeta: metav1.ObjectMeta{
					Namespace: "default",
					Name:      "my-endpoint-slice",
				},
			},
			expected: "default:my-endpoint-slice",
		},
		{
			name:    "Service",
			objType: "Service",
			obj: &corev1.Service{
				ObjectMeta: metav1.ObjectMeta{
					Namespace: "kube-system",
					Name:      "my-service",
				},
			},
			expected: "kube-system:my-service",
		},
		{
			name:    "Ingress",
			objType: "Ingress",
			obj: &networkingv1.Ingress{
				ObjectMeta: metav1.ObjectMeta{
					Namespace: "app-namespace",
					Name:      "my-ingress",
				},
			},
			expected: "app-namespace:my-ingress",
		},
		{
			name:     "Unknown type",
			objType:  "UnknownType",
			obj:      "some-object",
			expected: ":",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.CrudHashKey(tt.objType, tt.obj)
			if got != tt.expected {
				t.Errorf("CrudHashKey() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestObjKey(t *testing.T) {
	tests := []struct {
		name     string
		obj      interface{}
		expected string
	}{
		{
			name: "Service object",
			obj: &corev1.Service{
				ObjectMeta: metav1.ObjectMeta{
					Namespace: "default",
					Name:      "my-service",
				},
			},
			expected: "default/my-service",
		},
		{
			name: "Pod object",
			obj: &corev1.Pod{
				ObjectMeta: metav1.ObjectMeta{
					Namespace: "kube-system",
					Name:      "my-pod",
				},
			},
			expected: "kube-system/my-pod",
		},
		{
			name: "Ingress object",
			obj: &networkingv1.Ingress{
				ObjectMeta: metav1.ObjectMeta{
					Namespace: "app",
					Name:      "my-ingress",
				},
			},
			expected: "app/my-ingress",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.ObjKey(tt.obj)
			if got != tt.expected {
				t.Errorf("ObjKey() = %v, want %v", got, tt.expected)
			}
		})
	}
}
