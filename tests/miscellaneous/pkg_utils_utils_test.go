/*
 * Copyright Â© 2025 Broadcom Inc. and/or its subsidiaries. All Rights Reserved.
 * All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// @AI-Generated
// [Generated by Cursor claude-4-sonnet]

package miscellaneous

import (
	"encoding/json"
	"errors"
	"os"
	"strings"
	"testing"

	corev1 "k8s.io/api/core/v1"
	discovery "k8s.io/api/discovery/v1"
	networkingv1 "k8s.io/api/networking/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/utils"
)

func TestIsV4(t *testing.T) {
	tests := []struct {
		name string
		addr string
		want bool
	}{
		{
			name: "Valid IPv4 address",
			addr: "192.168.1.1",
			want: true,
		},
		{
			name: "Valid IPv4 localhost",
			addr: "127.0.0.1",
			want: true,
		},
		{
			name: "Valid IPv4 zero address",
			addr: "0.0.0.0",
			want: true,
		},
		{
			name: "IPv6 address",
			addr: "2001:0db8:85a3:0000:0000:8a2e:0370:7334",
			want: false,
		},
		{
			name: "IPv6 localhost",
			addr: "::1",
			want: false,
		},
		{
			name: "Invalid IP address",
			addr: "invalid",
			want: false,
		},
		{
			name: "Empty string",
			addr: "",
			want: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := utils.IsV4(tt.addr); got != tt.want {
				t.Errorf("IsV4() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestIsSvcHttp(t *testing.T) {
	tests := []struct {
		name     string
		svcName  string
		port     int32
		expected bool
	}{
		{
			name:     "Service name is http",
			svcName:  "http",
			port:     9000,
			expected: true,
		},
		{
			name:     "Service name starts with http-",
			svcName:  "http-web",
			port:     9000,
			expected: true,
		},
		{
			name:     "Port 80",
			svcName:  "web",
			port:     80,
			expected: true,
		},
		{
			name:     "Port 443",
			svcName:  "web",
			port:     443,
			expected: true,
		},
		{
			name:     "Port 8080",
			svcName:  "web",
			port:     8080,
			expected: true,
		},
		{
			name:     "Port 8443",
			svcName:  "web",
			port:     8443,
			expected: true,
		},
		{
			name:     "Non-HTTP service and port",
			svcName:  "grpc",
			port:     9090,
			expected: false,
		},
		{
			name:     "Empty service name with non-standard port",
			svcName:  "",
			port:     9000,
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.IsSvcHttp(tt.svcName, tt.port)
			if got != tt.expected {
				t.Errorf("IsSvcHttp(%s, %d) = %v, want %v", tt.svcName, tt.port, got, tt.expected)
			}
		})
	}
}

func TestAviUrlToObjType(t *testing.T) {
	tests := []struct {
		name    string
		aviurl  string
		want    string
		wantErr bool
	}{
		{
			name:    "Valid virtualservice URL",
			aviurl:  "https://controller.local/api/virtualservice/virtualservice-123",
			want:    "virtualservice",
			wantErr: false,
		},
		{
			name:    "Valid pool URL",
			aviurl:  "https://controller.local/api/pool/pool-456",
			want:    "pool",
			wantErr: false,
		},
		{
			name:    "Valid poolgroup URL",
			aviurl:  "https://controller.local/api/poolgroup/pg-789",
			want:    "poolgroup",
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := utils.AviUrlToObjType(tt.aviurl)
			if (err != nil) != tt.wantErr {
				t.Errorf("AviUrlToObjType() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if got != tt.want {
				t.Errorf("AviUrlToObjType() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestHash(t *testing.T) {
	tests := []struct {
		name  string
		input string
	}{
		{
			name:  "Simple string",
			input: "test",
		},
		{
			name:  "Empty string",
			input: "",
		},
		{
			name:  "Long string",
			input: "this is a very long string for testing hash function",
		},
		{
			name:  "String with special characters",
			input: "test@#$%^&*()",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			hash1 := utils.Hash(tt.input)
			hash2 := utils.Hash(tt.input)

			// Hash should be deterministic
			if hash1 != hash2 {
				t.Errorf("Hash() not deterministic: got %v and %v for same input", hash1, hash2)
			}
		})
	}

	// Test that different strings produce different hashes
	hash1 := utils.Hash("string1")
	hash2 := utils.Hash("string2")
	if hash1 == hash2 {
		t.Errorf("Hash() produced same hash for different strings")
	}
}

func TestBkt(t *testing.T) {
	tests := []struct {
		name        string
		key         string
		numWorkers  uint32
		expectRange bool
	}{
		{
			name:        "4 workers",
			key:         "test-key",
			numWorkers:  4,
			expectRange: true,
		},
		{
			name:        "8 workers",
			key:         "another-key",
			numWorkers:  8,
			expectRange: true,
		},
		{
			name:        "16 workers",
			key:         "namespace/name",
			numWorkers:  16,
			expectRange: true,
		},
		{
			name:        "1 worker",
			key:         "single",
			numWorkers:  1,
			expectRange: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.Bkt(tt.key, tt.numWorkers)

			// Result should be less than numWorkers
			if got >= tt.numWorkers {
				t.Errorf("Bkt() = %v, should be less than %v", got, tt.numWorkers)
			}

			// Same key should always return same bucket
			got2 := utils.Bkt(tt.key, tt.numWorkers)
			if got != got2 {
				t.Errorf("Bkt() not deterministic: got %v and %v for same input", got, got2)
			}
		})
	}
}

func TestDeepCopy(t *testing.T) {
	type TestStruct struct {
		Name  string
		Value int
		Tags  []string
	}

	tests := []struct {
		name string
		src  TestStruct
	}{
		{
			name: "Simple struct",
			src: TestStruct{
				Name:  "test",
				Value: 42,
				Tags:  []string{"tag1", "tag2"},
			},
		},
		{
			name: "Empty struct",
			src:  TestStruct{},
		},
		{
			name: "Struct with nil slice",
			src: TestStruct{
				Name:  "test",
				Value: 10,
				Tags:  nil,
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var dst TestStruct
			utils.DeepCopy(tt.src, &dst)

			// Check that values are copied
			if dst.Name != tt.src.Name {
				t.Errorf("DeepCopy() Name = %v, want %v", dst.Name, tt.src.Name)
			}
			if dst.Value != tt.src.Value {
				t.Errorf("DeepCopy() Value = %v, want %v", dst.Value, tt.src.Value)
			}

			// Verify it's a deep copy by modifying source
			tt.src.Name = "modified"
			if dst.Name == "modified" {
				t.Errorf("DeepCopy() did not create independent copy")
			}
		})
	}
}

func TestStringify(t *testing.T) {
	tests := []struct {
		name     string
		input    interface{}
		expected string
	}{
		{
			name:     "Simple map",
			input:    map[string]string{"key": "value"},
			expected: `{"key":"value"}`,
		},
		{
			name:     "Empty map",
			input:    map[string]string{},
			expected: `{}`,
		},
		{
			name:     "String",
			input:    "test",
			expected: `"test"`,
		},
		{
			name:     "Integer",
			input:    42,
			expected: `42`,
		},
		{
			name:     "Slice",
			input:    []string{"a", "b", "c"},
			expected: `["a","b","c"]`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.Stringify(tt.input)
			if got != tt.expected {
				t.Errorf("Stringify() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestExtractNamespaceObjectName(t *testing.T) {
	tests := []struct {
		name          string
		key           string
		wantNamespace string
		wantName      string
	}{
		{
			name:          "Two segments",
			key:           "default/my-service",
			wantNamespace: "default",
			wantName:      "my-service",
		},
		{
			name:          "Three segments",
			key:           "default/subpath/my-service",
			wantNamespace: "default",
			wantName:      "subpath/my-service",
		},
		{
			name:          "Single segment",
			key:           "single",
			wantNamespace: "",
			wantName:      "",
		},
		{
			name:          "Empty string",
			key:           "",
			wantNamespace: "",
			wantName:      "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gotNs, gotName := utils.ExtractNamespaceObjectName(tt.key)
			if gotNs != tt.wantNamespace {
				t.Errorf("ExtractNamespaceObjectName() namespace = %v, want %v", gotNs, tt.wantNamespace)
			}
			if gotName != tt.wantName {
				t.Errorf("ExtractNamespaceObjectName() name = %v, want %v", gotName, tt.wantName)
			}
		})
	}
}

func TestHasElem(t *testing.T) {
	tests := []struct {
		name  string
		slice interface{}
		elem  interface{}
		want  bool
	}{
		{
			name:  "Element exists in string slice",
			slice: []string{"a", "b", "c"},
			elem:  "b",
			want:  true,
		},
		{
			name:  "Element does not exist in string slice",
			slice: []string{"a", "b", "c"},
			elem:  "d",
			want:  false,
		},
		{
			name:  "Element exists in int slice",
			slice: []int{1, 2, 3},
			elem:  2,
			want:  true,
		},
		{
			name:  "Element does not exist in int slice",
			slice: []int{1, 2, 3},
			elem:  4,
			want:  false,
		},
		{
			name:  "Empty slice",
			slice: []string{},
			elem:  "a",
			want:  false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.HasElem(tt.slice, tt.elem)
			if got != tt.want {
				t.Errorf("HasElem() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRemove(t *testing.T) {
	tests := []struct {
		name     string
		arr      []string
		item     string
		expected []string
	}{
		{
			name:     "Remove existing item",
			arr:      []string{"a", "b", "c"},
			item:     "b",
			expected: []string{"a", "c"},
		},
		{
			name:     "Remove first item",
			arr:      []string{"a", "b", "c"},
			item:     "a",
			expected: []string{"b", "c"},
		},
		{
			name:     "Remove last item",
			arr:      []string{"a", "b", "c"},
			item:     "c",
			expected: []string{"a", "b"},
		},
		{
			name:     "Remove non-existing item",
			arr:      []string{"a", "b", "c"},
			item:     "d",
			expected: []string{"a", "b", "c"},
		},
		{
			name:     "Remove from empty slice",
			arr:      []string{},
			item:     "a",
			expected: []string{},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Make a copy to avoid modifying test data
			arrCopy := make([]string, len(tt.arr))
			copy(arrCopy, tt.arr)

			got := utils.Remove(arrCopy, tt.item)

			if len(got) != len(tt.expected) {
				t.Errorf("Remove() length = %v, want %v", len(got), len(tt.expected))
				return
			}

			for i := range got {
				if got[i] != tt.expected[i] {
					t.Errorf("Remove() = %v, want %v", got, tt.expected)
					break
				}
			}
		})
	}
}

func TestFindAndRemove(t *testing.T) {
	tests := []struct {
		name        string
		arr         []string
		item        string
		expectFound bool
		expectedArr []string
	}{
		{
			name:        "Find and remove existing item",
			arr:         []string{"a", "b", "c"},
			item:        "b",
			expectFound: true,
			expectedArr: []string{"a", "c"},
		},
		{
			name:        "Item not found",
			arr:         []string{"a", "b", "c"},
			item:        "d",
			expectFound: false,
			expectedArr: []string{"a", "b", "c"},
		},
		{
			name:        "Empty slice",
			arr:         []string{},
			item:        "a",
			expectFound: false,
			expectedArr: []string{},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Make a copy to avoid modifying test data
			arrCopy := make([]string, len(tt.arr))
			copy(arrCopy, tt.arr)

			found, got := utils.FindAndRemove(arrCopy, tt.item)

			if found != tt.expectFound {
				t.Errorf("FindAndRemove() found = %v, want %v", found, tt.expectFound)
			}

			if len(got) != len(tt.expectedArr) {
				t.Errorf("FindAndRemove() length = %v, want %v", len(got), len(tt.expectedArr))
				return
			}

			for i := range got {
				if got[i] != tt.expectedArr[i] {
					t.Errorf("FindAndRemove() = %v, want %v", got, tt.expectedArr)
					break
				}
			}
		})
	}
}

func TestRandomSeq(t *testing.T) {
	tests := []struct {
		name   string
		length int
	}{
		{
			name:   "Length 5",
			length: 5,
		},
		{
			name:   "Length 10",
			length: 10,
		},
		{
			name:   "Length 0",
			length: 0,
		},
		{
			name:   "Length 1",
			length: 1,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.RandomSeq(tt.length)

			if len(got) != tt.length {
				t.Errorf("RandomSeq(%d) length = %v, want %v", tt.length, len(got), tt.length)
			}

			// Verify all characters are from the allowed set
			allowedChars := "abcdefghijklmnopqrstuvwxyz1234567890"
			for _, char := range got {
				if !containsRune(allowedChars, char) {
					t.Errorf("RandomSeq() contains invalid character: %c", char)
				}
			}
		})
	}

	// Test that multiple calls produce different results (probabilistically)
	seq1 := utils.RandomSeq(10)
	seq2 := utils.RandomSeq(10)
	if seq1 == seq2 {
		// This could theoretically fail, but probability is very low
		t.Log("Warning: Two random sequences are identical (this is possible but unlikely)")
	}
}

func containsRune(s string, r rune) bool {
	for _, c := range s {
		if c == r {
			return true
		}
	}
	return false
}

func TestDeepCopyJSON(t *testing.T) {
	// Test that DeepCopy works with complex nested structures
	type Nested struct {
		Field1 string
		Field2 int
	}

	type Complex struct {
		Name   string
		Nested Nested
		List   []string
	}

	src := Complex{
		Name: "test",
		Nested: Nested{
			Field1: "nested",
			Field2: 42,
		},
		List: []string{"a", "b"},
	}

	var dst Complex
	utils.DeepCopy(src, &dst)

	// Verify deep copy
	if dst.Name != src.Name {
		t.Errorf("DeepCopy() Name not copied correctly")
	}
	if dst.Nested.Field1 != src.Nested.Field1 {
		t.Errorf("DeepCopy() Nested.Field1 not copied correctly")
	}
	if dst.Nested.Field2 != src.Nested.Field2 {
		t.Errorf("DeepCopy() Nested.Field2 not copied correctly")
	}

	// Modify source and verify destination is independent
	src.Nested.Field1 = "modified"
	if dst.Nested.Field1 == "modified" {
		t.Errorf("DeepCopy() did not create independent nested copy")
	}
}

func TestStringifyJSON(t *testing.T) {
	// Test that Stringify produces valid JSON
	input := map[string]interface{}{
		"string": "value",
		"number": 42,
		"bool":   true,
		"null":   nil,
	}

	result := utils.Stringify(input)

	// Verify it's valid JSON by unmarshaling
	var decoded map[string]interface{}
	err := json.Unmarshal([]byte(result), &decoded)
	if err != nil {
		t.Errorf("Stringify() produced invalid JSON: %v", err)
	}

	// Verify values
	if decoded["string"] != "value" {
		t.Errorf("Stringify() string value incorrect")
	}
	if decoded["number"].(float64) != 42 {
		t.Errorf("Stringify() number value incorrect")
	}
	if decoded["bool"] != true {
		t.Errorf("Stringify() bool value incorrect")
	}
}

func TestContainsDuplicate(t *testing.T) {
	tests := []struct {
		name     string
		arr      interface{}
		expected bool
	}{
		{
			name:     "String slice with duplicates",
			arr:      []string{"a", "b", "c", "b"},
			expected: true,
		},
		{
			name:     "String slice without duplicates",
			arr:      []string{"a", "b", "c"},
			expected: false,
		},
		{
			name:     "Int slice with duplicates",
			arr:      []int{1, 2, 3, 2},
			expected: true,
		},
		{
			name:     "Int slice without duplicates",
			arr:      []int{1, 2, 3},
			expected: false,
		},
		{
			name:     "Empty slice",
			arr:      []string{},
			expected: false,
		},
		{
			name:     "Single element",
			arr:      []string{"a"},
			expected: false,
		},
		{
			name:     "All duplicates",
			arr:      []int{5, 5, 5},
			expected: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.ContainsDuplicate(tt.arr)
			if got != tt.expected {
				t.Errorf("ContainsDuplicate() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestNewVersion(t *testing.T) {
	tests := []struct {
		name       string
		version    string
		wantErr    bool
		wantLength int
	}{
		{
			name:       "Simple version",
			version:    "1.2.3",
			wantErr:    false,
			wantLength: 3,
		},
		{
			name:       "Two part version",
			version:    "1.0",
			wantErr:    false,
			wantLength: 2,
		},
		{
			name:       "Four part version",
			version:    "1.2.3.4",
			wantErr:    false,
			wantLength: 4,
		},
		{
			name:       "Single digit",
			version:    "1",
			wantErr:    false,
			wantLength: 1,
		},
		{
			name:    "Invalid version with letter",
			version: "1.2.a",
			wantErr: true,
		},
		{
			name:    "Empty string",
			version: "",
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := utils.NewVersion(tt.version)
			if (err != nil) != tt.wantErr {
				t.Errorf("NewVersion() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !tt.wantErr && got == nil {
				t.Errorf("NewVersion() returned nil without error")
			}
		})
	}
}

func TestVersionCompare(t *testing.T) {
	tests := []struct {
		name     string
		version1 string
		version2 string
		expected int
	}{
		{
			name:     "Equal versions",
			version1: "1.2.3",
			version2: "1.2.3",
			expected: 0,
		},
		{
			name:     "First version greater",
			version1: "1.2.4",
			version2: "1.2.3",
			expected: 1,
		},
		{
			name:     "First version less",
			version1: "1.2.2",
			version2: "1.2.3",
			expected: -1,
		},
		{
			name:     "Different lengths - first longer and greater",
			version1: "1.2.3.1",
			version2: "1.2.3",
			expected: 1,
		},
		{
			name:     "Different lengths - first shorter and less",
			version1: "1.2",
			version2: "1.2.3",
			expected: -1,
		},
		{
			name:     "Major version difference",
			version1: "2.0.0",
			version2: "1.9.9",
			expected: 1,
		},
		{
			name:     "Minor version difference",
			version1: "1.3.0",
			version2: "1.2.9",
			expected: 1,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			v1, err := utils.NewVersion(tt.version1)
			if err != nil {
				t.Fatalf("Failed to create version1: %v", err)
			}
			v2, err := utils.NewVersion(tt.version2)
			if err != nil {
				t.Fatalf("Failed to create version2: %v", err)
			}

			got := v1.Compare(v2)
			if got != tt.expected {
				t.Errorf("Version.Compare() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestString(t *testing.T) {
	tests := []struct {
		name     string
		input    *string
		expected string
	}{
		{
			name:     "Non-nil string pointer",
			input:    StringPtr("test"),
			expected: "test",
		},
		{
			name:     "Empty string pointer",
			input:    StringPtr(""),
			expected: "",
		},
		{
			name:     "Nil string pointer",
			input:    nil,
			expected: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.String(tt.input)
			if got != tt.expected {
				t.Errorf("String() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestCheckSubdomainOverlapping(t *testing.T) {
	tests := []struct {
		name      string
		hostName1 string
		hostName2 string
		expected  bool
	}{
		{
			name:      "Exact match",
			hostName1: "example.com",
			hostName2: "example.com",
			expected:  true,
		},
		{
			name:      "Wildcard in first hostname",
			hostName1: "*.example.com",
			hostName2: "api.example.com",
			expected:  true,
		},
		{
			name:      "Wildcard in second hostname",
			hostName1: "api.example.com",
			hostName2: "*.example.com",
			expected:  true,
		},
		{
			name:      "Both wildcards",
			hostName1: "*.example.com",
			hostName2: "*.example.com",
			expected:  true,
		},
		{
			name:      "Different subdomains",
			hostName1: "api.example.com",
			hostName2: "web.example.com",
			expected:  false,
		},
		{
			name:      "Different domains",
			hostName1: "example.com",
			hostName2: "example.org",
			expected:  false,
		},
		{
			name:      "Subdomain vs root domain",
			hostName1: "api.example.com",
			hostName2: "example.com",
			expected:  true,
		},
		{
			name:      "Multi-level subdomains matching",
			hostName1: "api.v1.example.com",
			hostName2: "web.v1.example.com",
			expected:  false,
		},
		{
			name:      "Multi-level with wildcard",
			hostName1: "*.v1.example.com",
			hostName2: "api.v1.example.com",
			expected:  true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.CheckSubdomainOverlapping(tt.hostName1, tt.hostName2)
			if got != tt.expected {
				t.Errorf("CheckSubdomainOverlapping(%s, %s) = %v, want %v",
					tt.hostName1, tt.hostName2, got, tt.expected)
			}
		})
	}
}

func TestGetUriEncoded(t *testing.T) {
	tests := []struct {
		name     string
		uri      string
		expected string
	}{
		{
			name:     "URI without query parameters",
			uri:      "https://example.com/path",
			expected: "https://example.com/path",
		},
		{
			name:     "URI with simple query parameters",
			uri:      "https://example.com/path?key=value",
			expected: "https://example.com/path?key=value",
		},
		{
			name:     "URI with special characters in query",
			uri:      "https://example.com/path?key=value with spaces",
			expected: "https://example.com/path?key=value+with+spaces",
		},
		{
			name:     "URI with multiple query parameters",
			uri:      "https://example.com/path?key1=value1&key2=value2",
			expected: "https://example.com/path?key1=value1&key2=value2",
		},
		{
			name:     "URI with empty query value",
			uri:      "https://example.com/path?key=",
			expected: "https://example.com/path?key=",
		},
		{
			name:     "Simple path without scheme",
			uri:      "/path",
			expected: "/path",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.GetUriEncoded(tt.uri)
			if got != tt.expected {
				t.Errorf("GetUriEncoded() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestNewSet(t *testing.T) {
	t.Run("Create empty set", func(t *testing.T) {
		s := utils.NewSet[string]()
		if s.Size() != 0 {
			t.Errorf("NewSet() size = %v, want 0", s.Size())
		}
	})

	t.Run("Create set with initial values", func(t *testing.T) {
		s := utils.NewSet("a", "b", "c")
		if s.Size() != 3 {
			t.Errorf("NewSet() size = %v, want 3", s.Size())
		}
		if !s.Has("a") || !s.Has("b") || !s.Has("c") {
			t.Errorf("NewSet() missing expected elements")
		}
	})

	t.Run("Create set with duplicate values", func(t *testing.T) {
		s := utils.NewSet("a", "b", "a")
		if s.Size() != 2 {
			t.Errorf("NewSet() with duplicates size = %v, want 2", s.Size())
		}
	})
}

func TestSetAdd(t *testing.T) {
	t.Run("Add single element", func(t *testing.T) {
		s := utils.NewSet[string]()
		s.Add("a")
		if !s.Has("a") {
			t.Errorf("Set.Add() element not added")
		}
		if s.Size() != 1 {
			t.Errorf("Set.Add() size = %v, want 1", s.Size())
		}
	})

	t.Run("Add multiple elements", func(t *testing.T) {
		s := utils.NewSet[string]()
		s.Add("a", "b", "c")
		if s.Size() != 3 {
			t.Errorf("Set.Add() multiple elements size = %v, want 3", s.Size())
		}
	})

	t.Run("Add duplicate element", func(t *testing.T) {
		s := utils.NewSet("a")
		s.Add("a")
		if s.Size() != 1 {
			t.Errorf("Set.Add() duplicate size = %v, want 1", s.Size())
		}
	})
}

func TestSetRemove(t *testing.T) {
	t.Run("Remove existing element", func(t *testing.T) {
		s := utils.NewSet("a", "b", "c")
		s.Remove("b")
		if s.Has("b") {
			t.Errorf("Set.Remove() element still exists")
		}
		if s.Size() != 2 {
			t.Errorf("Set.Remove() size = %v, want 2", s.Size())
		}
	})

	t.Run("Remove non-existing element", func(t *testing.T) {
		s := utils.NewSet("a", "b")
		s.Remove("c")
		if s.Size() != 2 {
			t.Errorf("Set.Remove() non-existing changed size")
		}
	})

	t.Run("Remove multiple elements", func(t *testing.T) {
		s := utils.NewSet("a", "b", "c", "d")
		s.Remove("a", "c")
		if s.Size() != 2 {
			t.Errorf("Set.Remove() multiple size = %v, want 2", s.Size())
		}
		if s.Has("a") || s.Has("c") {
			t.Errorf("Set.Remove() elements still exist")
		}
	})
}

func TestSetHas(t *testing.T) {
	s := utils.NewSet("a", "b", "c")

	tests := []struct {
		name     string
		key      string
		expected bool
	}{
		{
			name:     "Existing element",
			key:      "a",
			expected: true,
		},
		{
			name:     "Non-existing element",
			key:      "d",
			expected: false,
		},
		{
			name:     "Empty string in set",
			key:      "",
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := s.Has(tt.key)
			if got != tt.expected {
				t.Errorf("Set.Has(%s) = %v, want %v", tt.key, got, tt.expected)
			}
		})
	}
}

func TestSetSize(t *testing.T) {
	tests := []struct {
		name     string
		elements []string
		expected int
	}{
		{
			name:     "Empty set",
			elements: []string{},
			expected: 0,
		},
		{
			name:     "Single element",
			elements: []string{"a"},
			expected: 1,
		},
		{
			name:     "Multiple elements",
			elements: []string{"a", "b", "c"},
			expected: 3,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s := utils.NewSet(tt.elements...)
			got := s.Size()
			if got != tt.expected {
				t.Errorf("Set.Size() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestSetKeys(t *testing.T) {
	t.Run("Get keys from set", func(t *testing.T) {
		s := utils.NewSet("a", "b", "c")
		keys := s.Keys()

		if len(keys) != 3 {
			t.Errorf("Set.Keys() length = %v, want 3", len(keys))
		}

		// Check all expected keys are present
		keyMap := make(map[string]bool)
		for _, k := range keys {
			keyMap[k] = true
		}

		if !keyMap["a"] || !keyMap["b"] || !keyMap["c"] {
			t.Errorf("Set.Keys() missing expected keys")
		}
	})

	t.Run("Get keys from empty set", func(t *testing.T) {
		s := utils.NewSet[string]()
		keys := s.Keys()

		if len(keys) != 0 {
			t.Errorf("Set.Keys() empty set length = %v, want 0", len(keys))
		}
	})
}

func TestUtilsRemoveNamespaceName(t *testing.T) {
	tests := []struct {
		name     string
		slice    []utils.NamespaceName
		remove   utils.NamespaceName
		expected []utils.NamespaceName
	}{
		{
			name: "Remove existing element",
			slice: []utils.NamespaceName{
				{Namespace: "ns1", Name: "name1"},
				{Namespace: "ns2", Name: "name2"},
				{Namespace: "ns3", Name: "name3"},
			},
			remove: utils.NamespaceName{Namespace: "ns2", Name: "name2"},
			expected: []utils.NamespaceName{
				{Namespace: "ns1", Name: "name1"},
				{Namespace: "ns3", Name: "name3"},
			},
		},
		{
			name: "Remove non-existing element",
			slice: []utils.NamespaceName{
				{Namespace: "ns1", Name: "name1"},
				{Namespace: "ns2", Name: "name2"},
			},
			remove: utils.NamespaceName{Namespace: "ns3", Name: "name3"},
			expected: []utils.NamespaceName{
				{Namespace: "ns1", Name: "name1"},
				{Namespace: "ns2", Name: "name2"},
			},
		},
		{
			name:     "Remove from empty slice",
			slice:    []utils.NamespaceName{},
			remove:   utils.NamespaceName{Namespace: "ns1", Name: "name1"},
			expected: []utils.NamespaceName{},
		},
		{
			name: "Remove first element",
			slice: []utils.NamespaceName{
				{Namespace: "ns1", Name: "name1"},
				{Namespace: "ns2", Name: "name2"},
			},
			remove: utils.NamespaceName{Namespace: "ns1", Name: "name1"},
			expected: []utils.NamespaceName{
				{Namespace: "ns2", Name: "name2"},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.RemoveNamespaceName(tt.slice, tt.remove)

			if len(got) != len(tt.expected) {
				t.Errorf("RemoveNamespaceName() length = %v, want %v", len(got), len(tt.expected))
				return
			}

			for i := range got {
				if got[i] != tt.expected[i] {
					t.Errorf("RemoveNamespaceName() = %v, want %v", got, tt.expected)
					break
				}
			}
		})
	}
}

func TestHasElemWithName(t *testing.T) {
	type TestStruct struct {
		Name  string
		Value int
	}

	tests := []struct {
		name     string
		slice    interface{}
		elem     interface{}
		expected int
	}{
		{
			name: "Element exists",
			slice: []TestStruct{
				{Name: "first", Value: 1},
				{Name: "second", Value: 2},
				{Name: "third", Value: 3},
			},
			elem:     TestStruct{Name: "second", Value: 999},
			expected: 1,
		},
		{
			name: "Element does not exist",
			slice: []TestStruct{
				{Name: "first", Value: 1},
				{Name: "second", Value: 2},
			},
			elem:     TestStruct{Name: "third", Value: 3},
			expected: -1,
		},
		{
			name:     "Empty slice",
			slice:    []TestStruct{},
			elem:     TestStruct{Name: "first", Value: 1},
			expected: -1,
		},
		{
			name: "First element match",
			slice: []TestStruct{
				{Name: "first", Value: 1},
				{Name: "second", Value: 2},
			},
			elem:     TestStruct{Name: "first", Value: 999},
			expected: 0,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.HasElemWithName(tt.slice, tt.elem)
			if got != tt.expected {
				t.Errorf("HasElemWithName() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestCrudHashKey(t *testing.T) {
	tests := []struct {
		name     string
		objType  string
		obj      interface{}
		expected string
	}{
		{
			name:    "EndpointSlice",
			objType: "EndpointSlice",
			obj: &discovery.EndpointSlice{
				ObjectMeta: metav1.ObjectMeta{
					Namespace: "default",
					Name:      "my-endpoint-slice",
				},
			},
			expected: "default:my-endpoint-slice",
		},
		{
			name:    "Service",
			objType: "Service",
			obj: &corev1.Service{
				ObjectMeta: metav1.ObjectMeta{
					Namespace: "kube-system",
					Name:      "my-service",
				},
			},
			expected: "kube-system:my-service",
		},
		{
			name:    "Ingress",
			objType: "Ingress",
			obj: &networkingv1.Ingress{
				ObjectMeta: metav1.ObjectMeta{
					Namespace: "app-namespace",
					Name:      "my-ingress",
				},
			},
			expected: "app-namespace:my-ingress",
		},
		{
			name:     "Unknown type",
			objType:  "UnknownType",
			obj:      "some-object",
			expected: ":",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.CrudHashKey(tt.objType, tt.obj)
			if got != tt.expected {
				t.Errorf("CrudHashKey() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestObjKey(t *testing.T) {
	tests := []struct {
		name     string
		obj      interface{}
		expected string
	}{
		{
			name: "Service object",
			obj: &corev1.Service{
				ObjectMeta: metav1.ObjectMeta{
					Namespace: "default",
					Name:      "my-service",
				},
			},
			expected: "default/my-service",
		},
		{
			name: "Pod object",
			obj: &corev1.Pod{
				ObjectMeta: metav1.ObjectMeta{
					Namespace: "kube-system",
					Name:      "my-pod",
				},
			},
			expected: "kube-system/my-pod",
		},
		{
			name: "Ingress object",
			obj: &networkingv1.Ingress{
				ObjectMeta: metav1.ObjectMeta{
					Namespace: "app",
					Name:      "my-ingress",
				},
			},
			expected: "app/my-ingress",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.ObjKey(tt.obj)
			if got != tt.expected {
				t.Errorf("ObjKey() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestWebSyncError(t *testing.T) {
	tests := []struct {
		name              string
		err               error
		operation         string
		expectedErrString string
	}{
		{
			name:              "POST operation error",
			err:               errors.New("connection timeout"),
			operation:         "POST",
			expectedErrString: "Error during POST: connection timeout",
		},
		{
			name:              "PUT operation error",
			err:               errors.New("invalid request"),
			operation:         "PUT",
			expectedErrString: "Error during PUT: invalid request",
		},
		{
			name:              "DELETE operation error",
			err:               errors.New("resource not found"),
			operation:         "DELETE",
			expectedErrString: "Error during DELETE: resource not found",
		},
		{
			name:              "GET operation error",
			err:               errors.New("unauthorized"),
			operation:         "GET",
			expectedErrString: "Error during GET: unauthorized",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			webErr := &utils.WebSyncError{
				Err:       tt.err,
				Operation: tt.operation,
			}

			// Test Error() method
			if webErr.Error() != tt.expectedErrString {
				t.Errorf("WebSyncError.Error() = %v, want %v", webErr.Error(), tt.expectedErrString)
			}

			// Test GetWebAPIError() method
			if webErr.GetWebAPIError() != tt.err {
				t.Errorf("WebSyncError.GetWebAPIError() = %v, want %v", webErr.GetWebAPIError(), tt.err)
			}

			// Test Unwrap() method
			if webErr.Unwrap() != tt.err {
				t.Errorf("WebSyncError.Unwrap() = %v, want %v", webErr.Unwrap(), tt.err)
			}
		})
	}
}

func TestWebSyncErrorUnwrap(t *testing.T) {
	originalErr := errors.New("original error")
	webErr := &utils.WebSyncError{
		Err:       originalErr,
		Operation: "POST",
	}

	// Test that errors.Is works with Unwrap
	if !errors.Is(webErr, originalErr) {
		t.Error("errors.Is should work with WebSyncError.Unwrap()")
	}
}

func TestSkipSyncError(t *testing.T) {
	tests := []struct {
		name        string
		msg         string
		expectedMsg string
	}{
		{
			name:        "Simple message",
			msg:         "skipping sync",
			expectedMsg: "skipping sync",
		},
		{
			name:        "Detailed message",
			msg:         "skipping sync due to invalid configuration",
			expectedMsg: "skipping sync due to invalid configuration",
		},
		{
			name:        "Empty message",
			msg:         "",
			expectedMsg: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			skipErr := &utils.SkipSyncError{
				Msg: tt.msg,
			}

			if skipErr.Error() != tt.expectedMsg {
				t.Errorf("SkipSyncError.Error() = %v, want %v", skipErr.Error(), tt.expectedMsg)
			}
		})
	}
}

func TestSetCloudName(t *testing.T) {
	tests := []struct {
		name      string
		cloudName string
	}{
		{
			name:      "Set to AWS",
			cloudName: "AWS",
		},
		{
			name:      "Set to Azure",
			cloudName: "Azure",
		},
		{
			name:      "Set to GCP",
			cloudName: "GCP",
		},
		{
			name:      "Set to Default-Cloud",
			cloudName: "Default-Cloud",
		},
		{
			name:      "Set to empty string",
			cloudName: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			utils.SetCloudName(tt.cloudName)
			// Note: We can't directly test the value since CloudName is not exported
			// This test ensures the function doesn't panic
		})
	}
}

func TestSetCloudUUID(t *testing.T) {
	tests := []struct {
		name      string
		cloudUUID string
	}{
		{
			name:      "Set valid UUID",
			cloudUUID: "cloud-uuid-12345",
		},
		{
			name:      "Set another UUID",
			cloudUUID: "uuid-abcdef",
		},
		{
			name:      "Set empty UUID",
			cloudUUID: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			utils.SetCloudUUID(tt.cloudUUID)
			// Note: We can't directly test the value since CloudUUID is not exported
			// This test ensures the function doesn't panic
		})
	}
}

func TestCloudNameInitialization(t *testing.T) {
	// Test that CloudName is initialized from environment or defaults to "Default-Cloud"
	// This is tested indirectly through the init() function

	// Save original env var
	originalCloudName := os.Getenv("CLOUD_NAME")
	defer func() {
		if originalCloudName != "" {
			os.Setenv("CLOUD_NAME", originalCloudName)
		} else {
			os.Unsetenv("CLOUD_NAME")
		}
	}()

	// The init() function has already run, so we can't test it directly
	// But we can verify the functions work
	testCloudName := "TestCloud"
	utils.SetCloudName(testCloudName)

	// Verify function doesn't panic
	utils.SetCloudUUID("test-uuid")
}

func TestRestMethodConstants(t *testing.T) {
	// Test that RestMethod constants are defined correctly
	tests := []struct {
		name     string
		method   utils.RestMethod
		expected string
	}{
		{
			name:     "POST method",
			method:   utils.RestPost,
			expected: "POST",
		},
		{
			name:     "PUT method",
			method:   utils.RestPut,
			expected: "PUT",
		},
		{
			name:     "DELETE method",
			method:   utils.RestDelete,
			expected: "DELETE",
		},
		{
			name:     "PATCH method",
			method:   utils.RestPatch,
			expected: "PATCH",
		},
		{
			name:     "GET method",
			method:   utils.RestGet,
			expected: "GET",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if string(tt.method) != tt.expected {
				t.Errorf("RestMethod %s = %v, want %v", tt.name, tt.method, tt.expected)
			}
		})
	}
}

func TestEvTypeConstants(t *testing.T) {
	// Test that EvType constants are defined correctly
	tests := []struct {
		name     string
		evType   utils.EvType
		expected string
	}{
		{
			name:     "CREATE event",
			evType:   utils.CreateEv,
			expected: "CREATE",
		},
		{
			name:     "UPDATE event",
			evType:   utils.UpdateEv,
			expected: "UPDATE",
		},
		{
			name:     "DELETE event",
			evType:   utils.DeleteEv,
			expected: "DELETE",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if string(tt.evType) != tt.expected {
				t.Errorf("EvType %s = %v, want %v", tt.name, tt.evType, tt.expected)
			}
		})
	}
}

func TestPatchOpConstants(t *testing.T) {
	tests := []struct {
		name     string
		constant string
		expected string
	}{
		{
			name:     "PatchAddOp",
			constant: utils.PatchAddOp,
			expected: "add",
		},
		{
			name:     "PatchReplaceOp",
			constant: utils.PatchReplaceOp,
			expected: "replace",
		},
		{
			name:     "PatchDeleteOp",
			constant: utils.PatchDeleteOp,
			expected: "delete",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.constant != tt.expected {
				t.Errorf("%s = %v, want %v", tt.name, tt.constant, tt.expected)
			}
		})
	}
}

func TestHealthMonitorConstants(t *testing.T) {
	tests := []struct {
		name     string
		constant string
		expected string
	}{
		{
			name:     "AVI_DEFAULT_TCP_HM",
			constant: utils.AVI_DEFAULT_TCP_HM,
			expected: "System-TCP",
		},
		{
			name:     "AVI_DEFAULT_UDP_HM",
			constant: utils.AVI_DEFAULT_UDP_HM,
			expected: "System-UDP",
		},
		{
			name:     "AVI_DEFAULT_SCTP_HM",
			constant: utils.AVI_DEFAULT_SCTP_HM,
			expected: "System-SCTP",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.constant != tt.expected {
				t.Errorf("%s = %v, want %v", tt.name, tt.constant, tt.expected)
			}
		})
	}
}

func TestInformerConstants(t *testing.T) {
	tests := []struct {
		name     string
		constant string
		expected string
	}{
		{
			name:     "INFORMERS_INSTANTIATE_ONCE",
			constant: utils.INFORMERS_INSTANTIATE_ONCE,
			expected: "instantiateOnce",
		},
		{
			name:     "INFORMERS_OPENSHIFT_CLIENT",
			constant: utils.INFORMERS_OPENSHIFT_CLIENT,
			expected: "oshiftClient",
		},
		{
			name:     "INFORMERS_AKO_CLIENT",
			constant: utils.INFORMERS_AKO_CLIENT,
			expected: "akoClient",
		},
		{
			name:     "INFORMERS_NAMESPACE",
			constant: utils.INFORMERS_NAMESPACE,
			expected: "namespace",
		},
		{
			name:     "INFORMERS_ADVANCED_L4",
			constant: utils.INFORMERS_ADVANCED_L4,
			expected: "informersAdvL4",
		},
		{
			name:     "VMWARE_SYSTEM_AKO",
			constant: utils.VMWARE_SYSTEM_AKO,
			expected: "vmware-system-ako",
		},
		{
			name:     "AKO_DEFAULT_NS",
			constant: utils.AKO_DEFAULT_NS,
			expected: "avi-system",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.constant != tt.expected {
				t.Errorf("%s = %v, want %v", tt.name, tt.constant, tt.expected)
			}
		})
	}
}

func TestNumWorkersConstants(t *testing.T) {
	if utils.NumWorkersIngestion != 2 {
		t.Errorf("NumWorkersIngestion = %v, want 2", utils.NumWorkersIngestion)
	}

	if utils.NumWorkersGraph != 2 {
		t.Errorf("NumWorkersGraph = %v, want 2", utils.NumWorkersGraph)
	}
}

func TestWebSyncErrorAsError(t *testing.T) {
	// Test that WebSyncError implements error interface
	var _ error = &utils.WebSyncError{}

	webErr := &utils.WebSyncError{
		Err:       errors.New("test error"),
		Operation: "TEST",
	}

	// Should be usable as error - webErr is never nil since it's a concrete type
	if !strings.Contains(webErr.Error(), "TEST") {
		t.Error("WebSyncError.Error() should contain operation name")
	}
}

func TestSkipSyncErrorAsError(t *testing.T) {
	// Test that SkipSyncError implements error interface
	var _ error = &utils.SkipSyncError{}

	skipErr := &utils.SkipSyncError{
		Msg: "test skip message",
	}

	// Should be usable as error - skipErr is never nil since it's a concrete type
	if skipErr.Error() != "test skip message" {
		t.Errorf("SkipSyncError.Error() = %v, want 'test skip message'", skipErr.Error())
	}
}

func TestUtilsNamespaceNameStruct(t *testing.T) {
	// Test NamespaceName struct
	nn := utils.NamespaceName{
		Namespace: "default",
		Name:      "my-service",
	}

	if nn.Namespace != "default" {
		t.Errorf("NamespaceName.Namespace = %v, want default", nn.Namespace)
	}

	if nn.Name != "my-service" {
		t.Errorf("NamespaceName.Name = %v, want my-service", nn.Name)
	}
}

func TestRestOpStruct(t *testing.T) {
	// Test RestOp struct initialization
	restOp := utils.RestOp{
		Path:    "/api/virtualservice",
		Method:  utils.RestPost,
		Tenant:  "admin",
		PatchOp: utils.PatchAddOp,
		Model:   "VirtualService",
		Version: "v1",
		ObjName: "test-vs",
		Caller:  "test-caller",
		Message: "test message",
	}

	if restOp.Path != "/api/virtualservice" {
		t.Errorf("RestOp.Path = %v, want /api/virtualservice", restOp.Path)
	}

	if restOp.Method != utils.RestPost {
		t.Errorf("RestOp.Method = %v, want POST", restOp.Method)
	}

	if restOp.Tenant != "admin" {
		t.Errorf("RestOp.Tenant = %v, want admin", restOp.Tenant)
	}

	if restOp.Model != "VirtualService" {
		t.Errorf("RestOp.Model = %v, want VirtualService", restOp.Model)
	}
}
