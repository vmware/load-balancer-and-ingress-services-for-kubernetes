/*
 * Copyright Â© 2025 Broadcom Inc. and/or its subsidiaries. All Rights Reserved.
 * All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*   http://www.apache.org/licenses/LICENSE-2.0
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

// @AI-Generated
// This test file was generated by Claude AI assistant.

package miscellaneous

import (
	"encoding/json"
	"errors"
	"testing"

	avimodels "github.com/vmware/alb-sdk/go/models"

	avicache "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/cache"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/nodes"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/rest"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/utils"
)

// TestAviPersistenceProfileBuild tests the AviPersistenceProfileBuild function
func TestAviPersistenceProfileBuild(t *testing.T) {
	// Initialize cache
	cache := avicache.NewAviObjCache()

	// Create RestOperations
	restOps := rest.NewRestOperations(cache)

	tests := []struct {
		name                 string
		appPersProfileNode   *nodes.AviApplicationPersistenceProfileNode
		cacheObj             *avicache.AviPersistenceProfileCache
		expectedMethod       utils.RestMethod
		expectedPathContains string
		shouldBeNil          bool
	}{
		{
			name:               "Nil node",
			appPersProfileNode: nil,
			cacheObj:           nil,
			shouldBeNil:        true,
		},
		{
			name: "Valid HTTP Cookie persistence profile - POST (no cache)",
			appPersProfileNode: &nodes.AviApplicationPersistenceProfileNode{
				Name:            "test-persistence-profile",
				Tenant:          "admin",
				PersistenceType: "PERSISTENCE_TYPE_HTTP_COOKIE",
				HTTPCookiePersistenceProfile: &nodes.HTTPCookiePersistenceProfileNode{
					CookieName:         "test-cookie",
					Timeout:            Int32Ptr(300),
					IsPersistentCookie: BoolPtr(true),
				},
				AviMarkers: utils.AviObjectMarkers{},
			},
			cacheObj:             nil,
			expectedMethod:       utils.RestPost,
			expectedPathContains: "/api/applicationpersistenceprofile",
			shouldBeNil:          false,
		},
		{
			name: "Valid HTTP Cookie persistence profile - PUT (with cache)",
			appPersProfileNode: &nodes.AviApplicationPersistenceProfileNode{
				Name:            "test-persistence-profile",
				Tenant:          "admin",
				PersistenceType: "PERSISTENCE_TYPE_HTTP_COOKIE",
				HTTPCookiePersistenceProfile: &nodes.HTTPCookiePersistenceProfileNode{
					CookieName:         "test-cookie",
					Timeout:            Int32Ptr(300),
					IsPersistentCookie: BoolPtr(false),
				},
				AviMarkers: utils.AviObjectMarkers{},
			},
			cacheObj: &avicache.AviPersistenceProfileCache{
				Name:   "test-persistence-profile",
				Tenant: "admin",
				Uuid:   "test-uuid-123",
			},
			expectedMethod:       utils.RestPut,
			expectedPathContains: "/api/applicationpersistenceprofile/test-uuid-123",
			shouldBeNil:          false,
		},
		{
			name: "Unknown persistence type",
			appPersProfileNode: &nodes.AviApplicationPersistenceProfileNode{
				Name:            "test-persistence-profile",
				Tenant:          "admin",
				PersistenceType: "UNKNOWN_TYPE",
				AviMarkers:      utils.AviObjectMarkers{},
			},
			cacheObj:    nil,
			shouldBeNil: true,
		},
		{
			name: "Long name - should be skipped",
			appPersProfileNode: &nodes.AviApplicationPersistenceProfileNode{
				Name:            "this-is-a-very-long-name-that-exceeds-the-maximum-allowed-length-for-avi-objects-and-should-be-rejected-by-the-validation-logic-in-the-build-function-to-prevent-errors-when-creating-objects-in-the-avi-controller-this-string-needs-to-be-longer-than-255-characters-to-trigger-the-validation-error-so-adding-more-text-here",
				Tenant:          "admin",
				PersistenceType: "PERSISTENCE_TYPE_HTTP_COOKIE",
				HTTPCookiePersistenceProfile: &nodes.HTTPCookiePersistenceProfileNode{
					CookieName:         "test-cookie",
					Timeout:            Int32Ptr(300),
					IsPersistentCookie: BoolPtr(true),
				},
				AviMarkers: utils.AviObjectMarkers{},
			},
			cacheObj:    nil,
			shouldBeNil: true,
		},
		{
			name: "PUT with existing cache entry (not in cacheObj parameter)",
			appPersProfileNode: &nodes.AviApplicationPersistenceProfileNode{
				Name:            "existing-profile",
				Tenant:          "admin",
				PersistenceType: "PERSISTENCE_TYPE_HTTP_COOKIE",
				HTTPCookiePersistenceProfile: &nodes.HTTPCookiePersistenceProfileNode{
					CookieName:         "existing-cookie",
					Timeout:            Int32Ptr(600),
					IsPersistentCookie: BoolPtr(true),
				},
				AviMarkers: utils.AviObjectMarkers{},
			},
			cacheObj:             nil,
			expectedMethod:       utils.RestPut,
			expectedPathContains: "/api/applicationpersistenceprofile/existing-uuid-456",
			shouldBeNil:          false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup cache for the last test case
			if tt.name == "PUT with existing cache entry (not in cacheObj parameter)" {
				existingKey := avicache.NamespaceName{Namespace: "admin", Name: "existing-profile"}
				existingCache := &avicache.AviPersistenceProfileCache{
					Name:   "existing-profile",
					Tenant: "admin",
					Uuid:   "existing-uuid-456",
				}
				cache.AppPersProfileCache.AviCacheAdd(existingKey, existingCache)
				defer cache.AppPersProfileCache.AviCacheDelete(existingKey)
			}

			restOp := restOps.AviPersistenceProfileBuild(tt.appPersProfileNode, tt.cacheObj)

			if tt.shouldBeNil {
				if restOp != nil {
					t.Errorf("Expected nil RestOp, but got: %+v", restOp)
				}
				return
			}

			if restOp == nil {
				t.Fatalf("Expected non-nil RestOp, but got nil")
			}

			if restOp.Method != tt.expectedMethod {
				t.Errorf("Expected method %s, got %s", tt.expectedMethod, restOp.Method)
			}

			if tt.expectedPathContains != "" && restOp.Path != tt.expectedPathContains {
				t.Errorf("Expected path to contain %s, got %s", tt.expectedPathContains, restOp.Path)
			}

			if restOp.Tenant != tt.appPersProfileNode.Tenant {
				t.Errorf("Expected tenant %s, got %s", tt.appPersProfileNode.Tenant, restOp.Tenant)
			}

			if restOp.Model != "ApplicationPersistenceProfile" {
				t.Errorf("Expected model ApplicationPersistenceProfile, got %s", restOp.Model)
			}

			// Verify the object structure
			var appPersProfile avimodels.ApplicationPersistenceProfile
			switch obj := restOp.Obj.(type) {
			case avimodels.ApplicationPersistenceProfile:
				appPersProfile = obj
			default:
				t.Fatalf("Expected ApplicationPersistenceProfile object, got %T", restOp.Obj)
			}

			if *appPersProfile.Name != tt.appPersProfileNode.Name {
				t.Errorf("Expected name %s, got %s", tt.appPersProfileNode.Name, *appPersProfile.Name)
			}

			if *appPersProfile.PersistenceType != tt.appPersProfileNode.PersistenceType {
				t.Errorf("Expected persistence type %s, got %s", tt.appPersProfileNode.PersistenceType, *appPersProfile.PersistenceType)
			}

			// Verify HTTP Cookie profile if present
			if tt.appPersProfileNode.HTTPCookiePersistenceProfile != nil {
				if appPersProfile.HTTPCookiePersistenceProfile == nil {
					t.Errorf("Expected HTTPCookiePersistenceProfile, got nil")
				} else {
					if *appPersProfile.HTTPCookiePersistenceProfile.CookieName != tt.appPersProfileNode.HTTPCookiePersistenceProfile.CookieName {
						t.Errorf("Expected cookie name %s, got %s",
							tt.appPersProfileNode.HTTPCookiePersistenceProfile.CookieName,
							*appPersProfile.HTTPCookiePersistenceProfile.CookieName)
					}
				}
			}
		})
	}
}

// TestAviPersistenceProfileDel tests the AviPersistenceProfileDel function
func TestAviPersistenceProfileDel(t *testing.T) {
	cache := avicache.NewAviObjCache()
	restOps := rest.NewRestOperations(cache)

	tests := []struct {
		name         string
		uuid         string
		tenant       string
		expectedPath string
	}{
		{
			name:         "Delete with valid UUID",
			uuid:         "test-uuid-123",
			tenant:       "admin",
			expectedPath: "/api/applicationpersistenceprofile/test-uuid-123",
		},
		{
			name:         "Delete with different tenant",
			uuid:         "test-uuid-456",
			tenant:       "tenant2",
			expectedPath: "/api/applicationpersistenceprofile/test-uuid-456",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			restOp := restOps.AviPersistenceProfileDel(tt.uuid, tt.tenant)

			if restOp == nil {
				t.Fatalf("Expected non-nil RestOp, but got nil")
			}

			if restOp.Path != tt.expectedPath {
				t.Errorf("Expected path %s, got %s", tt.expectedPath, restOp.Path)
			}

			if restOp.Method != "DELETE" {
				t.Errorf("Expected method DELETE, got %s", restOp.Method)
			}

			if restOp.Tenant != tt.tenant {
				t.Errorf("Expected tenant %s, got %s", tt.tenant, restOp.Tenant)
			}

			if restOp.Model != "ApplicationPersistenceProfile" {
				t.Errorf("Expected model ApplicationPersistenceProfile, got %s", restOp.Model)
			}
		})
	}
}

// TestAviPersistenceProfileCacheAdd tests the AviPersistenceProfileCacheAdd function
func TestAviPersistenceProfileCacheAdd(t *testing.T) {
	cache := avicache.NewAviObjCache()
	restOps := rest.NewRestOperations(cache)

	tests := []struct {
		name          string
		restOp        *utils.RestOp
		poolKey       avicache.NamespaceName
		key           string
		setupCache    func()
		expectedError bool
		validateCache func(t *testing.T)
		validatePool  func(t *testing.T)
	}{
		{
			name: "Add persistence profile with error in RestOp",
			restOp: &utils.RestOp{
				Err: errors.New("test error"),
			},
			poolKey:       avicache.NamespaceName{},
			key:           "test-key",
			expectedError: true,
		},
		{
			name: "Add persistence profile with nil response",
			restOp: &utils.RestOp{
				Err:      nil,
				Response: nil,
			},
			poolKey:       avicache.NamespaceName{},
			key:           "test-key",
			expectedError: true,
		},
		{
			name: "Add persistence profile successfully",
			restOp: &utils.RestOp{
				Err:    nil,
				Tenant: "admin",
				Obj: avimodels.ApplicationPersistenceProfile{
					Name:            StringPtr("test-profile"),
					PersistenceType: StringPtr("PERSISTENCE_TYPE_HTTP_COOKIE"),
					HTTPCookiePersistenceProfile: &avimodels.HTTPCookiePersistenceProfile{
						CookieName:         StringPtr("test-cookie"),
						Timeout:            Int32Ptr(300),
						IsPersistentCookie: BoolPtr(true),
					},
				},
				Response: map[string]interface{}{
					"name":           "test-profile",
					"uuid":           "test-uuid-789",
					"_last_modified": "2025-01-01T00:00:00Z",
				},
			},
			poolKey:       avicache.NamespaceName{},
			key:           "test-key",
			expectedError: false,
			validateCache: func(t *testing.T) {
				cacheKey := avicache.NamespaceName{Namespace: "admin", Name: "test-profile"}
				cacheObj, found := cache.AppPersProfileCache.AviCacheGet(cacheKey)
				if !found {
					t.Errorf("Expected cache entry for test-profile, but not found")
					return
				}
				persProfileCache, ok := cacheObj.(*avicache.AviPersistenceProfileCache)
				if !ok {
					t.Errorf("Expected AviPersistenceProfileCache, got %T", cacheObj)
					return
				}
				if persProfileCache.Name != "test-profile" {
					t.Errorf("Expected name test-profile, got %s", persProfileCache.Name)
				}
				if persProfileCache.Uuid != "test-uuid-789" {
					t.Errorf("Expected uuid test-uuid-789, got %s", persProfileCache.Uuid)
				}
				if persProfileCache.Type != "PERSISTENCE_TYPE_HTTP_COOKIE" {
					t.Errorf("Expected type PERSISTENCE_TYPE_HTTP_COOKIE, got %s", persProfileCache.Type)
				}
			},
		},
		{
			name: "Add persistence profile with pool association",
			restOp: &utils.RestOp{
				Err:    nil,
				Tenant: "admin",
				Obj: avimodels.ApplicationPersistenceProfile{
					Name:            StringPtr("pool-profile"),
					PersistenceType: StringPtr("PERSISTENCE_TYPE_HTTP_COOKIE"),
					HTTPCookiePersistenceProfile: &avimodels.HTTPCookiePersistenceProfile{
						CookieName:         StringPtr("pool-cookie"),
						Timeout:            Int32Ptr(600),
						IsPersistentCookie: BoolPtr(false),
					},
				},
				Response: map[string]interface{}{
					"name":           "pool-profile",
					"uuid":           "pool-uuid-999",
					"_last_modified": "2025-01-01T00:00:00Z",
				},
			},
			poolKey: avicache.NamespaceName{Namespace: "admin", Name: "test-pool"},
			key:     "test-key",
			setupCache: func() {
				// Add pool to cache
				poolKey := avicache.NamespaceName{Namespace: "admin", Name: "test-pool"}
				poolCache := cache.PoolCache.AviCacheAddPool(poolKey)
				poolCache.Name = "test-pool"
				poolCache.Tenant = "admin"
			},
			expectedError: false,
			validateCache: func(t *testing.T) {
				cacheKey := avicache.NamespaceName{Namespace: "admin", Name: "pool-profile"}
				cacheObj, found := cache.AppPersProfileCache.AviCacheGet(cacheKey)
				if !found {
					t.Errorf("Expected cache entry for pool-profile, but not found")
				}
				persProfileCache, ok := cacheObj.(*avicache.AviPersistenceProfileCache)
				if !ok {
					t.Errorf("Expected AviPersistenceProfileCache, got %T", cacheObj)
					return
				}
				if persProfileCache.Name != "pool-profile" {
					t.Errorf("Expected name pool-profile, got %s", persProfileCache.Name)
				}
			},
			validatePool: func(t *testing.T) {
				poolKey := avicache.NamespaceName{Namespace: "admin", Name: "test-pool"}
				poolCacheObj, found := cache.PoolCache.AviCacheGet(poolKey)
				if !found {
					t.Errorf("Expected pool cache entry, but not found")
					return
				}
				poolCache, ok := poolCacheObj.(*avicache.AviPoolCache)
				if !ok {
					t.Errorf("Expected AviPoolCache, got %T", poolCacheObj)
					return
				}
				expectedPersKey := avicache.NamespaceName{Namespace: "admin", Name: "pool-profile"}
				if poolCache.PersistenceProfile != expectedPersKey {
					t.Errorf("Expected persistence profile %+v, got %+v", expectedPersKey, poolCache.PersistenceProfile)
				}
			},
		},
		{
			name: "Add persistence profile with missing _last_modified",
			restOp: &utils.RestOp{
				Err:    nil,
				Tenant: "admin",
				Obj: avimodels.ApplicationPersistenceProfile{
					Name:            StringPtr("invalid-profile"),
					PersistenceType: StringPtr("PERSISTENCE_TYPE_HTTP_COOKIE"),
				},
				Response: map[string]interface{}{
					"name": "invalid-profile",
					"uuid": "invalid-uuid-111",
					// _last_modified is missing
				},
			},
			poolKey:       avicache.NamespaceName{},
			key:           "test-key",
			expectedError: false,
			validateCache: func(t *testing.T) {
				cacheKey := avicache.NamespaceName{Namespace: "admin", Name: "invalid-profile"}
				cacheObj, found := cache.AppPersProfileCache.AviCacheGet(cacheKey)
				if !found {
					t.Errorf("Expected cache entry for invalid-profile, but not found")
					return
				}
				persProfileCache, ok := cacheObj.(*avicache.AviPersistenceProfileCache)
				if !ok {
					t.Errorf("Expected AviPersistenceProfileCache, got %T", cacheObj)
					return
				}
				if !persProfileCache.InvalidData {
					t.Errorf("Expected InvalidData to be true, got false")
				}
			},
		},
		{
			name: "Add persistence profile with AviRestObjMacro",
			restOp: &utils.RestOp{
				Err:    nil,
				Tenant: "admin",
				Obj: utils.AviRestObjMacro{
					Data: avimodels.ApplicationPersistenceProfile{
						Name:            StringPtr("macro-profile"),
						PersistenceType: StringPtr("PERSISTENCE_TYPE_HTTP_COOKIE"),
					},
				},
				Response: map[string]interface{}{
					"name":           "macro-profile",
					"uuid":           "macro-uuid-222",
					"_last_modified": "2025-01-01T00:00:00Z",
				},
			},
			poolKey:       avicache.NamespaceName{},
			key:           "test-key",
			expectedError: false,
			validateCache: func(t *testing.T) {
				cacheKey := avicache.NamespaceName{Namespace: "admin", Name: "macro-profile"}
				cacheObj, found := cache.AppPersProfileCache.AviCacheGet(cacheKey)
				if !found {
					t.Errorf("Expected cache entry for macro-profile, but not found")
					return
				}
				persProfileCache, ok := cacheObj.(*avicache.AviPersistenceProfileCache)
				if !ok {
					t.Errorf("Expected AviPersistenceProfileCache, got %T", cacheObj)
					return
				}
				if persProfileCache.Name != "macro-profile" {
					t.Errorf("Expected name macro-profile, got %s", persProfileCache.Name)
				}
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup cache if needed
			if tt.setupCache != nil {
				tt.setupCache()
			}

			err := restOps.AviPersistenceProfileCacheAdd(tt.restOp, tt.poolKey, tt.key)

			if tt.expectedError && err == nil {
				t.Errorf("Expected error, but got nil")
			}

			if !tt.expectedError && err != nil {
				t.Errorf("Expected no error, but got: %v", err)
			}

			// Validate cache if needed
			if tt.validateCache != nil {
				tt.validateCache(t)
			}

			// Validate pool if needed
			if tt.validatePool != nil {
				tt.validatePool(t)
			}

			// Cleanup
			if tt.restOp.Response != nil {
				if respMap, ok := tt.restOp.Response.(map[string]interface{}); ok {
					if name, ok := respMap["name"].(string); ok {
						cacheKey := avicache.NamespaceName{Namespace: tt.restOp.Tenant, Name: name}
						cache.AppPersProfileCache.AviCacheDelete(cacheKey)
					}
				}
			}
			if tt.poolKey != (avicache.NamespaceName{}) {
				cache.PoolCache.AviCacheDelete(tt.poolKey)
			}
		})
	}
}

// TestAviPersistenceProfileCacheDel tests the AviPersistenceProfileCacheDel function
func TestAviPersistenceProfileCacheDel(t *testing.T) {
	cache := avicache.NewAviObjCache()
	restOps := rest.NewRestOperations(cache)

	tests := []struct {
		name        string
		restOp      *utils.RestOp
		poolKey     avicache.NamespaceName
		key         string
		setupCache  func()
		validateDel func(t *testing.T)
	}{
		{
			name: "Delete persistence profile without pool",
			restOp: &utils.RestOp{
				ObjName: "test-profile",
				Tenant:  "admin",
			},
			poolKey: avicache.NamespaceName{},
			key:     "test-key",
			setupCache: func() {
				cacheKey := avicache.NamespaceName{Namespace: "admin", Name: "test-profile"}
				cacheObj := &avicache.AviPersistenceProfileCache{
					Name:   "test-profile",
					Tenant: "admin",
					Uuid:   "test-uuid-123",
				}
				cache.AppPersProfileCache.AviCacheAdd(cacheKey, cacheObj)
			},
			validateDel: func(t *testing.T) {
				cacheKey := avicache.NamespaceName{Namespace: "admin", Name: "test-profile"}
				_, found := cache.AppPersProfileCache.AviCacheGet(cacheKey)
				if found {
					t.Errorf("Expected cache entry to be deleted, but it still exists")
				}
			},
		},
		{
			name: "Delete persistence profile with pool association",
			restOp: &utils.RestOp{
				ObjName: "pool-profile",
				Tenant:  "admin",
			},
			poolKey: avicache.NamespaceName{Namespace: "admin", Name: "test-pool"},
			key:     "test-key",
			setupCache: func() {
				// Add persistence profile
				persKey := avicache.NamespaceName{Namespace: "admin", Name: "pool-profile"}
				persCache := &avicache.AviPersistenceProfileCache{
					Name:   "pool-profile",
					Tenant: "admin",
					Uuid:   "pool-uuid-456",
				}
				cache.AppPersProfileCache.AviCacheAdd(persKey, persCache)

				// Add pool with persistence profile reference
				poolKey := avicache.NamespaceName{Namespace: "admin", Name: "test-pool"}
				poolCache := cache.PoolCache.AviCacheAddPool(poolKey)
				poolCache.Name = "test-pool"
				poolCache.Tenant = "admin"
				poolCache.PersistenceProfile = persKey
			},
			validateDel: func(t *testing.T) {
				// Check persistence profile is deleted
				persKey := avicache.NamespaceName{Namespace: "admin", Name: "pool-profile"}
				_, found := cache.AppPersProfileCache.AviCacheGet(persKey)
				if found {
					t.Errorf("Expected persistence profile cache entry to be deleted, but it still exists")
				}

				// Check pool's persistence profile reference is cleared
				poolKey := avicache.NamespaceName{Namespace: "admin", Name: "test-pool"}
				poolCacheObj, found := cache.PoolCache.AviCacheGet(poolKey)
				if !found {
					t.Errorf("Expected pool cache entry to exist")
					return
				}
				poolCache, ok := poolCacheObj.(*avicache.AviPoolCache)
				if !ok {
					t.Errorf("Expected AviPoolCache, got %T", poolCacheObj)
					return
				}
				emptyKey := avicache.NamespaceName{}
				if poolCache.PersistenceProfile != emptyKey {
					t.Errorf("Expected persistence profile reference to be cleared, got %+v", poolCache.PersistenceProfile)
				}
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup cache
			if tt.setupCache != nil {
				tt.setupCache()
			}

			err := restOps.AviPersistenceProfileCacheDel(tt.restOp, tt.poolKey, tt.key)

			if err != nil {
				t.Errorf("Expected no error, but got: %v", err)
			}

			// Validate deletion
			if tt.validateDel != nil {
				tt.validateDel(t)
			}

			// Cleanup pool if exists
			if tt.poolKey != (avicache.NamespaceName{}) {
				cache.PoolCache.AviCacheDelete(tt.poolKey)
			}
		})
	}
}

// TestAviPersistenceProfileCacheAddWithMissingFields tests edge cases with missing fields
func TestAviPersistenceProfileCacheAddWithMissingFields(t *testing.T) {
	cache := avicache.NewAviObjCache()
	restOps := rest.NewRestOperations(cache)

	tests := []struct {
		name          string
		response      map[string]interface{}
		expectedError bool
	}{
		{
			name: "Missing name in response",
			response: map[string]interface{}{
				"uuid":           "test-uuid",
				"_last_modified": "2025-01-01T00:00:00Z",
			},
			expectedError: false, // Function continues but skips this entry
		},
		{
			name: "Missing uuid in response",
			response: map[string]interface{}{
				"name":           "test-profile",
				"_last_modified": "2025-01-01T00:00:00Z",
			},
			expectedError: false, // Function continues but skips this entry
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			restOp := &utils.RestOp{
				Err:    nil,
				Tenant: "admin",
				Obj: avimodels.ApplicationPersistenceProfile{
					Name:            StringPtr("test-profile"),
					PersistenceType: StringPtr("PERSISTENCE_TYPE_HTTP_COOKIE"),
				},
				Response: tt.response,
			}

			err := restOps.AviPersistenceProfileCacheAdd(restOp, avicache.NamespaceName{}, "test-key")

			if tt.expectedError && err == nil {
				t.Errorf("Expected error, but got nil")
			}

			if !tt.expectedError && err != nil {
				t.Errorf("Expected no error, but got: %v", err)
			}
		})
	}
}

// TestAviPersistenceProfileCacheAddWithArrayResponse tests handling of array responses
func TestAviPersistenceProfileCacheAddWithArrayResponse(t *testing.T) {
	cache := avicache.NewAviObjCache()
	restOps := rest.NewRestOperations(cache)

	// Create a response with multiple persistence profiles
	responseArray := []interface{}{
		map[string]interface{}{
			"name":           "profile-1",
			"uuid":           "uuid-1",
			"_last_modified": "2025-01-01T00:00:00Z",
		},
		map[string]interface{}{
			"name":           "profile-2",
			"uuid":           "uuid-2",
			"_last_modified": "2025-01-01T00:00:00Z",
		},
	}

	// Create response in the format expected by RestRespArrToObjByType
	response := map[string]interface{}{
		"results": responseArray,
	}

	restOp := &utils.RestOp{
		Err:    nil,
		Tenant: "admin",
		Obj: avimodels.ApplicationPersistenceProfile{
			Name:            StringPtr("profile-1"),
			PersistenceType: StringPtr("PERSISTENCE_TYPE_HTTP_COOKIE"),
		},
		Response: response,
	}

	err := restOps.AviPersistenceProfileCacheAdd(restOp, avicache.NamespaceName{}, "test-key")

	if err != nil {
		t.Errorf("Expected no error, but got: %v", err)
	}

	// Cleanup
	for _, item := range responseArray {
		if respMap, ok := item.(map[string]interface{}); ok {
			if name, ok := respMap["name"].(string); ok {
				cacheKey := avicache.NamespaceName{Namespace: "admin", Name: name}
				cache.AppPersProfileCache.AviCacheDelete(cacheKey)
			}
		}
	}
}

// TestPersistenceProfileChecksumCalculation tests that checksum is properly calculated
func TestPersistenceProfileChecksumCalculation(t *testing.T) {
	cache := avicache.NewAviObjCache()
	restOps := rest.NewRestOperations(cache)

	appPersProfile := avimodels.ApplicationPersistenceProfile{
		Name:            StringPtr("checksum-profile"),
		PersistenceType: StringPtr("PERSISTENCE_TYPE_HTTP_COOKIE"),
		HTTPCookiePersistenceProfile: &avimodels.HTTPCookiePersistenceProfile{
			CookieName:         StringPtr("checksum-cookie"),
			Timeout:            Int32Ptr(300),
			IsPersistentCookie: BoolPtr(true),
		},
	}

	restOp := &utils.RestOp{
		Err:    nil,
		Tenant: "admin",
		Obj:    appPersProfile,
		Response: map[string]interface{}{
			"name":           "checksum-profile",
			"uuid":           "checksum-uuid",
			"_last_modified": "2025-01-01T00:00:00Z",
		},
	}

	err := restOps.AviPersistenceProfileCacheAdd(restOp, avicache.NamespaceName{}, "test-key")
	if err != nil {
		t.Fatalf("Expected no error, but got: %v", err)
	}

	// Retrieve from cache and verify checksum is set
	cacheKey := avicache.NamespaceName{Namespace: "admin", Name: "checksum-profile"}
	cacheObj, found := cache.AppPersProfileCache.AviCacheGet(cacheKey)
	if !found {
		t.Fatalf("Expected cache entry for checksum-profile, but not found")
	}

	persProfileCache, ok := cacheObj.(*avicache.AviPersistenceProfileCache)
	if !ok {
		t.Fatalf("Expected AviPersistenceProfileCache, got %T", cacheObj)
	}

	if persProfileCache.CloudConfigCksum == 0 {
		t.Errorf("Expected non-zero checksum, got 0")
	}

	// Cleanup
	cache.AppPersProfileCache.AviCacheDelete(cacheKey)
}

// TestAviPersistenceProfileBuildWithMarkers tests building with AVI markers
func TestAviPersistenceProfileBuildWithMarkers(t *testing.T) {
	cache := avicache.NewAviObjCache()
	restOps := rest.NewRestOperations(cache)

	markers := utils.AviObjectMarkers{
		Namespace: "default",
		Host:      []string{"test.example.com"},
		Path:      []string{"/api"},
	}

	appPersProfileNode := &nodes.AviApplicationPersistenceProfileNode{
		Name:            "marker-profile",
		Tenant:          "admin",
		PersistenceType: "PERSISTENCE_TYPE_HTTP_COOKIE",
		HTTPCookiePersistenceProfile: &nodes.HTTPCookiePersistenceProfileNode{
			CookieName:         "marker-cookie",
			Timeout:            Int32Ptr(300),
			IsPersistentCookie: BoolPtr(true),
		},
		AviMarkers: markers,
	}

	restOp := restOps.AviPersistenceProfileBuild(appPersProfileNode, nil)

	if restOp == nil {
		t.Fatalf("Expected non-nil RestOp, but got nil")
	}

	var appPersProfile avimodels.ApplicationPersistenceProfile
	switch obj := restOp.Obj.(type) {
	case avimodels.ApplicationPersistenceProfile:
		appPersProfile = obj
	default:
		t.Fatalf("Expected ApplicationPersistenceProfile object, got %T", restOp.Obj)
	}

	// Verify markers are set
	if appPersProfile.Markers == nil {
		t.Errorf("Expected markers to be set, got nil")
	} else if len(appPersProfile.Markers) == 0 {
		t.Errorf("Expected non-empty markers, got empty array")
	}
}

// TestAviPersistenceProfileIntegration tests a complete flow
func TestAviPersistenceProfileIntegration(t *testing.T) {
	cache := avicache.NewAviObjCache()
	restOps := rest.NewRestOperations(cache)

	// Step 1: Build a new persistence profile (POST)
	appPersProfileNode := &nodes.AviApplicationPersistenceProfileNode{
		Name:            "integration-profile",
		Tenant:          "admin",
		PersistenceType: "PERSISTENCE_TYPE_HTTP_COOKIE",
		HTTPCookiePersistenceProfile: &nodes.HTTPCookiePersistenceProfileNode{
			CookieName:         "integration-cookie",
			Timeout:            Int32Ptr(300),
			IsPersistentCookie: BoolPtr(true),
		},
		AviMarkers: utils.AviObjectMarkers{},
	}

	restOp := restOps.AviPersistenceProfileBuild(appPersProfileNode, nil)
	if restOp == nil {
		t.Fatalf("Expected non-nil RestOp for build, but got nil")
	}

	if restOp.Method != utils.RestPost {
		t.Errorf("Expected POST method, got %s", restOp.Method)
	}

	// Step 2: Simulate adding to cache after successful creation
	restOp.Response = map[string]interface{}{
		"name":           "integration-profile",
		"uuid":           "integration-uuid-123",
		"_last_modified": "2025-01-01T00:00:00Z",
	}

	err := restOps.AviPersistenceProfileCacheAdd(restOp, avicache.NamespaceName{}, "integration-key")
	if err != nil {
		t.Fatalf("Expected no error adding to cache, but got: %v", err)
	}

	// Step 3: Verify cache entry
	cacheKey := avicache.NamespaceName{Namespace: "admin", Name: "integration-profile"}
	cacheObj, found := cache.AppPersProfileCache.AviCacheGet(cacheKey)
	if !found {
		t.Fatalf("Expected cache entry for integration-profile, but not found")
	}

	persProfileCache, ok := cacheObj.(*avicache.AviPersistenceProfileCache)
	if !ok {
		t.Fatalf("Expected AviPersistenceProfileCache, got %T", cacheObj)
	}

	// Step 4: Build an update (PUT) using the cached object
	updateRestOp := restOps.AviPersistenceProfileBuild(appPersProfileNode, persProfileCache)
	if updateRestOp == nil {
		t.Fatalf("Expected non-nil RestOp for update, but got nil")
	}

	if updateRestOp.Method != utils.RestPut {
		t.Errorf("Expected PUT method, got %s", updateRestOp.Method)
	}

	if updateRestOp.Path != "/api/applicationpersistenceprofile/integration-uuid-123" {
		t.Errorf("Expected path with UUID, got %s", updateRestOp.Path)
	}

	// Step 5: Delete the persistence profile
	delRestOp := restOps.AviPersistenceProfileDel(persProfileCache.Uuid, "admin")
	if delRestOp == nil {
		t.Fatalf("Expected non-nil RestOp for delete, but got nil")
	}

	if delRestOp.Method != "DELETE" {
		t.Errorf("Expected DELETE method, got %s", delRestOp.Method)
	}

	// Set ObjName for cache deletion
	delRestOp.ObjName = "integration-profile"

	// Step 6: Remove from cache
	err = restOps.AviPersistenceProfileCacheDel(delRestOp, avicache.NamespaceName{}, "integration-key")
	if err != nil {
		t.Fatalf("Expected no error deleting from cache, but got: %v", err)
	}

	// Step 7: Verify cache entry is deleted
	_, found = cache.AppPersProfileCache.AviCacheGet(cacheKey)
	if found {
		t.Errorf("Expected cache entry to be deleted, but it still exists")
	}
}

// TestAviPersistenceProfileCacheAddWithPoolCreation tests pool creation during persistence profile add
func TestAviPersistenceProfileCacheAddWithPoolCreation(t *testing.T) {
	cache := avicache.NewAviObjCache()
	restOps := rest.NewRestOperations(cache)

	poolKey := avicache.NamespaceName{Namespace: "admin", Name: "new-pool"}

	restOp := &utils.RestOp{
		Err:    nil,
		Tenant: "admin",
		Obj: avimodels.ApplicationPersistenceProfile{
			Name:            StringPtr("new-pool-profile"),
			PersistenceType: StringPtr("PERSISTENCE_TYPE_HTTP_COOKIE"),
		},
		Response: map[string]interface{}{
			"name":           "new-pool-profile",
			"uuid":           "new-pool-uuid",
			"_last_modified": "2025-01-01T00:00:00Z",
		},
	}

	// Don't pre-create the pool - let the function create it
	err := restOps.AviPersistenceProfileCacheAdd(restOp, poolKey, "test-key")
	if err != nil {
		t.Fatalf("Expected no error, but got: %v", err)
	}

	// Verify pool was created and has persistence profile reference
	poolCacheObj, found := cache.PoolCache.AviCacheGet(poolKey)
	if !found {
		t.Errorf("Expected pool cache entry to be created, but not found")
		return
	}

	poolCache, ok := poolCacheObj.(*avicache.AviPoolCache)
	if !ok {
		t.Errorf("Expected AviPoolCache, got %T", poolCacheObj)
		return
	}

	expectedPersKey := avicache.NamespaceName{Namespace: "admin", Name: "new-pool-profile"}
	if poolCache.PersistenceProfile != expectedPersKey {
		t.Errorf("Expected persistence profile %+v, got %+v", expectedPersKey, poolCache.PersistenceProfile)
	}

	// Cleanup
	cache.AppPersProfileCache.AviCacheDelete(expectedPersKey)
	cache.PoolCache.AviCacheDelete(poolKey)
}

// TestAviPersistenceProfileResponseSerialization tests JSON serialization
func TestAviPersistenceProfileResponseSerialization(t *testing.T) {
	appPersProfile := avimodels.ApplicationPersistenceProfile{
		Name:            StringPtr("serialize-profile"),
		PersistenceType: StringPtr("PERSISTENCE_TYPE_HTTP_COOKIE"),
		HTTPCookiePersistenceProfile: &avimodels.HTTPCookiePersistenceProfile{
			CookieName:         StringPtr("serialize-cookie"),
			Timeout:            Int32Ptr(300),
			IsPersistentCookie: BoolPtr(true),
		},
	}

	// Serialize to JSON
	jsonData, err := json.Marshal(appPersProfile)
	if err != nil {
		t.Fatalf("Failed to marshal persistence profile: %v", err)
	}

	// Deserialize from JSON
	var deserializedProfile avimodels.ApplicationPersistenceProfile
	err = json.Unmarshal(jsonData, &deserializedProfile)
	if err != nil {
		t.Fatalf("Failed to unmarshal persistence profile: %v", err)
	}

	// Verify fields
	if *deserializedProfile.Name != "serialize-profile" {
		t.Errorf("Expected name serialize-profile, got %s", *deserializedProfile.Name)
	}

	if *deserializedProfile.PersistenceType != "PERSISTENCE_TYPE_HTTP_COOKIE" {
		t.Errorf("Expected persistence type PERSISTENCE_TYPE_HTTP_COOKIE, got %s", *deserializedProfile.PersistenceType)
	}

	if deserializedProfile.HTTPCookiePersistenceProfile == nil {
		t.Errorf("Expected HTTPCookiePersistenceProfile, got nil")
	} else {
		if *deserializedProfile.HTTPCookiePersistenceProfile.CookieName != "serialize-cookie" {
			t.Errorf("Expected cookie name serialize-cookie, got %s", *deserializedProfile.HTTPCookiePersistenceProfile.CookieName)
		}
	}
}
