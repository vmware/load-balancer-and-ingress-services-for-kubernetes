/*
 * Copyright Â© 2025 Broadcom Inc. and/or its subsidiaries. All Rights Reserved.
 * All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// @AI-Generated
// [Generated by Cursor claude-4-sonnet]

package miscellaneous

import (
	"crypto/tls"
	"os"
	"testing"

	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/utils"
)

func TestAviModelToUrl(t *testing.T) {
	tests := []struct {
		name     string
		model    string
		expected string
	}{
		{
			name:     "Pool model",
			model:    "Pool",
			expected: "/api/pool",
		},
		{
			name:     "VirtualService model",
			model:    "VirtualService",
			expected: "/api/virtualservice",
		},
		{
			name:     "PoolGroup model",
			model:    "PoolGroup",
			expected: "/api/poolgroup",
		},
		{
			name:     "SSLKeyAndCertificate model",
			model:    "SSLKeyAndCertificate",
			expected: "/api/sslkeyandcertificate",
		},
		{
			name:     "HTTPPolicySet model",
			model:    "HTTPPolicySet",
			expected: "/api/httppolicyset",
		},
		{
			name:     "GSLBService model",
			model:    "GSLBService",
			expected: "/api/gslbservice",
		},
		{
			name:     "VsVip model",
			model:    "VsVip",
			expected: "/api/vsvip",
		},
		{
			name:     "VSDataScriptSet model",
			model:    "VSDataScriptSet",
			expected: "/api/vsdatascriptset",
		},
		{
			name:     "Unknown model",
			model:    "UnknownModel",
			expected: "",
		},
		{
			name:     "Empty model",
			model:    "",
			expected: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.AviModelToUrl(tt.model)
			if got != tt.expected {
				t.Errorf("AviModelToUrl(%s) = %v, want %v", tt.model, got, tt.expected)
			}
		})
	}
}

func TestGetHTTPTransportWithCert(t *testing.T) {
	tests := []struct {
		name         string
		rootPEMCerts string
		setupEnv     func()
		cleanupEnv   func()
		expectSecure bool
		expectNotNil bool
	}{
		{
			name:         "Empty PEM certs",
			rootPEMCerts: "",
			setupEnv:     func() {},
			cleanupEnv:   func() {},
			expectSecure: false,
			expectNotNil: false,
		},
		{
			name: "Valid PEM cert",
			rootPEMCerts: `-----BEGIN CERTIFICATE-----
MIICEjCCAXsCAg36MA0GCSqGSIb3DQEBBQUAMIGbMQswCQYDVQQGEwJKUDEOMAwG
A1UECBMFVG9reW8xEDAOBgNVBAcTB0NodW8ta3UxETAPBgNVBAoTCEZyYW5rNERE
MRgwFgYDVQQLEw9XZWJDZXJ0IFN1cHBvcnQxGDAWBgNVBAMTD0ZyYW5rNEREIFdl
YiBDQTEjMCEGCSqGSIb3DQEJARYUc3VwcG9ydEBmcmFuazRkZC5jb20wHhcNMTIw
ODIyMDUyNjU0WhcNMTcwODIxMDUyNjU0WjBKMQswCQYDVQQGEwJKUDEOMAwGA1UE
CAwFVG9reW8xETAPBgNVBAoMCEZyYW5rNEREMRgwFgYDVQQDDA93d3cuZXhhbXBs
ZS5jb20wXDANBgkqhkiG9w0BAQEFAANLADBIAkEAm/xmkHmEQrurE/0re/jeFRLl
8ZPjBop7uLHhnia7lQG/5zDtZIUC3RVpqDSwBuw/NTweGyuP+o8AG98HxqxTBwID
AQABMA0GCSqGSIb3DQEBBQUAA4GBABS2TLuBeTPmcaTaUW/LCB2NYOy8GMdzR1mx
8iBIu2H6/E2tiY3RIevV2OW61qY2/XRQg7YPxx3ffeUugX9F4J/iPnnu1zAxzyYw
ln1hzfGCRoqPXFvq7LZvODA/4VxKKJfYvYqCNxKqCBRSJlPUUgYGzLOIjKqFVqJ5
-----END CERTIFICATE-----`,
			setupEnv:     func() {},
			cleanupEnv:   func() {},
			expectSecure: true,
			expectNotNil: true,
		},
		{
			name: "VKS managed mode with controller IP",
			rootPEMCerts: `-----BEGIN CERTIFICATE-----
MIICEjCCAXsCAg36MA0GCSqGSIb3DQEBBQUAMIGbMQswCQYDVQQGEwJKUDEOMAwG
A1UECBMFVG9reW8xEDAOBgNVBAcTB0NodW8ta3UxETAPBgNVBAoTCEZyYW5rNERE
MRgwFgYDVQQLEw9XZWJDZXJ0IFN1cHBvcnQxGDAWBgNVBAMTD0ZyYW5rNEREIFdl
YiBDQTEjMCEGCSqGSIb3DQEJARYUc3VwcG9ydEBmcmFuazRkZC5jb20wHhcNMTIw
ODIyMDUyNjU0WhcNMTcwODIxMDUyNjU0WjBKMQswCQYDVQQGEwJKUDEOMAwGA1UE
CAwFVG9reW8xETAPBgNVBAoMCEZyYW5rNEREMRgwFgYDVQQDDA93d3cuZXhhbXBs
ZS5jb20wXDANBgkqhkiG9w0BAQEFAANLADBIAkEAm/xmkHmEQrurE/0re/jeFRLl
8ZPjBop7uLHhnia7lQG/5zDtZIUC3RVpqDSwBuw/NTweGyuP+o8AG98HxqxTBwID
AQABMA0GCSqGSIb3DQEBBQUAA4GBABS2TLuBeTPmcaTaUW/LCB2NYOy8GMdzR1mx
8iBIu2H6/E2tiY3RIevV2OW61qY2/XRQg7YPxx3ffeUugX9F4J/iPnnu1zAxzyYw
ln1hzfGCRoqPXFvq7LZvODA/4VxKKJfYvYqCNxKqCBRSJlPUUgYGzLOIjKqFVqJ5
-----END CERTIFICATE-----`,
			setupEnv: func() {
				os.Setenv("VKS_MANAGED", "true")
				os.Setenv("CTRL_IPADDRESS", "10.0.0.1")
			},
			cleanupEnv: func() {
				os.Unsetenv("VKS_MANAGED")
				os.Unsetenv("CTRL_IPADDRESS")
			},
			expectSecure: true,
			expectNotNil: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupEnv()
			defer tt.cleanupEnv()

			transport, isSecure := utils.GetHTTPTransportWithCert(tt.rootPEMCerts)

			if isSecure != tt.expectSecure {
				t.Errorf("GetHTTPTransportWithCert() isSecure = %v, want %v", isSecure, tt.expectSecure)
			}

			if tt.expectNotNil && transport == nil {
				t.Error("GetHTTPTransportWithCert() returned nil transport when non-nil was expected")
			}

			if !tt.expectNotNil && transport != nil {
				t.Error("GetHTTPTransportWithCert() returned non-nil transport when nil was expected")
			}

			// Verify TLS config is set when secure
			if tt.expectSecure && transport != nil {
				if transport.TLSClientConfig == nil {
					t.Error("GetHTTPTransportWithCert() TLSClientConfig is nil for secure transport")
				}
			}
		})
	}
}

func TestGetHTTPTransportWithCertTLSConfig(t *testing.T) {
	validCert := `-----BEGIN CERTIFICATE-----
MIICEjCCAXsCAg36MA0GCSqGSIb3DQEBBQUAMIGbMQswCQYDVQQGEwJKUDEOMAwG
A1UECBMFVG9reW8xEDAOBgNVBAcTB0NodW8ta3UxETAPBgNVBAoTCEZyYW5rNERE
MRgwFgYDVQQLEw9XZWJDZXJ0IFN1cHBvcnQxGDAWBgNVBAMTD0ZyYW5rNEREIFdl
YiBDQTEjMCEGCSqGSIb3DQEJARYUc3VwcG9ydEBmcmFuazRkZC5jb20wHhcNMTIw
ODIyMDUyNjU0WhcNMTcwODIxMDUyNjU0WjBKMQswCQYDVQQGEwJKUDEOMAwGA1UE
CAwFVG9reW8xETAPBgNVBAoMCEZyYW5rNEREMRgwFgYDVQQDDA93d3cuZXhhbXBs
ZS5jb20wXDANBgkqhkiG9w0BAQEFAANLADBIAkEAm/xmkHmEQrurE/0re/jeFRLl
8ZPjBop7uLHhnia7lQG/5zDtZIUC3RVpqDSwBuw/NTweGyuP+o8AG98HxqxTBwID
AQABMA0GCSqGSIb3DQEBBQUAA4GBABS2TLuBeTPmcaTaUW/LCB2NYOy8GMdzR1mx
8iBIu2H6/E2tiY3RIevV2OW61qY2/XRQg7YPxx3ffeUugX9F4J/iPnnu1zAxzyYw
ln1hzfGCRoqPXFvq7LZvODA/4VxKKJfYvYqCNxKqCBRSJlPUUgYGzLOIjKqFVqJ5
-----END CERTIFICATE-----`

	transport, isSecure := utils.GetHTTPTransportWithCert(validCert)

	if !isSecure {
		t.Error("GetHTTPTransportWithCert() should return secure=true for valid cert")
	}

	if transport == nil {
		t.Fatal("GetHTTPTransportWithCert() returned nil transport")
	}

	if transport.TLSClientConfig == nil {
		t.Fatal("GetHTTPTransportWithCert() TLSClientConfig is nil")
	}

	// Verify RootCAs is set
	if transport.TLSClientConfig.RootCAs == nil {
		t.Error("GetHTTPTransportWithCert() RootCAs is nil")
	}
}

func TestGetHTTPTransportWithCertVKSManagedMode(t *testing.T) {
	validCert := `-----BEGIN CERTIFICATE-----
MIICEjCCAXsCAg36MA0GCSqGSIb3DQEBBQUAMIGbMQswCQYDVQQGEwJKUDEOMAwG
A1UECBMFVG9reW8xEDAOBgNVBAcTB0NodW8ta3UxETAPBgNVBAoTCEZyYW5rNERE
MRgwFgYDVQQLEw9XZWJDZXJ0IFN1cHBvcnQxGDAWBgNVBAMTD0ZyYW5rNEREIFdl
YiBDQTEjMCEGCSqGSIb3DQEJARYUc3VwcG9ydEBmcmFuazRkZC5jb20wHhcNMTIw
ODIyMDUyNjU0WhcNMTcwODIxMDUyNjU0WjBKMQswCQYDVQQGEwJKUDEOMAwGA1UE
CAwFVG9reW8xETAPBgNVBAoMCEZyYW5rNEREMRgwFgYDVQQDDA93d3cuZXhhbXBs
ZS5jb20wXDANBgkqhkiG9w0BAQEFAANLADBIAkEAm/xmkHmEQrurE/0re/jeFRLl
8ZPjBop7uLHhnia7lQG/5zDtZIUC3RVpqDSwBuw/NTweGyuP+o8AG98HxqxTBwID
AQABMA0GCSqGSIb3DQEBBQUAA4GBABS2TLuBeTPmcaTaUW/LCB2NYOy8GMdzR1mx
8iBIu2H6/E2tiY3RIevV2OW61qY2/XRQg7YPxx3ffeUugX9F4J/iPnnu1zAxzyYw
ln1hzfGCRoqPXFvq7LZvODA/4VxKKJfYvYqCNxKqCBRSJlPUUgYGzLOIjKqFVqJ5
-----END CERTIFICATE-----`

	// Set up VKS managed mode environment
	os.Setenv("VKS_MANAGED", "true")
	os.Setenv("CTRL_ADDRESS", "controller.example.com")
	defer func() {
		os.Unsetenv("VKS_MANAGED")
		os.Unsetenv("CTRL_ADDRESS")
	}()

	transport, isSecure := utils.GetHTTPTransportWithCert(validCert)

	if !isSecure {
		t.Error("GetHTTPTransportWithCert() should return secure=true in VKS managed mode")
	}

	if transport == nil {
		t.Fatal("GetHTTPTransportWithCert() returned nil transport")
	}

	if transport.TLSClientConfig == nil {
		t.Fatal("GetHTTPTransportWithCert() TLSClientConfig is nil")
	}

	// Note: ServerName may or may not be set depending on VKS_MANAGED mode implementation
	// This test verifies the transport is created correctly with TLS config
	t.Logf("VKS managed mode: ServerName = %v", transport.TLSClientConfig.ServerName)
}

func TestGetHTTPTransportWithInvalidCert(t *testing.T) {
	invalidCert := "this is not a valid certificate"

	transport, isSecure := utils.GetHTTPTransportWithCert(invalidCert)

	if !isSecure {
		t.Error("GetHTTPTransportWithCert() should still return secure=true even with invalid cert")
	}

	if transport == nil {
		t.Fatal("GetHTTPTransportWithCert() returned nil transport")
	}

	// Transport should still be created even with invalid cert
	if transport.TLSClientConfig == nil {
		t.Error("GetHTTPTransportWithCert() TLSClientConfig should not be nil")
	}
}

func TestGetHTTPTransportReturnsHTTPTransport(t *testing.T) {
	validCert := `-----BEGIN CERTIFICATE-----
MIICEjCCAXsCAg36MA0GCSqGSIb3DQEBBQUAMIGbMQswCQYDVQQGEwJKUDEOMAwG
A1UECBMFVG9reW8xEDAOBgNVBAcTB0NodW8ta3UxETAPBgNVBAoTCEZyYW5rNERE
MRgwFgYDVQQLEw9XZWJDZXJ0IFN1cHBvcnQxGDAWBgNVBAMTD0ZyYW5rNEREIFdl
YiBDQTEjMCEGCSqGSIb3DQEJARYUc3VwcG9ydEBmcmFuazRkZC5jb20wHhcNMTIw
ODIyMDUyNjU0WhcNMTcwODIxMDUyNjU0WjBKMQswCQYDVQQGEwJKUDEOMAwGA1UE
CAwFVG9reW8xETAPBgNVBAoMCEZyYW5rNEREMRgwFgYDVQQDDA93d3cuZXhhbXBs
ZS5jb20wXDANBgkqhkiG9w0BAQEFAANLADBIAkEAm/xmkHmEQrurE/0re/jeFRLl
8ZPjBop7uLHhnia7lQG/5zDtZIUC3RVpqDSwBuw/NTweGyuP+o8AG98HxqxTBwID
AQABMA0GCSqGSIb3DQEBBQUAA4GBABS2TLuBeTPmcaTaUW/LCB2NYOy8GMdzR1mx
8iBIu2H6/E2tiY3RIevV2OW61qY2/XRQg7YPxx3ffeUugX9F4J/iPnnu1zAxzyYw
ln1hzfGCRoqPXFvq7LZvODA/4VxKKJfYvYqCNxKqCBRSJlPUUgYGzLOIjKqFVqJ5
-----END CERTIFICATE-----`

	transport, _ := utils.GetHTTPTransportWithCert(validCert)

	// Verify transport is not nil
	if transport == nil {
		t.Error("GetHTTPTransportWithCert() returned nil transport")
	}
}

func TestGetHTTPTransportTLSVersion(t *testing.T) {
	validCert := `-----BEGIN CERTIFICATE-----
MIICEjCCAXsCAg36MA0GCSqGSIb3DQEBBQUAMIGbMQswCQYDVQQGEwJKUDEOMAwG
A1UECBMFVG9reW8xEDAOBgNVBAcTB0NodW8ta3UxETAPBgNVBAoTCEZyYW5rNERE
MRgwFgYDVQQLEw9XZWJDZXJ0IFN1cHBvcnQxGDAWBgNVBAMTD0ZyYW5rNEREIFdl
YiBDQTEjMCEGCSqGSIb3DQEJARYUc3VwcG9ydEBmcmFuazRkZC5jb20wHhcNMTIw
ODIyMDUyNjU0WhcNMTcwODIxMDUyNjU0WjBKMQswCQYDVQQGEwJKUDEOMAwGA1UE
CAwFVG9reW8xETAPBgNVBAoMCEZyYW5rNEREMRgwFgYDVQQDDA93d3cuZXhhbXBs
ZS5jb20wXDANBgkqhkiG9w0BAQEFAANLADBIAkEAm/xmkHmEQrurE/0re/jeFRLl
8ZPjBop7uLHhnia7lQG/5zDtZIUC3RVpqDSwBuw/NTweGyuP+o8AG98HxqxTBwID
AQABMA0GCSqGSIb3DQEBBQUAA4GBABS2TLuBeTPmcaTaUW/LCB2NYOy8GMdzR1mx
8iBIu2H6/E2tiY3RIevV2OW61qY2/XRQg7YPxx3ffeUugX9F4J/iPnnu1zAxzyYw
ln1hzfGCRoqPXFvq7LZvODA/4VxKKJfYvYqCNxKqCBRSJlPUUgYGzLOIjKqFVqJ5
-----END CERTIFICATE-----`

	transport, _ := utils.GetHTTPTransportWithCert(validCert)

	if transport == nil || transport.TLSClientConfig == nil {
		t.Fatal("Transport or TLSClientConfig is nil")
	}

	// Verify TLS configuration is properly set
	tlsConfig := transport.TLSClientConfig

	// Check that RootCAs is configured
	if tlsConfig.RootCAs == nil {
		t.Error("TLSClientConfig.RootCAs should not be nil")
	}

	// MinVersion and MaxVersion should use defaults if not set explicitly
	// This is just verifying the config exists and is usable
	if tlsConfig.MinVersion != 0 && tlsConfig.MinVersion < tls.VersionTLS10 {
		t.Errorf("TLS MinVersion seems invalid: %v", tlsConfig.MinVersion)
	}
}
