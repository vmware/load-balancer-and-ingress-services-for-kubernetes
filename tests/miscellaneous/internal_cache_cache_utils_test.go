/*
 * Copyright Â© 2025 Broadcom Inc. and/or its subsidiaries. All Rights Reserved.
 * All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// @AI-Generated
// [Generated by Cursor claude-4-sonnet]

package miscellaneous

import (
	"testing"

	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/cache"
)

func TestRemoveNamespaceName(t *testing.T) {
	tests := []struct {
		name     string
		slice    []cache.NamespaceName
		remove   cache.NamespaceName
		expected []cache.NamespaceName
	}{
		{
			name: "Remove existing element from middle",
			slice: []cache.NamespaceName{
				{Namespace: "ns1", Name: "name1"},
				{Namespace: "ns2", Name: "name2"},
				{Namespace: "ns3", Name: "name3"},
			},
			remove: cache.NamespaceName{Namespace: "ns2", Name: "name2"},
			expected: []cache.NamespaceName{
				{Namespace: "ns1", Name: "name1"},
				{Namespace: "ns3", Name: "name3"},
			},
		},
		{
			name: "Remove first element",
			slice: []cache.NamespaceName{
				{Namespace: "ns1", Name: "name1"},
				{Namespace: "ns2", Name: "name2"},
			},
			remove: cache.NamespaceName{Namespace: "ns1", Name: "name1"},
			expected: []cache.NamespaceName{
				{Namespace: "ns2", Name: "name2"},
			},
		},
		{
			name: "Remove last element",
			slice: []cache.NamespaceName{
				{Namespace: "ns1", Name: "name1"},
				{Namespace: "ns2", Name: "name2"},
			},
			remove: cache.NamespaceName{Namespace: "ns2", Name: "name2"},
			expected: []cache.NamespaceName{
				{Namespace: "ns1", Name: "name1"},
			},
		},
		{
			name: "Remove non-existing element",
			slice: []cache.NamespaceName{
				{Namespace: "ns1", Name: "name1"},
				{Namespace: "ns2", Name: "name2"},
			},
			remove: cache.NamespaceName{Namespace: "ns3", Name: "name3"},
			expected: []cache.NamespaceName{
				{Namespace: "ns1", Name: "name1"},
				{Namespace: "ns2", Name: "name2"},
			},
		},
		{
			name:     "Remove from empty slice",
			slice:    []cache.NamespaceName{},
			remove:   cache.NamespaceName{Namespace: "ns1", Name: "name1"},
			expected: []cache.NamespaceName{},
		},
		{
			name: "Remove only element",
			slice: []cache.NamespaceName{
				{Namespace: "ns1", Name: "name1"},
			},
			remove:   cache.NamespaceName{Namespace: "ns1", Name: "name1"},
			expected: []cache.NamespaceName{},
		},
		{
			name: "Remove element with matching namespace but different name",
			slice: []cache.NamespaceName{
				{Namespace: "ns1", Name: "name1"},
				{Namespace: "ns1", Name: "name2"},
			},
			remove: cache.NamespaceName{Namespace: "ns1", Name: "name3"},
			expected: []cache.NamespaceName{
				{Namespace: "ns1", Name: "name1"},
				{Namespace: "ns1", Name: "name2"},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := cache.RemoveNamespaceName(tt.slice, tt.remove)

			if len(got) != len(tt.expected) {
				t.Errorf("RemoveNamespaceName() length = %v, want %v", len(got), len(tt.expected))
				return
			}

			for i := range got {
				if got[i] != tt.expected[i] {
					t.Errorf("RemoveNamespaceName() = %v, want %v", got, tt.expected)
					break
				}
			}
		})
	}
}

func TestAviVsCacheAddToPGKeyCollection(t *testing.T) {
	tests := []struct {
		name           string
		initialKeys    []cache.NamespaceName
		addKey         cache.NamespaceName
		expectedLength int
		shouldContain  cache.NamespaceName
	}{
		{
			name:           "Add to nil collection",
			initialKeys:    nil,
			addKey:         cache.NamespaceName{Namespace: "ns1", Name: "pg1"},
			expectedLength: 1,
			shouldContain:  cache.NamespaceName{Namespace: "ns1", Name: "pg1"},
		},
		{
			name: "Add to existing collection",
			initialKeys: []cache.NamespaceName{
				{Namespace: "ns1", Name: "pg1"},
			},
			addKey:         cache.NamespaceName{Namespace: "ns2", Name: "pg2"},
			expectedLength: 2,
			shouldContain:  cache.NamespaceName{Namespace: "ns2", Name: "pg2"},
		},
		{
			name: "Add duplicate key",
			initialKeys: []cache.NamespaceName{
				{Namespace: "ns1", Name: "pg1"},
			},
			addKey:         cache.NamespaceName{Namespace: "ns1", Name: "pg1"},
			expectedLength: 1,
			shouldContain:  cache.NamespaceName{Namespace: "ns1", Name: "pg1"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			vsCache := &cache.AviVsCache{
				PGKeyCollection: tt.initialKeys,
			}

			vsCache.AddToPGKeyCollection(tt.addKey)

			if len(vsCache.PGKeyCollection) != tt.expectedLength {
				t.Errorf("AddToPGKeyCollection() length = %v, want %v", len(vsCache.PGKeyCollection), tt.expectedLength)
			}

			found := false
			for _, key := range vsCache.PGKeyCollection {
				if key == tt.shouldContain {
					found = true
					break
				}
			}

			if !found {
				t.Errorf("AddToPGKeyCollection() should contain %v", tt.shouldContain)
			}
		})
	}
}

func TestAviVsCacheRemoveFromPGKeyCollection(t *testing.T) {
	tests := []struct {
		name           string
		initialKeys    []cache.NamespaceName
		removeKey      cache.NamespaceName
		expectedLength int
	}{
		{
			name:           "Remove from nil collection",
			initialKeys:    nil,
			removeKey:      cache.NamespaceName{Namespace: "ns1", Name: "pg1"},
			expectedLength: 0,
		},
		{
			name: "Remove existing key",
			initialKeys: []cache.NamespaceName{
				{Namespace: "ns1", Name: "pg1"},
				{Namespace: "ns2", Name: "pg2"},
			},
			removeKey:      cache.NamespaceName{Namespace: "ns1", Name: "pg1"},
			expectedLength: 1,
		},
		{
			name: "Remove non-existing key",
			initialKeys: []cache.NamespaceName{
				{Namespace: "ns1", Name: "pg1"},
			},
			removeKey:      cache.NamespaceName{Namespace: "ns2", Name: "pg2"},
			expectedLength: 1,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			vsCache := &cache.AviVsCache{
				PGKeyCollection: tt.initialKeys,
			}

			vsCache.RemoveFromPGKeyCollection(tt.removeKey)

			actualLength := 0
			if vsCache.PGKeyCollection != nil {
				actualLength = len(vsCache.PGKeyCollection)
			}

			if actualLength != tt.expectedLength {
				t.Errorf("RemoveFromPGKeyCollection() length = %v, want %v", actualLength, tt.expectedLength)
			}
		})
	}
}

func TestAviVsCacheAddToPoolKeyCollection(t *testing.T) {
	vsCache := &cache.AviVsCache{}

	// Add first key
	key1 := cache.NamespaceName{Namespace: "ns1", Name: "pool1"}
	vsCache.AddToPoolKeyCollection(key1)

	if len(vsCache.PoolKeyCollection) != 1 {
		t.Errorf("AddToPoolKeyCollection() length = %v, want 1", len(vsCache.PoolKeyCollection))
	}

	// Add second key
	key2 := cache.NamespaceName{Namespace: "ns2", Name: "pool2"}
	vsCache.AddToPoolKeyCollection(key2)

	if len(vsCache.PoolKeyCollection) != 2 {
		t.Errorf("AddToPoolKeyCollection() length = %v, want 2", len(vsCache.PoolKeyCollection))
	}

	// Add duplicate
	vsCache.AddToPoolKeyCollection(key1)

	if len(vsCache.PoolKeyCollection) != 2 {
		t.Errorf("AddToPoolKeyCollection() should not add duplicate, length = %v, want 2", len(vsCache.PoolKeyCollection))
	}
}

func TestAviVsCacheAddToHTTPKeyCollection(t *testing.T) {
	vsCache := &cache.AviVsCache{}

	key := cache.NamespaceName{Namespace: "ns1", Name: "http1"}
	vsCache.AddToHTTPKeyCollection(key)

	if len(vsCache.HTTPKeyCollection) != 1 {
		t.Errorf("AddToHTTPKeyCollection() length = %v, want 1", len(vsCache.HTTPKeyCollection))
	}

	if vsCache.HTTPKeyCollection[0] != key {
		t.Errorf("AddToHTTPKeyCollection() key = %v, want %v", vsCache.HTTPKeyCollection[0], key)
	}
}

func TestAviVsCacheAddToSSLKeyCertCollection(t *testing.T) {
	vsCache := &cache.AviVsCache{}

	key := cache.NamespaceName{Namespace: "ns1", Name: "ssl1"}
	vsCache.AddToSSLKeyCertCollection(key)

	if len(vsCache.SSLKeyCertCollection) != 1 {
		t.Errorf("AddToSSLKeyCertCollection() length = %v, want 1", len(vsCache.SSLKeyCertCollection))
	}

	// Add duplicate
	vsCache.AddToSSLKeyCertCollection(key)

	if len(vsCache.SSLKeyCertCollection) != 1 {
		t.Errorf("AddToSSLKeyCertCollection() should not add duplicate, length = %v", len(vsCache.SSLKeyCertCollection))
	}
}

func TestAviVsCacheAddToSNIChildCollection(t *testing.T) {
	vsCache := &cache.AviVsCache{}

	child1 := "child-vs-1"
	vsCache.AddToSNIChildCollection(child1)

	if len(vsCache.SNIChildCollection) != 1 {
		t.Errorf("AddToSNIChildCollection() length = %v, want 1", len(vsCache.SNIChildCollection))
	}

	child2 := "child-vs-2"
	vsCache.AddToSNIChildCollection(child2)

	if len(vsCache.SNIChildCollection) != 2 {
		t.Errorf("AddToSNIChildCollection() length = %v, want 2", len(vsCache.SNIChildCollection))
	}

	// Add duplicate
	vsCache.AddToSNIChildCollection(child1)

	if len(vsCache.SNIChildCollection) != 2 {
		t.Errorf("AddToSNIChildCollection() should not add duplicate, length = %v", len(vsCache.SNIChildCollection))
	}
}

func TestAviVsCacheReplaceSNIChildCollection(t *testing.T) {
	vsCache := &cache.AviVsCache{
		SNIChildCollection: []string{"child1", "child2"},
	}

	newCollection := []string{"child3", "child4", "child5"}
	vsCache.ReplaceSNIChildCollection(newCollection)

	if len(vsCache.SNIChildCollection) != 3 {
		t.Errorf("ReplaceSNIChildCollection() length = %v, want 3", len(vsCache.SNIChildCollection))
	}

	for i, child := range newCollection {
		if vsCache.SNIChildCollection[i] != child {
			t.Errorf("ReplaceSNIChildCollection() child[%d] = %v, want %v", i, vsCache.SNIChildCollection[i], child)
		}
	}
}

func TestAviVsCacheRemoveFromSNIChildCollection(t *testing.T) {
	vsCache := &cache.AviVsCache{
		SNIChildCollection: []string{"child1", "child2", "child3"},
	}

	vsCache.RemoveFromSNIChildCollection("child2")

	if len(vsCache.SNIChildCollection) != 2 {
		t.Errorf("RemoveFromSNIChildCollection() length = %v, want 2", len(vsCache.SNIChildCollection))
	}

	// Verify child2 is removed
	for _, child := range vsCache.SNIChildCollection {
		if child == "child2" {
			t.Error("RemoveFromSNIChildCollection() should have removed child2")
		}
	}
}

func TestAviVsCacheSetPGKeyCollection(t *testing.T) {
	vsCache := &cache.AviVsCache{}

	newCollection := []cache.NamespaceName{
		{Namespace: "ns1", Name: "pg1"},
		{Namespace: "ns2", Name: "pg2"},
	}

	vsCache.SetPGKeyCollection(newCollection)

	if len(vsCache.PGKeyCollection) != 2 {
		t.Errorf("SetPGKeyCollection() length = %v, want 2", len(vsCache.PGKeyCollection))
	}

	for i, key := range newCollection {
		if vsCache.PGKeyCollection[i] != key {
			t.Errorf("SetPGKeyCollection() key[%d] = %v, want %v", i, vsCache.PGKeyCollection[i], key)
		}
	}
}

func TestAviVsCacheAddToL4PolicyCollection(t *testing.T) {
	vsCache := &cache.AviVsCache{}

	key := cache.NamespaceName{Namespace: "ns1", Name: "l4policy1"}
	vsCache.AddToL4PolicyCollection(key)

	if len(vsCache.L4PolicyCollection) != 1 {
		t.Errorf("AddToL4PolicyCollection() length = %v, want 1", len(vsCache.L4PolicyCollection))
	}

	// Add another key
	key2 := cache.NamespaceName{Namespace: "ns2", Name: "l4policy2"}
	vsCache.AddToL4PolicyCollection(key2)

	if len(vsCache.L4PolicyCollection) != 2 {
		t.Errorf("AddToL4PolicyCollection() length = %v, want 2", len(vsCache.L4PolicyCollection))
	}
}

func TestAviVsCacheAddToStringGroupKeyCollection(t *testing.T) {
	vsCache := &cache.AviVsCache{}

	key := cache.NamespaceName{Namespace: "ns1", Name: "stringgroup1"}
	vsCache.AddToStringGroupKeyCollection(key)

	if len(vsCache.StringGroupKeyCollection) != 1 {
		t.Errorf("AddToStringGroupKeyCollection() length = %v, want 1", len(vsCache.StringGroupKeyCollection))
	}

	if vsCache.StringGroupKeyCollection[0] != key {
		t.Errorf("AddToStringGroupKeyCollection() key = %v, want %v", vsCache.StringGroupKeyCollection[0], key)
	}
}

func TestAviVsCacheAddToDSKeyCollection(t *testing.T) {
	vsCache := &cache.AviVsCache{}

	key := cache.NamespaceName{Namespace: "ns1", Name: "ds1"}
	vsCache.AddToDSKeyCollection(key)

	if len(vsCache.DSKeyCollection) != 1 {
		t.Errorf("AddToDSKeyCollection() length = %v, want 1", len(vsCache.DSKeyCollection))
	}

	// Test duplicate prevention
	vsCache.AddToDSKeyCollection(key)

	if len(vsCache.DSKeyCollection) != 1 {
		t.Errorf("AddToDSKeyCollection() should not add duplicate, length = %v", len(vsCache.DSKeyCollection))
	}
}

func TestAviVsCacheAddToVSVipKeyCollection(t *testing.T) {
	vsCache := &cache.AviVsCache{}

	key := cache.NamespaceName{Namespace: "ns1", Name: "vsvip1"}
	vsCache.AddToVSVipKeyCollection(key)

	if len(vsCache.VSVipKeyCollection) != 1 {
		t.Errorf("AddToVSVipKeyCollection() length = %v, want 1", len(vsCache.VSVipKeyCollection))
	}

	if vsCache.VSVipKeyCollection[0] != key {
		t.Errorf("AddToVSVipKeyCollection() key = %v, want %v", vsCache.VSVipKeyCollection[0], key)
	}
}
