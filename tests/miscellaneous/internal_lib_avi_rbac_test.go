/*
 * Copyright 2024 VMware, Inc.
 * All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*   http://www.apache.org/licenses/LICENSE-2.0
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

// @AI-Generated
// This test file was generated by Claude AI assistant.

package miscellaneous

import (
	"fmt"
	"strings"
	"testing"

	"google.golang.org/protobuf/proto"

	"github.com/vmware/alb-sdk/go/models"

	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/lib"
)

// TestCreateClusterRoles tests cluster role creation
func TestCreateClusterRoles(t *testing.T) {
	t.Run("NilClient", func(t *testing.T) {
		_, err := lib.CreateClusterRoles(nil, "test", "tenant")
		if err == nil {
			t.Fatal("Expected error for nil client")
		}
		expected := "avi Controller client not available - ensure AKO infra is properly initialized"
		if err.Error() != expected {
			t.Errorf("Expected error %q, got %q", expected, err.Error())
		}
	})
}

// TestCreateClusterUserWithRoles tests user creation
func TestCreateClusterUserWithRoles(t *testing.T) {
	t.Run("NilClient", func(t *testing.T) {
		roles := &lib.ClusterRoles{}
		_, _, err := lib.CreateClusterUserWithRoles(nil, "test", roles, "tenant")
		if err == nil {
			t.Fatal("Expected error for nil client")
		}
		expected := "avi Controller client not available - ensure AKO infra is properly initialized"
		if err.Error() != expected {
			t.Errorf("Expected error %q, got %q", expected, err.Error())
		}
	})

	t.Run("UserAccessStructure", func(t *testing.T) {
		// Test user access role structure
		tenant := "my-tenant"
		roles := &lib.ClusterRoles{
			AdminRole:      &models.Role{UUID: proto.String("admin-uuid")},
			TenantRole:     &models.Role{UUID: proto.String("tenant-uuid")},
			AllTenantsRole: &models.Role{UUID: proto.String("all-uuid")},
		}

		userAccess := []*models.UserRole{
			{
				RoleRef:   roles.AdminRole.UUID,
				TenantRef: proto.String("/api/tenant/?name=admin"),
			},
			{
				RoleRef:   roles.TenantRole.UUID,
				TenantRef: proto.String(fmt.Sprintf("/api/tenant/?name=%s", tenant)),
			},
			{
				RoleRef:    roles.AllTenantsRole.UUID,
				AllTenants: proto.Bool(true),
			},
		}

		if len(userAccess) != 3 {
			t.Error("Expected 3 user access roles")
		}

		// Check admin role
		if *userAccess[0].RoleRef != "admin-uuid" {
			t.Error("Admin role ref incorrect")
		}
		if *userAccess[0].TenantRef != "/api/tenant/?name=admin" {
			t.Error("Admin tenant ref incorrect")
		}

		// Check tenant role
		if *userAccess[1].RoleRef != "tenant-uuid" {
			t.Error("Tenant role ref incorrect")
		}
		if *userAccess[1].TenantRef != "/api/tenant/?name=my-tenant" {
			t.Error("Tenant ref incorrect")
		}

		// Check all-tenants role
		if *userAccess[2].RoleRef != "all-uuid" {
			t.Error("All-tenants role ref incorrect")
		}
		if !*userAccess[2].AllTenants {
			t.Error("AllTenants should be true")
		}
	})
}

// TestDeleteClusterRoles tests role deletion
func TestDeleteClusterRoles(t *testing.T) {
	t.Run("NilClientHandling", func(t *testing.T) {
		err := lib.DeleteClusterRoles(nil, "test")
		if err != nil {
			t.Errorf("Should handle nil client gracefully, got: %v", err)
		}
	})

	t.Run("ClusterSpecificRoleDeletion", func(t *testing.T) {
		cluster := "del-cluster"

		// Only cluster-specific tenant role is deleted (shared roles are preserved)
		clusterTenantRole := fmt.Sprintf("%s-tenant-role", cluster)

		if clusterTenantRole != "del-cluster-tenant-role" {
			t.Errorf("Expected cluster-specific tenant role name del-cluster-tenant-role, got %s", clusterTenantRole)
		}

		// Verify shared roles are NOT in deletion list
		sharedRoles := []string{"vks-admin-role", "vks-all-tenants-role"}
		for _, shared := range sharedRoles {
			if strings.Contains(shared, cluster) {
				t.Errorf("Shared role %s should not contain cluster name", shared)
			}
		}
	})
}

// TestDeleteClusterUser tests user deletion
func TestDeleteClusterUser(t *testing.T) {
	t.Run("NilClientHandling", func(t *testing.T) {
		err := lib.DeleteClusterUser(nil, "test")
		if err != nil {
			t.Errorf("Should handle nil client gracefully, got: %v", err)
		}
	})

	t.Run("UserNameConstruction", func(t *testing.T) {
		cluster := "del-user-cluster"
		expected := fmt.Sprintf("%s-user", cluster)
		if expected != "del-user-cluster-user" {
			t.Error("User name construction for deletion incorrect")
		}
	})
}

// TestClusterFilterConstruction tests the cluster filter logic
func TestClusterFilterConstruction(t *testing.T) {
	t.Run("FilterStructure", func(t *testing.T) {
		cluster := "filter-cluster"

		filter := &models.RoleFilter{
			MatchOperation: proto.String("ROLE_FILTER_EQUALS"),
			MatchLabel: &models.RoleFilterMatchLabel{
				Key:    proto.String("clustername"),
				Values: []string{cluster},
			},
			Enabled: proto.Bool(true),
		}

		// Verify structure
		if *filter.MatchOperation != "ROLE_FILTER_EQUALS" {
			t.Error("Expected ROLE_FILTER_EQUALS")
		}

		if *filter.MatchLabel.Key != "clustername" {
			t.Error("Expected key 'clustername'")
		}

		if len(filter.MatchLabel.Values) != 1 || filter.MatchLabel.Values[0] != cluster {
			t.Error("Expected cluster name in values")
		}

		if !*filter.Enabled {
			t.Error("Expected filter to be enabled")
		}
	})
}

// TestDataStructures tests the struct definitions
func TestDataStructures(t *testing.T) {
	t.Run("ClusterCredentials", func(t *testing.T) {
		creds := &lib.ClusterCredentials{
			Username: "testuser",
			Password: "testpass",
		}

		if creds.Username != "testuser" {
			t.Errorf("Expected username 'testuser', got %s", creds.Username)
		}
		if creds.Password != "testpass" {
			t.Errorf("Expected password 'testpass', got %s", creds.Password)
		}
	})

	t.Run("ClusterRoles", func(t *testing.T) {
		admin := &models.Role{Name: proto.String("admin")}
		tenant := &models.Role{Name: proto.String("tenant")}
		allTenants := &models.Role{Name: proto.String("all")}

		roles := &lib.ClusterRoles{
			AdminRole:      admin,
			TenantRole:     tenant,
			AllTenantsRole: allTenants,
		}

		if roles.AdminRole != admin {
			t.Error("AdminRole not set correctly")
		}
		if roles.TenantRole != tenant {
			t.Error("TenantRole not set correctly")
		}
		if roles.AllTenantsRole != allTenants {
			t.Error("AllTenantsRole not set correctly")
		}
	})
}
