/*
 * Copyright Â© 2025 Broadcom Inc. and/or its subsidiaries. All Rights Reserved.
 * All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// @AI-Generated
// [Generated by Cursor claude-4-sonnet]

package miscellaneous

import (
	"testing"
	"time"

	corev1 "k8s.io/api/core/v1"
	networkingv1 "k8s.io/api/networking/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	routev1 "github.com/openshift/api/route/v1"

	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/lib"
)

func TestExtractTypeNameNamespace(t *testing.T) {
	tests := []struct {
		name              string
		key               string
		expectedType      string
		expectedNamespace string
		expectedName      string
	}{
		{
			name:              "Three segments",
			key:               "Service/default/my-service",
			expectedType:      "Service",
			expectedNamespace: "default",
			expectedName:      "my-service",
		},
		{
			name:              "Two segments",
			key:               "Service/my-service",
			expectedType:      "Service",
			expectedNamespace: "",
			expectedName:      "my-service",
		},
		{
			name:              "Single segment",
			key:               "my-service",
			expectedType:      "",
			expectedNamespace: "",
			expectedName:      "my-service",
		},
		{
			name:              "Empty string",
			key:               "",
			expectedType:      "",
			expectedNamespace: "",
			expectedName:      "",
		},
		{
			name:              "With path separator in name",
			key:               "Ingress/default/path/to/resource",
			expectedType:      "Ingress",
			expectedNamespace: "default",
			expectedName:      "path/to/resource",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gotType, gotNamespace, gotName := lib.ExtractTypeNameNamespace(tt.key)

			if gotType != tt.expectedType {
				t.Errorf("ExtractTypeNameNamespace() type = %v, want %v", gotType, tt.expectedType)
			}

			if gotNamespace != tt.expectedNamespace {
				t.Errorf("ExtractTypeNameNamespace() namespace = %v, want %v", gotNamespace, tt.expectedNamespace)
			}

			if gotName != tt.expectedName {
				t.Errorf("ExtractTypeNameNamespace() name = %v, want %v", gotName, tt.expectedName)
			}
		})
	}
}

func TestIsServiceNodPortType(t *testing.T) {
	tests := []struct {
		name     string
		service  *corev1.Service
		expected bool
	}{
		{
			name: "NodePort service",
			service: &corev1.Service{
				Spec: corev1.ServiceSpec{
					Type: corev1.ServiceTypeNodePort,
				},
			},
			expected: true,
		},
		{
			name: "ClusterIP service",
			service: &corev1.Service{
				Spec: corev1.ServiceSpec{
					Type: corev1.ServiceTypeClusterIP,
				},
			},
			expected: false,
		},
		{
			name: "LoadBalancer service",
			service: &corev1.Service{
				Spec: corev1.ServiceSpec{
					Type: corev1.ServiceTypeLoadBalancer,
				},
			},
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := lib.IsServiceNodPortType(tt.service)
			if got != tt.expected {
				t.Errorf("IsServiceNodPortType() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestIsServiceClusterIPType(t *testing.T) {
	tests := []struct {
		name     string
		service  *corev1.Service
		expected bool
	}{
		{
			name: "ClusterIP service",
			service: &corev1.Service{
				Spec: corev1.ServiceSpec{
					Type: corev1.ServiceTypeClusterIP,
				},
			},
			expected: true,
		},
		{
			name: "NodePort service",
			service: &corev1.Service{
				Spec: corev1.ServiceSpec{
					Type: corev1.ServiceTypeNodePort,
				},
			},
			expected: false,
		},
		{
			name: "LoadBalancer service",
			service: &corev1.Service{
				Spec: corev1.ServiceSpec{
					Type: corev1.ServiceTypeLoadBalancer,
				},
			},
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := lib.IsServiceClusterIPType(tt.service)
			if got != tt.expected {
				t.Errorf("IsServiceClusterIPType() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestHasSpecLoadBalancerIP(t *testing.T) {
	tests := []struct {
		name     string
		service  *corev1.Service
		expected bool
	}{
		{
			name: "Service with LoadBalancerIP",
			service: &corev1.Service{
				Spec: corev1.ServiceSpec{
					LoadBalancerIP: "10.0.0.1",
				},
			},
			expected: true,
		},
		{
			name: "Service without LoadBalancerIP",
			service: &corev1.Service{
				Spec: corev1.ServiceSpec{
					LoadBalancerIP: "",
				},
			},
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := lib.HasSpecLoadBalancerIP(tt.service)
			if got != tt.expected {
				t.Errorf("HasSpecLoadBalancerIP() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestHasLoadBalancerIPAnnotation(t *testing.T) {
	tests := []struct {
		name     string
		service  *corev1.Service
		expected bool
	}{
		{
			name: "Service with LoadBalancerIP annotation",
			service: &corev1.Service{
				ObjectMeta: metav1.ObjectMeta{
					Annotations: map[string]string{
						lib.LoadBalancerIP: "10.0.0.1",
					},
				},
			},
			expected: true,
		},
		{
			name: "Service without LoadBalancerIP annotation",
			service: &corev1.Service{
				ObjectMeta: metav1.ObjectMeta{
					Annotations: map[string]string{},
				},
			},
			expected: false,
		},
		{
			name: "Service with empty LoadBalancerIP annotation",
			service: &corev1.Service{
				ObjectMeta: metav1.ObjectMeta{
					Annotations: map[string]string{
						lib.LoadBalancerIP: "",
					},
				},
			},
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := lib.HasLoadBalancerIPAnnotation(tt.service)
			if got != tt.expected {
				t.Errorf("HasLoadBalancerIPAnnotation() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestDifference(t *testing.T) {
	tests := []struct {
		name     string
		a        []string
		b        []string
		expected []string
	}{
		{
			name:     "No common elements",
			a:        []string{"a", "b", "c"},
			b:        []string{"d", "e", "f"},
			expected: []string{"a", "b", "c"},
		},
		{
			name:     "Some common elements",
			a:        []string{"a", "b", "c", "d"},
			b:        []string{"b", "d"},
			expected: []string{"a", "c"},
		},
		{
			name:     "All common elements",
			a:        []string{"a", "b", "c"},
			b:        []string{"a", "b", "c"},
			expected: []string{},
		},
		{
			name:     "Empty first slice",
			a:        []string{},
			b:        []string{"a", "b"},
			expected: []string{},
		},
		{
			name:     "Empty second slice",
			a:        []string{"a", "b", "c"},
			b:        []string{},
			expected: []string{"a", "b", "c"},
		},
		{
			name:     "Both empty",
			a:        []string{},
			b:        []string{},
			expected: []string{},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := lib.Difference(tt.a, tt.b)

			if len(got) != len(tt.expected) {
				t.Errorf("Difference() length = %v, want %v", len(got), len(tt.expected))
				return
			}

			// Convert to map for easier comparison
			gotMap := make(map[string]bool)
			for _, v := range got {
				gotMap[v] = true
			}

			for _, v := range tt.expected {
				if !gotMap[v] {
					t.Errorf("Difference() missing expected value %v", v)
				}
			}
		})
	}
}

func TestCheckConstraintsForRFC(t *testing.T) {
	tests := []struct {
		name      string
		input     string
		pattern   string
		maxlength int
		expected  bool
	}{
		{
			name:      "Valid name within length",
			input:     "valid-name",
			pattern:   "^[a-z]([-a-z0-9]*[a-z0-9])?$",
			maxlength: 63,
			expected:  true,
		},
		{
			name:      "Name too long",
			input:     "this-is-a-very-long-name-that-exceeds-the-maximum-length-allowed",
			pattern:   "^[a-z]([-a-z0-9]*[a-z0-9])?$",
			maxlength: 10,
			expected:  false,
		},
		{
			name:      "Name doesn't match pattern",
			input:     "Invalid_Name",
			pattern:   "^[a-z]([-a-z0-9]*[a-z0-9])?$",
			maxlength: 63,
			expected:  false,
		},
		{
			name:      "Empty name",
			input:     "",
			pattern:   "^[a-z]([-a-z0-9]*[a-z0-9])?$",
			maxlength: 63,
			expected:  false,
		},
		{
			name:      "Name with uppercase",
			input:     "UpperCase",
			pattern:   "^[a-z]([-a-z0-9]*[a-z0-9])?$",
			maxlength: 63,
			expected:  false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := lib.CheckConstraintsForRFC(tt.input, tt.pattern, tt.maxlength)
			if got != tt.expected {
				t.Errorf("CheckConstraintsForRFC() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestCheckRFC1035(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected bool
	}{
		{
			name:     "Valid RFC1035 name",
			input:    "valid-name",
			expected: true,
		},
		{
			name:     "Valid with numbers",
			input:    "name123",
			expected: true,
		},
		{
			name:     "Starts with number",
			input:    "1name",
			expected: false,
		},
		{
			name:     "Contains uppercase",
			input:    "ValidName",
			expected: false,
		},
		{
			name:     "Contains underscore",
			input:    "valid_name",
			expected: false,
		},
		{
			name:     "Too long",
			input:    "this-is-a-very-long-name-that-exceeds-the-sixty-three-character-limit-for-rfc1035",
			expected: false,
		},
		{
			name:     "Empty string",
			input:    "",
			expected: false,
		},
		{
			name:     "Single character",
			input:    "a",
			expected: true,
		},
		{
			name:     "Ends with hyphen",
			input:    "name-",
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := lib.CheckRFC1035(tt.input)
			if got != tt.expected {
				t.Errorf("CheckRFC1035(%s) = %v, want %v", tt.input, got, tt.expected)
			}
		})
	}
}

func TestIngressLessthan(t *testing.T) {
	now := metav1.Now()
	earlier := metav1.NewTime(now.Add(-1 * time.Hour))

	tests := []struct {
		name     string
		ing1     *networkingv1.Ingress
		ing2     *networkingv1.Ingress
		expected bool
	}{
		{
			name: "ing1 created before ing2",
			ing1: &networkingv1.Ingress{
				ObjectMeta: metav1.ObjectMeta{
					CreationTimestamp: earlier,
				},
			},
			ing2: &networkingv1.Ingress{
				ObjectMeta: metav1.ObjectMeta{
					CreationTimestamp: now,
				},
			},
			expected: true,
		},
		{
			name: "ing1 created after ing2",
			ing1: &networkingv1.Ingress{
				ObjectMeta: metav1.ObjectMeta{
					CreationTimestamp: now,
				},
			},
			ing2: &networkingv1.Ingress{
				ObjectMeta: metav1.ObjectMeta{
					CreationTimestamp: earlier,
				},
			},
			expected: false,
		},
		{
			name: "Same creation time",
			ing1: &networkingv1.Ingress{
				ObjectMeta: metav1.ObjectMeta{
					CreationTimestamp: now,
				},
			},
			ing2: &networkingv1.Ingress{
				ObjectMeta: metav1.ObjectMeta{
					CreationTimestamp: now,
				},
			},
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := lib.IngressLessthan(tt.ing1, tt.ing2)
			if got != tt.expected {
				t.Errorf("IngressLessthan() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestRouteLessthan(t *testing.T) {
	now := metav1.Now()
	earlier := metav1.NewTime(now.Add(-1 * time.Hour))

	tests := []struct {
		name     string
		route1   *routev1.Route
		route2   *routev1.Route
		expected bool
	}{
		{
			name: "route1 created before route2",
			route1: &routev1.Route{
				ObjectMeta: metav1.ObjectMeta{
					CreationTimestamp: earlier,
				},
			},
			route2: &routev1.Route{
				ObjectMeta: metav1.ObjectMeta{
					CreationTimestamp: now,
				},
			},
			expected: true,
		},
		{
			name: "route1 created after route2",
			route1: &routev1.Route{
				ObjectMeta: metav1.ObjectMeta{
					CreationTimestamp: now,
				},
			},
			route2: &routev1.Route{
				ObjectMeta: metav1.ObjectMeta{
					CreationTimestamp: earlier,
				},
			},
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := lib.RouteLessthan(tt.route1, tt.route2)
			if got != tt.expected {
				t.Errorf("RouteLessthan() = %v, want %v", got, tt.expected)
			}
		})
	}
}
