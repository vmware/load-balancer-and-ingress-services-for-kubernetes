/*
 * Copyright Â© 2025 Broadcom Inc. and/or its subsidiaries. All Rights Reserved.
 * All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// @AI-Generated
// [Generated by Cursor claude-4-sonnet]

package miscellaneous

import (
	"testing"

	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/cache"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/lib"
)

// Integration tests for AviObjCache - testing cache operations without external dependencies

// TestIntegrationCachePopulationAndRetrieval tests the complete flow of adding and retrieving cache entries
func TestIntegrationCachePopulationAndRetrieval(t *testing.T) {
	objCache := cache.NewAviObjCache()

	// Test Pool Cache population
	t.Run("PoolCache", func(t *testing.T) {
		poolKey := cache.NamespaceName{Namespace: "admin", Name: "test-pool"}
		poolData := &cache.AviPoolCache{
			Name:             "test-pool",
			Tenant:           "admin",
			Uuid:             "pool-uuid-1",
			CloudConfigCksum: "checksum1",
			ServiceMetadataObj: lib.ServiceMetadataObj{
				NamespaceIngressName: []string{"default/ingress1"},
			},
		}

		objCache.PoolCache.AviCacheAdd(poolKey, poolData)

		// Retrieve and verify
		retrieved, found := objCache.PoolCache.AviCacheGet(poolKey)
		if !found {
			t.Fatal("Pool not found in cache")
		}

		poolCache := retrieved.(*cache.AviPoolCache)
		if poolCache.Name != "test-pool" {
			t.Errorf("Expected name 'test-pool', got '%s'", poolCache.Name)
		}
		if poolCache.Uuid != "pool-uuid-1" {
			t.Errorf("Expected UUID 'pool-uuid-1', got '%s'", poolCache.Uuid)
		}
	})

	// Test Pool Group Cache population
	t.Run("PoolGroupCache", func(t *testing.T) {
		pgKey := cache.NamespaceName{Namespace: "admin", Name: "test-pg"}
		pgData := &cache.AviPGCache{
			Name:             "test-pg",
			Tenant:           "admin",
			Uuid:             "pg-uuid-1",
			CloudConfigCksum: "checksum1",
			Members:          []string{"pool1", "pool2"},
		}

		objCache.PgCache.AviCacheAdd(pgKey, pgData)

		// Retrieve and verify
		retrieved, found := objCache.PgCache.AviCacheGet(pgKey)
		if !found {
			t.Fatal("Pool group not found in cache")
		}

		pgCache := retrieved.(*cache.AviPGCache)
		if pgCache.Name != "test-pg" {
			t.Errorf("Expected name 'test-pg', got '%s'", pgCache.Name)
		}
		if len(pgCache.Members) != 2 {
			t.Errorf("Expected 2 members, got %d", len(pgCache.Members))
		}
	})

	// Test VSVIP Cache population
	t.Run("VSVIPCache", func(t *testing.T) {
		vsvipKey := cache.NamespaceName{Namespace: "admin", Name: "test-vsvip"}
		vsvipData := &cache.AviVSVIPCache{
			Name:             "test-vsvip",
			Tenant:           "admin",
			Uuid:             "vsvip-uuid-1",
			FQDNs:            []string{"test.example.com", "test2.example.com"},
			Vips:             []string{"10.0.0.1", "10.0.0.2"},
			V6IPs:            []string{"2001:db8::1"},
			CloudConfigCksum: "checksum1",
		}

		objCache.VSVIPCache.AviCacheAdd(vsvipKey, vsvipData)

		// Retrieve and verify
		retrieved, found := objCache.VSVIPCache.AviCacheGet(vsvipKey)
		if !found {
			t.Fatal("VSVIP not found in cache")
		}

		vsvipCache := retrieved.(*cache.AviVSVIPCache)
		if vsvipCache.Name != "test-vsvip" {
			t.Errorf("Expected name 'test-vsvip', got '%s'", vsvipCache.Name)
		}
		if len(vsvipCache.FQDNs) != 2 {
			t.Errorf("Expected 2 FQDNs, got %d", len(vsvipCache.FQDNs))
		}
		if len(vsvipCache.Vips) != 2 {
			t.Errorf("Expected 2 VIPs, got %d", len(vsvipCache.Vips))
		}
	})

	// Test SSL Key Cache population
	t.Run("SSLKeyCache", func(t *testing.T) {
		sslKey := cache.NamespaceName{Namespace: "admin", Name: "test-ssl"}
		sslData := &cache.AviSSLCache{
			Name:   "test-ssl",
			Tenant: "admin",
			Uuid:   "ssl-uuid-1",
			Cert:   "-----BEGIN CERTIFICATE-----\nMIIC...",
		}

		objCache.SSLKeyCache.AviCacheAdd(sslKey, sslData)

		// Retrieve and verify
		retrieved, found := objCache.SSLKeyCache.AviCacheGet(sslKey)
		if !found {
			t.Fatal("SSL key not found in cache")
		}

		sslCache := retrieved.(*cache.AviSSLCache)
		if sslCache.Name != "test-ssl" {
			t.Errorf("Expected name 'test-ssl', got '%s'", sslCache.Name)
		}
	})

	// Test HTTP Policy Cache population
	t.Run("HTTPPolicyCache", func(t *testing.T) {
		httpKey := cache.NamespaceName{Namespace: "admin", Name: "test-http-policy"}
		httpData := &cache.AviHTTPPolicyCache{
			Name:             "test-http-policy",
			Tenant:           "admin",
			Uuid:             "http-uuid-1",
			CloudConfigCksum: "checksum1",
			PoolGroups:       []string{"pg1", "pg2"},
		}

		objCache.HTTPPolicyCache.AviCacheAdd(httpKey, httpData)

		// Retrieve and verify
		retrieved, found := objCache.HTTPPolicyCache.AviCacheGet(httpKey)
		if !found {
			t.Fatal("HTTP policy not found in cache")
		}

		httpCache := retrieved.(*cache.AviHTTPPolicyCache)
		if httpCache.Name != "test-http-policy" {
			t.Errorf("Expected name 'test-http-policy', got '%s'", httpCache.Name)
		}
		if len(httpCache.PoolGroups) != 2 {
			t.Errorf("Expected 2 pool groups, got %d", len(httpCache.PoolGroups))
		}
	})

	// Test L4 Policy Cache population
	t.Run("L4PolicyCache", func(t *testing.T) {
		l4Key := cache.NamespaceName{Namespace: "admin", Name: "test-l4-policy"}
		l4Data := &cache.AviL4PolicyCache{
			Name:   "test-l4-policy",
			Tenant: "admin",
			Uuid:   "l4-uuid-1",
			Pools:  []string{"pool1", "pool2"},
		}

		objCache.L4PolicyCache.AviCacheAdd(l4Key, l4Data)

		// Retrieve and verify
		retrieved, found := objCache.L4PolicyCache.AviCacheGet(l4Key)
		if !found {
			t.Fatal("L4 policy not found in cache")
		}

		l4Cache := retrieved.(*cache.AviL4PolicyCache)
		if l4Cache.Name != "test-l4-policy" {
			t.Errorf("Expected name 'test-l4-policy', got '%s'", l4Cache.Name)
		}
		if len(l4Cache.Pools) != 2 {
			t.Errorf("Expected 2 pools, got %d", len(l4Cache.Pools))
		}
	})

	// Test DataScript Cache population
	t.Run("DataScriptCache", func(t *testing.T) {
		dsKey := cache.NamespaceName{Namespace: "admin", Name: "test-ds"}
		dsData := &cache.AviDSCache{
			Name:       "test-ds",
			Tenant:     "admin",
			Uuid:       "ds-uuid-1",
			PoolGroups: []string{"pg1"},
		}

		objCache.DSCache.AviCacheAdd(dsKey, dsData)

		// Retrieve and verify
		retrieved, found := objCache.DSCache.AviCacheGet(dsKey)
		if !found {
			t.Fatal("DataScript not found in cache")
		}

		dsCache := retrieved.(*cache.AviDSCache)
		if dsCache.Name != "test-ds" {
			t.Errorf("Expected name 'test-ds', got '%s'", dsCache.Name)
		}
	})

	// Test String Group Cache population
	t.Run("StringGroupCache", func(t *testing.T) {
		sgKey := cache.NamespaceName{Namespace: "admin", Name: "test-sg"}
		sgData := &cache.AviStringGroupCache{
			Name:   "test-sg",
			Tenant: "admin",
			Uuid:   "sg-uuid-1",
		}

		objCache.StringGroupCache.AviCacheAdd(sgKey, sgData)

		// Retrieve and verify
		retrieved, found := objCache.StringGroupCache.AviCacheGet(sgKey)
		if !found {
			t.Fatal("String group not found in cache")
		}

		sgCache := retrieved.(*cache.AviStringGroupCache)
		if sgCache.Name != "test-sg" {
			t.Errorf("Expected name 'test-sg', got '%s'", sgCache.Name)
		}
	})

	// Test PKI Profile Cache population
	t.Run("PKIProfileCache", func(t *testing.T) {
		pkiKey := cache.NamespaceName{Namespace: "admin", Name: "test-pki"}
		pkiData := &cache.AviPkiProfileCache{
			Name:   "test-pki",
			Tenant: "admin",
			Uuid:   "pki-uuid-1",
		}

		objCache.PKIProfileCache.AviCacheAdd(pkiKey, pkiData)

		// Retrieve and verify
		retrieved, found := objCache.PKIProfileCache.AviCacheGet(pkiKey)
		if !found {
			t.Fatal("PKI profile not found in cache")
		}

		pkiCache := retrieved.(*cache.AviPkiProfileCache)
		if pkiCache.Name != "test-pki" {
			t.Errorf("Expected name 'test-pki', got '%s'", pkiCache.Name)
		}
	})

	// Test VRF Cache population
	t.Run("VRFCache", func(t *testing.T) {
		vrfData := &cache.AviVrfCache{
			Name: "global",
			Uuid: "vrf-uuid-1",
		}

		objCache.VrfCache.AviCacheAdd("global", vrfData)

		// Retrieve and verify
		retrieved, found := objCache.VrfCache.AviCacheGet("global")
		if !found {
			t.Fatal("VRF not found in cache")
		}

		vrfCache := retrieved.(*cache.AviVrfCache)
		if vrfCache.Name != "global" {
			t.Errorf("Expected name 'global', got '%s'", vrfCache.Name)
		}
	})
}

// TestIntegrationCacheInvalidationFlow tests marking objects as invalid and cleanup
func TestIntegrationCacheInvalidationFlow(t *testing.T) {
	objCache := cache.NewAviObjCache()

	// Populate multiple pools
	for i := 1; i <= 5; i++ {
		poolKey := cache.NamespaceName{Namespace: "admin", Name: "pool" + string(rune('0'+i))}
		poolData := &cache.AviPoolCache{
			Name:        "pool" + string(rune('0'+i)),
			Tenant:      "admin",
			Uuid:        "pool-uuid-" + string(rune('0'+i)),
			InvalidData: false,
		}
		objCache.PoolCache.AviCacheAdd(poolKey, poolData)
	}

	// Mark all as invalid initially
	allKeys := objCache.PoolCache.AviGetAllKeys()
	if len(allKeys) != 5 {
		t.Fatalf("Expected 5 pools, got %d", len(allKeys))
	}

	for _, key := range allKeys {
		pool, _ := objCache.PoolCache.AviCacheGet(key)
		poolCache := pool.(*cache.AviPoolCache)
		poolCache.InvalidData = true
		objCache.PoolCache.AviCacheAdd(key, poolCache)
	}

	// Mark some as valid (simulate they still exist in controller)
	validPools := []string{"pool1", "pool2", "pool3"}
	for _, poolName := range validPools {
		poolKey := cache.NamespaceName{Namespace: "admin", Name: poolName}
		pool, found := objCache.PoolCache.AviCacheGet(poolKey)
		if found {
			poolCache := pool.(*cache.AviPoolCache)
			poolCache.InvalidData = false
			objCache.PoolCache.AviCacheAdd(poolKey, poolCache)
		}
	}

	// Delete unmarked (invalid) objects manually
	for _, key := range objCache.PoolCache.AviGetAllKeys() {
		pool, _ := objCache.PoolCache.AviCacheGet(key)
		poolCache := pool.(*cache.AviPoolCache)
		if poolCache.InvalidData {
			objCache.PoolCache.AviCacheDelete(key)
		}
	}

	// Verify only valid pools remain
	remainingKeys := objCache.PoolCache.AviGetAllKeys()
	if len(remainingKeys) != 3 {
		t.Errorf("Expected 3 pools after cleanup, got %d", len(remainingKeys))
	}

	// Verify the correct pools remain
	for _, poolName := range validPools {
		poolKey := cache.NamespaceName{Namespace: "admin", Name: poolName}
		_, found := objCache.PoolCache.AviCacheGet(poolKey)
		if !found {
			t.Errorf("Valid pool %s was incorrectly deleted", poolName)
		}
	}
}

// TestIntegrationReferenceMarking tests the reference marking functionality
func TestIntegrationReferenceMarking(t *testing.T) {
	objCache := cache.NewAviObjCache()

	// Setup pools
	pool1Key := cache.NamespaceName{Namespace: "admin", Name: "pool1"}
	objCache.PoolCache.AviCacheAdd(pool1Key, &cache.AviPoolCache{
		Name:   "pool1",
		Tenant: "admin",
		Uuid:   "pool-uuid-1",
	})

	pool2Key := cache.NamespaceName{Namespace: "admin", Name: "pool2"}
	objCache.PoolCache.AviCacheAdd(pool2Key, &cache.AviPoolCache{
		Name:   "pool2",
		Tenant: "admin",
		Uuid:   "pool-uuid-2",
	})

	// Setup pool groups referencing pools
	pg1Key := cache.NamespaceName{Namespace: "admin", Name: "pg1"}
	objCache.PgCache.AviCacheAdd(pg1Key, &cache.AviPGCache{
		Name:    "pg1",
		Tenant:  "admin",
		Uuid:    "pg-uuid-1",
		Members: []string{"pool1"},
	})

	// Setup HTTP policy referencing pool group
	httpKey := cache.NamespaceName{Namespace: "admin", Name: "http-policy-1"}
	objCache.HTTPPolicyCache.AviCacheAdd(httpKey, &cache.AviHTTPPolicyCache{
		Name:       "http-policy-1",
		Tenant:     "admin",
		Uuid:       "http-uuid-1",
		PoolGroups: []string{"pg1"},
	})

	// Setup VS referencing HTTP policy
	vsKey := cache.NamespaceName{Namespace: "admin", Name: "vs1"}
	vsData := &cache.AviVsCache{
		Name:              "vs1",
		Tenant:            "admin",
		Uuid:              "vs-uuid-1",
		HTTPKeyCollection: []cache.NamespaceName{httpKey},
		PoolKeyCollection: []cache.NamespaceName{pool2Key},
	}
	objCache.VsCacheMeta.AviCacheAdd(vsKey, vsData)

	// Mark references from VS
	objCache.MarkReference(vsData)

	// Verify pool2 is marked as referenced (directly by VS)
	pool2, _ := objCache.PoolCache.AviCacheGet(pool2Key)
	pool2Cache := pool2.(*cache.AviPoolCache)
	if pool2Cache.InvalidData {
		t.Error("Pool2 should be marked as valid (referenced by VS)")
	}

	// Verify HTTP policy is marked as referenced
	http, _ := objCache.HTTPPolicyCache.AviCacheGet(httpKey)
	httpCache := http.(*cache.AviHTTPPolicyCache)
	if httpCache.InvalidData {
		t.Error("HTTP policy should be marked as valid (referenced by VS)")
	}

	// Verify pool group is marked as referenced (through HTTP policy)
	pg1, _ := objCache.PgCache.AviCacheGet(pg1Key)
	pg1Cache := pg1.(*cache.AviPGCache)
	if pg1Cache.InvalidData {
		t.Error("Pool group should be marked as valid (referenced by HTTP policy)")
	}

	// Verify pool1 is marked as referenced (through pool group)
	pool1, _ := objCache.PoolCache.AviCacheGet(pool1Key)
	pool1Cache := pool1.(*cache.AviPoolCache)
	if pool1Cache.InvalidData {
		t.Error("Pool1 should be marked as valid (referenced by pool group)")
	}
}

// TestIntegrationVSCacheOperations tests Virtual Service cache operations
func TestIntegrationVSCacheOperations(t *testing.T) {
	objCache := cache.NewAviObjCache()

	// Test VsCacheMeta operations
	t.Run("VsCacheMeta", func(t *testing.T) {
		vsKey := cache.NamespaceName{Namespace: "admin", Name: "test-vs"}
		vsData := &cache.AviVsCache{
			Name:             "test-vs",
			Tenant:           "admin",
			Uuid:             "vs-uuid-1",
			CloudConfigCksum: "checksum1",
			ServiceMetadataObj: lib.ServiceMetadataObj{
				NamespaceIngressName: []string{"default/ingress1"},
				HostNames:            []string{"test.example.com"},
			},
			SNIChildCollection: []string{"vs-child-1", "vs-child-2"},
		}

		objCache.VsCacheMeta.AviCacheAdd(vsKey, vsData)

		// Retrieve and verify
		retrieved, found := objCache.VsCacheMeta.AviCacheGet(vsKey)
		if !found {
			t.Fatal("VS not found in VsCacheMeta")
		}

		vsCache := retrieved.(*cache.AviVsCache)
		if vsCache.Name != "test-vs" {
			t.Errorf("Expected name 'test-vs', got '%s'", vsCache.Name)
		}
		if len(vsCache.SNIChildCollection) != 2 {
			t.Errorf("Expected 2 SNI children, got %d", len(vsCache.SNIChildCollection))
		}
	})

	// Test VsCacheLocal operations
	t.Run("VsCacheLocal", func(t *testing.T) {
		vsKey := cache.NamespaceName{Namespace: "red", Name: "test-vs-local"}
		vsData := &cache.AviVsCache{
			Name:   "test-vs-local",
			Tenant: "red",
			Uuid:   "vs-uuid-local-1",
		}

		objCache.VsCacheLocal.AviCacheAdd(vsKey, vsData)

		// Retrieve and verify
		retrieved, found := objCache.VsCacheLocal.AviCacheGet(vsKey)
		if !found {
			t.Fatal("VS not found in VsCacheLocal")
		}

		vsCache := retrieved.(*cache.AviVsCache)
		if vsCache.Name != "test-vs-local" {
			t.Errorf("Expected name 'test-vs-local', got '%s'", vsCache.Name)
		}
	})
}

// TestIntegrationMultiTenantCache tests cache operations across multiple tenants
func TestIntegrationMultiTenantCache(t *testing.T) {
	objCache := cache.NewAviObjCache()

	tenants := []string{"admin", "tenant1", "tenant2"}

	// Add pools for each tenant
	for _, tenant := range tenants {
		for i := 1; i <= 3; i++ {
			poolKey := cache.NamespaceName{
				Namespace: tenant,
				Name:      "pool" + string(rune('0'+i)),
			}
			poolData := &cache.AviPoolCache{
				Name:   "pool" + string(rune('0'+i)),
				Tenant: tenant,
				Uuid:   tenant + "-pool-uuid-" + string(rune('0'+i)),
			}
			objCache.PoolCache.AviCacheAdd(poolKey, poolData)
		}
	}

	// Verify all pools are cached
	allKeys := objCache.PoolCache.AviGetAllKeys()
	expectedCount := len(tenants) * 3
	if len(allKeys) != expectedCount {
		t.Errorf("Expected %d pools, got %d", expectedCount, len(allKeys))
	}

	// Verify tenant isolation
	for _, tenant := range tenants {
		for i := 1; i <= 3; i++ {
			poolKey := cache.NamespaceName{
				Namespace: tenant,
				Name:      "pool" + string(rune('0'+i)),
			}
			pool, found := objCache.PoolCache.AviCacheGet(poolKey)
			if !found {
				t.Errorf("Pool not found for tenant %s", tenant)
				continue
			}

			poolCache := pool.(*cache.AviPoolCache)
			if poolCache.Tenant != tenant {
				t.Errorf("Expected tenant '%s', got '%s'", tenant, poolCache.Tenant)
			}
		}
	}
}

// TestIntegrationCacheUpdateOperations tests updating existing cache entries
func TestIntegrationCacheUpdateOperations(t *testing.T) {
	objCache := cache.NewAviObjCache()

	poolKey := cache.NamespaceName{Namespace: "admin", Name: "test-pool"}

	// Add initial pool
	initialPool := &cache.AviPoolCache{
		Name:             "test-pool",
		Tenant:           "admin",
		Uuid:             "pool-uuid-1",
		CloudConfigCksum: "checksum1",
	}
	objCache.PoolCache.AviCacheAdd(poolKey, initialPool)

	// Update pool
	updatedPool := &cache.AviPoolCache{
		Name:             "test-pool",
		Tenant:           "admin",
		Uuid:             "pool-uuid-1",
		CloudConfigCksum: "checksum2", // Changed
	}
	objCache.PoolCache.AviCacheAdd(poolKey, updatedPool)

	// Verify update
	retrieved, found := objCache.PoolCache.AviCacheGet(poolKey)
	if !found {
		t.Fatal("Pool not found after update")
	}

	poolCache := retrieved.(*cache.AviPoolCache)
	if poolCache.CloudConfigCksum != "checksum2" {
		t.Errorf("Expected checksum 'checksum2', got '%s'", poolCache.CloudConfigCksum)
	}
}

// TestIntegrationCacheDeletionOperations tests deleting cache entries
func TestIntegrationCacheDeletionOperations(t *testing.T) {
	objCache := cache.NewAviObjCache()

	// Add multiple pools
	for i := 1; i <= 5; i++ {
		poolKey := cache.NamespaceName{Namespace: "admin", Name: "pool" + string(rune('0'+i))}
		poolData := &cache.AviPoolCache{
			Name:   "pool" + string(rune('0'+i)),
			Tenant: "admin",
			Uuid:   "pool-uuid-" + string(rune('0'+i)),
		}
		objCache.PoolCache.AviCacheAdd(poolKey, poolData)
	}

	// Verify all added
	if len(objCache.PoolCache.AviGetAllKeys()) != 5 {
		t.Fatal("Not all pools were added")
	}

	// Delete one pool
	deleteKey := cache.NamespaceName{Namespace: "admin", Name: "pool3"}
	objCache.PoolCache.AviCacheDelete(deleteKey)

	// Verify deletion
	_, found := objCache.PoolCache.AviCacheGet(deleteKey)
	if found {
		t.Error("Pool should have been deleted")
	}

	// Verify others remain
	if len(objCache.PoolCache.AviGetAllKeys()) != 4 {
		t.Errorf("Expected 4 pools after deletion, got %d", len(objCache.PoolCache.AviGetAllKeys()))
	}
}

// TestIntegrationComplexCacheScenario tests a complex multi-object cache scenario
func TestIntegrationComplexCacheScenario(t *testing.T) {
	objCache := cache.NewAviObjCache()

	// Scenario: Create a complete VS with all dependencies

	// 1. Create pools
	pool1Key := cache.NamespaceName{Namespace: "admin", Name: "app-pool-1"}
	objCache.PoolCache.AviCacheAdd(pool1Key, &cache.AviPoolCache{
		Name:   "app-pool-1",
		Tenant: "admin",
		Uuid:   "pool-uuid-1",
	})

	pool2Key := cache.NamespaceName{Namespace: "admin", Name: "app-pool-2"}
	objCache.PoolCache.AviCacheAdd(pool2Key, &cache.AviPoolCache{
		Name:   "app-pool-2",
		Tenant: "admin",
		Uuid:   "pool-uuid-2",
	})

	// 2. Create pool groups
	pg1Key := cache.NamespaceName{Namespace: "admin", Name: "app-pg-1"}
	objCache.PgCache.AviCacheAdd(pg1Key, &cache.AviPGCache{
		Name:    "app-pg-1",
		Tenant:  "admin",
		Uuid:    "pg-uuid-1",
		Members: []string{"app-pool-1"},
	})

	// 3. Create HTTP policy
	httpKey := cache.NamespaceName{Namespace: "admin", Name: "app-http-policy"}
	objCache.HTTPPolicyCache.AviCacheAdd(httpKey, &cache.AviHTTPPolicyCache{
		Name:       "app-http-policy",
		Tenant:     "admin",
		Uuid:       "http-uuid-1",
		PoolGroups: []string{"app-pg-1"},
	})

	// 4. Create SSL key
	sslKey := cache.NamespaceName{Namespace: "admin", Name: "app-ssl"}
	objCache.SSLKeyCache.AviCacheAdd(sslKey, &cache.AviSSLCache{
		Name:   "app-ssl",
		Tenant: "admin",
		Uuid:   "ssl-uuid-1",
	})

	// 5. Create VSVIP
	vsvipKey := cache.NamespaceName{Namespace: "admin", Name: "app-vsvip"}
	objCache.VSVIPCache.AviCacheAdd(vsvipKey, &cache.AviVSVIPCache{
		Name:   "app-vsvip",
		Tenant: "admin",
		Uuid:   "vsvip-uuid-1",
		FQDNs:  []string{"app.example.com"},
		Vips:   []string{"10.0.0.100"},
	})

	// 6. Create VS
	vsKey := cache.NamespaceName{Namespace: "admin", Name: "app-vs"}
	vsData := &cache.AviVsCache{
		Name:                 "app-vs",
		Tenant:               "admin",
		Uuid:                 "vs-uuid-1",
		HTTPKeyCollection:    []cache.NamespaceName{httpKey},
		PoolKeyCollection:    []cache.NamespaceName{pool2Key},
		SSLKeyCertCollection: []cache.NamespaceName{sslKey},
		VSVipKeyCollection:   []cache.NamespaceName{vsvipKey},
		ServiceMetadataObj: lib.ServiceMetadataObj{
			HostNames:            []string{"app.example.com"},
			NamespaceIngressName: []string{"production/app-ingress"},
		},
	}
	objCache.VsCacheMeta.AviCacheAdd(vsKey, vsData)

	// Verify all objects are cached
	t.Run("VerifyAllObjectsCached", func(t *testing.T) {
		if len(objCache.PoolCache.AviGetAllKeys()) != 2 {
			t.Errorf("Expected 2 pools, got %d", len(objCache.PoolCache.AviGetAllKeys()))
		}
		if len(objCache.PgCache.AviGetAllKeys()) != 1 {
			t.Errorf("Expected 1 pool group, got %d", len(objCache.PgCache.AviGetAllKeys()))
		}
		if len(objCache.HTTPPolicyCache.AviGetAllKeys()) != 1 {
			t.Errorf("Expected 1 HTTP policy, got %d", len(objCache.HTTPPolicyCache.AviGetAllKeys()))
		}
		if len(objCache.SSLKeyCache.AviGetAllKeys()) != 1 {
			t.Errorf("Expected 1 SSL key, got %d", len(objCache.SSLKeyCache.AviGetAllKeys()))
		}
		if len(objCache.VSVIPCache.AviGetAllKeys()) != 1 {
			t.Errorf("Expected 1 VSVIP, got %d", len(objCache.VSVIPCache.AviGetAllKeys()))
		}
		if len(objCache.VsCacheMeta.AviGetAllKeys()) != 1 {
			t.Errorf("Expected 1 VS, got %d", len(objCache.VsCacheMeta.AviGetAllKeys()))
		}
	})

	// Test reference marking
	t.Run("VerifyReferenceMarking", func(t *testing.T) {
		objCache.MarkReference(vsData)

		// All referenced objects should be marked as valid
		pool1, _ := objCache.PoolCache.AviCacheGet(pool1Key)
		if pool1.(*cache.AviPoolCache).InvalidData {
			t.Error("Pool1 should be marked as valid")
		}

		pool2, _ := objCache.PoolCache.AviCacheGet(pool2Key)
		if pool2.(*cache.AviPoolCache).InvalidData {
			t.Error("Pool2 should be marked as valid")
		}

		pg1, _ := objCache.PgCache.AviCacheGet(pg1Key)
		if pg1.(*cache.AviPGCache).InvalidData {
			t.Error("Pool group should be marked as valid")
		}

		http, _ := objCache.HTTPPolicyCache.AviCacheGet(httpKey)
		if http.(*cache.AviHTTPPolicyCache).InvalidData {
			t.Error("HTTP policy should be marked as valid")
		}
	})
}

// TestIntegrationCacheCleanupFlow tests the complete cleanup flow
func TestIntegrationCacheCleanupFlow(t *testing.T) {
	objCache := cache.NewAviObjCache()

	// Setup: Create VS with dependencies
	pool1Key := cache.NamespaceName{Namespace: "admin", Name: "pool1"}
	objCache.PoolCache.AviCacheAdd(pool1Key, &cache.AviPoolCache{
		Name:         "pool1",
		Tenant:       "admin",
		Uuid:         "pool-uuid-1",
		HasReference: false,
	})

	pool2Key := cache.NamespaceName{Namespace: "admin", Name: "pool2"}
	objCache.PoolCache.AviCacheAdd(pool2Key, &cache.AviPoolCache{
		Name:         "pool2",
		Tenant:       "admin",
		Uuid:         "pool-uuid-2",
		HasReference: false,
	})

	// pool3 is not referenced by any VS
	pool3Key := cache.NamespaceName{Namespace: "admin", Name: "pool3"}
	objCache.PoolCache.AviCacheAdd(pool3Key, &cache.AviPoolCache{
		Name:         "pool3",
		Tenant:       "admin",
		Uuid:         "pool-uuid-3",
		HasReference: false,
	})

	vsKey := cache.NamespaceName{Namespace: "admin", Name: "vs1"}
	vsData := &cache.AviVsCache{
		Name:              "vs1",
		Tenant:            "admin",
		Uuid:              "vs-uuid-1",
		PoolKeyCollection: []cache.NamespaceName{pool1Key, pool2Key},
	}
	objCache.VsCacheMeta.AviCacheAdd(vsKey, vsData)

	// Mark references from VS (this should mark pool1 and pool2 with HasReference=true)
	objCache.MarkReference(vsData)

	// Delete objects without references
	for _, key := range objCache.PoolCache.AviGetAllKeys() {
		pool, _ := objCache.PoolCache.AviCacheGet(key)
		poolCache := pool.(*cache.AviPoolCache)
		if !poolCache.HasReference {
			objCache.PoolCache.AviCacheDelete(key)
		}
	}

	// Verify only referenced pools remain
	remainingKeys := objCache.PoolCache.AviGetAllKeys()
	if len(remainingKeys) != 2 {
		t.Errorf("Expected 2 pools after cleanup, got %d", len(remainingKeys))
	}

	// Verify pool1 and pool2 remain
	_, found1 := objCache.PoolCache.AviCacheGet(pool1Key)
	if !found1 {
		t.Error("Pool1 should still exist")
	}

	_, found2 := objCache.PoolCache.AviCacheGet(pool2Key)
	if !found2 {
		t.Error("Pool2 should still exist")
	}

	// Verify pool3 was deleted
	_, found3 := objCache.PoolCache.AviCacheGet(pool3Key)
	if found3 {
		t.Error("Pool3 should have been deleted (not referenced)")
	}
}

// TestIntegrationCacheConcurrency tests concurrent access to cache
func TestIntegrationCacheConcurrency(t *testing.T) {
	objCache := cache.NewAviObjCache()

	// Concurrent writes
	done := make(chan bool)
	for i := 0; i < 10; i++ {
		go func(id int) {
			poolKey := cache.NamespaceName{Namespace: "admin", Name: "pool" + string(rune('0'+id))}
			poolData := &cache.AviPoolCache{
				Name:   "pool" + string(rune('0'+id)),
				Tenant: "admin",
				Uuid:   "pool-uuid-" + string(rune('0'+id)),
			}
			objCache.PoolCache.AviCacheAdd(poolKey, poolData)
			done <- true
		}(i)
	}

	// Wait for all goroutines
	for i := 0; i < 10; i++ {
		<-done
	}

	// Verify all pools were added
	allKeys := objCache.PoolCache.AviGetAllKeys()
	if len(allKeys) != 10 {
		t.Errorf("Expected 10 pools, got %d", len(allKeys))
	}
}
