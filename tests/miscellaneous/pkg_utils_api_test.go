/*
 * Copyright Â© 2025 Broadcom Inc. and/or its subsidiaries. All Rights Reserved.
 * All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// @AI-Generated
// [Generated by Cursor claude-4-sonnet]

package miscellaneous

import (
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/utils"
)

func TestRespond(t *testing.T) {
	tests := []struct {
		name         string
		data         interface{}
		expectedJSON string
		expectedCode int
	}{
		{
			name:         "Simple map response",
			data:         map[string]string{"status": "ok", "message": "success"},
			expectedJSON: `{"status":"ok","message":"success"}`,
			expectedCode: http.StatusOK,
		},
		{
			name:         "String response",
			data:         "test response",
			expectedJSON: `"test response"`,
			expectedCode: http.StatusOK,
		},
		{
			name:         "Integer response",
			data:         42,
			expectedJSON: `42`,
			expectedCode: http.StatusOK,
		},
		{
			name:         "Slice response",
			data:         []string{"item1", "item2", "item3"},
			expectedJSON: `["item1","item2","item3"]`,
			expectedCode: http.StatusOK,
		},
		{
			name:         "Nil response",
			data:         nil,
			expectedJSON: `null`,
			expectedCode: http.StatusOK,
		},
		{
			name: "Nested struct response",
			data: struct {
				Name  string
				Value int
				Tags  []string
			}{
				Name:  "test",
				Value: 100,
				Tags:  []string{"tag1", "tag2"},
			},
			expectedJSON: `{"Name":"test","Value":100,"Tags":["tag1","tag2"]}`,
			expectedCode: http.StatusOK,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create a response recorder
			w := httptest.NewRecorder()

			// Call Respond
			utils.Respond(w, tt.data)

			// Check status code
			if w.Code != tt.expectedCode {
				t.Errorf("Respond() status code = %v, want %v", w.Code, tt.expectedCode)
			}

			// Check Content-Type header
			contentType := w.Header().Get("Content-Type")
			if contentType != "application/json" {
				t.Errorf("Respond() Content-Type = %v, want application/json", contentType)
			}

			// Check response body
			var got interface{}
			var expected interface{}

			if err := json.Unmarshal(w.Body.Bytes(), &got); err != nil {
				t.Fatalf("Failed to unmarshal response body: %v", err)
			}

			if err := json.Unmarshal([]byte(tt.expectedJSON), &expected); err != nil {
				t.Fatalf("Failed to unmarshal expected JSON: %v", err)
			}

			gotJSON, _ := json.Marshal(got)
			expectedJSON, _ := json.Marshal(expected)

			if string(gotJSON) != string(expectedJSON) {
				t.Errorf("Respond() body = %v, want %v", string(gotJSON), string(expectedJSON))
			}
		})
	}
}

func TestLogApi(t *testing.T) {
	tests := []struct {
		name           string
		method         string
		requestURI     string
		expectedStatus int
	}{
		{
			name:           "GET request",
			method:         http.MethodGet,
			requestURI:     "/api/status",
			expectedStatus: http.StatusOK,
		},
		{
			name:           "POST request",
			method:         http.MethodPost,
			requestURI:     "/api/create",
			expectedStatus: http.StatusOK,
		},
		{
			name:           "PUT request",
			method:         http.MethodPut,
			requestURI:     "/api/update",
			expectedStatus: http.StatusOK,
		},
		{
			name:           "DELETE request",
			method:         http.MethodDelete,
			requestURI:     "/api/delete",
			expectedStatus: http.StatusOK,
		},
		{
			name:           "Request with query params",
			method:         http.MethodGet,
			requestURI:     "/api/search?query=test&limit=10",
			expectedStatus: http.StatusOK,
		},
		{
			name:           "Request with path params",
			method:         http.MethodGet,
			requestURI:     "/api/users/123/profile",
			expectedStatus: http.StatusOK,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create a test handler that returns OK
			testHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				w.WriteHeader(tt.expectedStatus)
			})

			// Wrap with LogApi middleware
			handler := utils.LogApi(testHandler)

			// Create request
			req := httptest.NewRequest(tt.method, tt.requestURI, nil)
			w := httptest.NewRecorder()

			// Execute request
			handler.ServeHTTP(w, req)

			// Verify status code
			if w.Code != tt.expectedStatus {
				t.Errorf("LogApi() status code = %v, want %v", w.Code, tt.expectedStatus)
			}
		})
	}
}

func TestLogApiMiddlewareChaining(t *testing.T) {
	// Test that LogApi properly chains with other handlers
	var handlerCalled bool

	testHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		handlerCalled = true
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("success"))
	})

	handler := utils.LogApi(testHandler)

	req := httptest.NewRequest(http.MethodGet, "/test", nil)
	w := httptest.NewRecorder()

	handler.ServeHTTP(w, req)

	if !handlerCalled {
		t.Error("LogApi() did not call the next handler")
	}

	if w.Code != http.StatusOK {
		t.Errorf("LogApi() status code = %v, want %v", w.Code, http.StatusOK)
	}

	if w.Body.String() != "success" {
		t.Errorf("LogApi() body = %v, want success", w.Body.String())
	}
}

func TestLogApiWithDifferentStatusCodes(t *testing.T) {
	tests := []struct {
		name       string
		statusCode int
	}{
		{"Status 200 OK", http.StatusOK},
		{"Status 201 Created", http.StatusCreated},
		{"Status 400 Bad Request", http.StatusBadRequest},
		{"Status 404 Not Found", http.StatusNotFound},
		{"Status 500 Internal Server Error", http.StatusInternalServerError},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				w.WriteHeader(tt.statusCode)
			})

			handler := utils.LogApi(testHandler)

			req := httptest.NewRequest(http.MethodGet, "/test", nil)
			w := httptest.NewRecorder()

			handler.ServeHTTP(w, req)

			if w.Code != tt.statusCode {
				t.Errorf("LogApi() status code = %v, want %v", w.Code, tt.statusCode)
			}
		})
	}
}

func TestRespondWithComplexData(t *testing.T) {
	type Address struct {
		Street string
		City   string
		Zip    string
	}

	type User struct {
		ID      int
		Name    string
		Email   string
		Address Address
	}

	user := User{
		ID:    1,
		Name:  "John Doe",
		Email: "john@example.com",
		Address: Address{
			Street: "123 Main St",
			City:   "Springfield",
			Zip:    "12345",
		},
	}

	w := httptest.NewRecorder()
	utils.Respond(w, user)

	if w.Code != http.StatusOK {
		t.Errorf("Respond() status code = %v, want %v", w.Code, http.StatusOK)
	}

	var got User
	if err := json.Unmarshal(w.Body.Bytes(), &got); err != nil {
		t.Fatalf("Failed to unmarshal response: %v", err)
	}

	if got.ID != user.ID || got.Name != user.Name || got.Email != user.Email {
		t.Errorf("Respond() did not correctly encode complex data")
	}

	if got.Address.City != user.Address.City {
		t.Errorf("Respond() did not correctly encode nested struct")
	}
}
