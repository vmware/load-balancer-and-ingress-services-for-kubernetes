/*
 * Copyright Â© 2025 Broadcom Inc. and/or its subsidiaries. All Rights Reserved.
 * All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*   http://www.apache.org/licenses/LICENSE-2.0
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

package status

import (
	"context"
	"encoding/json"
	"fmt"
	"testing"
	"time"

	"github.com/onsi/gomega"
	apimeta "k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"

	akogatewayapilib "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-gateway-api/lib"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/lib"
	tests "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/tests/gatewayapitests"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/tests/integrationtest"
)

// @AI-Generated
// [Generated by Cursor claude-4-sonnet]

/* Positive test cases for Dedicated Gateway Mode
 * - Gateway with valid listeners (no hostname) in dedicated mode
 * - Gateway with TLS listeners in dedicated mode
 * - Gateway transition from normal to dedicated mode
 * - Gateway transition from dedicated to normal mode
 */

func TestDedicatedGatewayWithValidListeners(t *testing.T) {
	gatewayName := "dedicated-gateway-01"
	gatewayClassName := "dedicated-gateway-class-01"
	ports := []int32{8080, 8081}

	tests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	listeners := tests.GetListenersV1(ports, true, false)
	tests.SetupDedicatedGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionProgrammed)) != nil
	}, 40*time.Second).Should(gomega.Equal(true))

	vsUUIDMap := map[string]string{
		"VSUUID": fmt.Sprintf("virtualservice-ako-gw-%s--%s-%s-L7-dedicated-EVH-random-uuid", lib.GetClusterName(), DEFAULT_NAMESPACE, gatewayName),
	}
	messageBytes, err := json.Marshal(vsUUIDMap)
	if err != nil {
		t.Fatalf("Couldn't marshal the vsUUIDMap, err: %+v", err)
	}
	programmedConditionMessage := string(messageBytes)

	expectedStatus := &gatewayv1.GatewayStatus{
		Conditions: []metav1.Condition{
			{
				Type:               string(gatewayv1.GatewayConditionAccepted),
				Status:             metav1.ConditionTrue,
				Message:            "Gateway configuration is valid",
				ObservedGeneration: 1,
				Reason:             string(gatewayv1.GatewayReasonAccepted),
			},
			{
				Type:               string(gatewayv1.GatewayConditionProgrammed),
				Status:             metav1.ConditionTrue,
				Message:            programmedConditionMessage,
				ObservedGeneration: 1,
				Reason:             string(gatewayv1.GatewayReasonProgrammed),
			},
		},
		Listeners: tests.GetListenerStatusV1(ports, []int32{0, 0}, true, true, programmedConditionMessage),
	}

	gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
	if err != nil || gateway == nil {
		t.Fatalf("Couldn't get the gateway, err: %+v", err)
	}

	tests.ValidateGatewayStatus(t, &gateway.Status, expectedStatus)
	tests.TeardownGateway(t, gatewayName, DEFAULT_NAMESPACE)
	tests.TeardownGatewayClass(t, gatewayClassName)
}

func TestDedicatedGatewayWithTLSListeners(t *testing.T) {
	gatewayName := "dedicated-gateway-02"
	gatewayClassName := "dedicated-gateway-class-02"
	ports := []int32{8080, 8081}
	secrets := []string{"dedicated-secret-01"}

	for _, secret := range secrets {
		integrationtest.AddSecret(secret, DEFAULT_NAMESPACE, "cert", "key")
	}

	tests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	listeners := tests.GetListenersV1(ports, true, false, secrets...)
	tests.SetupDedicatedGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	vsUUIDMap := map[string]string{
		"VSUUID": fmt.Sprintf("virtualservice-ako-gw-%s--%s-%s-L7-dedicated-EVH-random-uuid", lib.GetClusterName(), DEFAULT_NAMESPACE, gatewayName),
	}
	messageBytes, err := json.Marshal(vsUUIDMap)
	if err != nil {
		t.Fatalf("Couldn't marshal the vsUUIDMap, err: %+v", err)
	}
	programmedConditionMessage := string(messageBytes)

	expectedStatus := &gatewayv1.GatewayStatus{
		Conditions: []metav1.Condition{
			{
				Type:               string(gatewayv1.GatewayConditionAccepted),
				Status:             metav1.ConditionTrue,
				Message:            "Gateway configuration is valid",
				ObservedGeneration: 1,
				Reason:             string(gatewayv1.GatewayReasonAccepted),
			},
			{
				Type:               string(gatewayv1.GatewayConditionProgrammed),
				Status:             metav1.ConditionTrue,
				Message:            programmedConditionMessage,
				ObservedGeneration: 1,
				Reason:             string(gatewayv1.GatewayReasonProgrammed),
			},
		},
		Listeners: tests.GetListenerStatusV1(ports, []int32{0, 0}, true, false),
	}

	gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
	if err != nil || gateway == nil {
		t.Fatalf("Couldn't get the gateway, err: %+v", err)
	}

	tests.ValidateGatewayStatus(t, &gateway.Status, expectedStatus)
	tests.TeardownGateway(t, gatewayName, DEFAULT_NAMESPACE)
	tests.TeardownGatewayClass(t, gatewayClassName)
	for _, secret := range secrets {
		integrationtest.DeleteSecret(secret, DEFAULT_NAMESPACE)
	}
}

func TestGatewayTransitionFromNormalToDedicatedMode(t *testing.T) {
	gatewayName := "gateway-transition-01"
	gatewayClassName := "gateway-transition-class-01"
	ports := []int32{8080}

	tests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	listeners := tests.GetListenersV1(ports, true, false)
	// First create normal gateway
	tests.SetupGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	// Verify normal gateway is working
	gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
	if err != nil || gateway == nil {
		t.Fatalf("Couldn't get the gateway, err: %+v", err)
	}

	// Transition to dedicated mode
	tests.UpdateDedicatedGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)

	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		// Check that dedicated mode annotation is present
		if annotation, exists := gateway.GetAnnotations()[akogatewayapilib.DedicatedGatewayModeAnnotation]; !exists || annotation != "true" {
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	vsUUIDMap := map[string]string{
		"VSUUID": fmt.Sprintf("virtualservice-ako-gw-%s--%s-%s-L7-dedicated-EVH-random-uuid", lib.GetClusterName(), DEFAULT_NAMESPACE, gatewayName),
	}
	messageBytes, err := json.Marshal(vsUUIDMap)
	if err != nil {
		t.Fatalf("Couldn't marshal the vsUUIDMap, err: %+v", err)
	}
	programmedConditionMessage := string(messageBytes)
	expectedStatus := &gatewayv1.GatewayStatus{
		Conditions: []metav1.Condition{
			{
				Type:               string(gatewayv1.GatewayConditionAccepted),
				Status:             metav1.ConditionTrue,
				Message:            "Gateway configuration is valid",
				ObservedGeneration: 1,
				Reason:             string(gatewayv1.GatewayReasonAccepted),
			},
			{
				Type:               string(gatewayv1.GatewayConditionProgrammed),
				Status:             metav1.ConditionTrue,
				Message:            programmedConditionMessage,
				ObservedGeneration: 1,
				Reason:             string(gatewayv1.GatewayReasonProgrammed),
			},
		},
		Listeners: tests.GetListenerStatusV1(ports, []int32{0}, true, false),
	}

	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Fatalf("Couldn't get the gateway, err: %+v", err)
		}
		return tests.ValidateGatewayStatusWithRetry(t, &gateway.Status, expectedStatus)
	}, 30*time.Second).Should(gomega.Equal(true))

	tests.TeardownGateway(t, gatewayName, DEFAULT_NAMESPACE)
	tests.TeardownGatewayClass(t, gatewayClassName)
}

func TestGatewayTransitionFromDedicatedToNormalMode(t *testing.T) {
	gatewayName := "gateway-transition-02"
	gatewayClassName := "gateway-transition-class-02"
	ports := []int32{8080}

	tests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	listeners := tests.GetListenersV1(ports, true, false)
	// First create dedicated gateway
	tests.SetupDedicatedGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	// Transition to normal mode by removing dedicated annotation
	g2 := &tests.Gateway{}
	g2.Gateway = g2.GatewayV1(gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)
	// Don't add dedicated mode annotation (normal mode)
	g2.Update(t)

	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		// Check that dedicated mode annotation is not present or false
		if annotation, exists := gateway.GetAnnotations()[akogatewayapilib.DedicatedGatewayModeAnnotation]; exists && annotation == "true" {
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	vsUUIDMap := map[string]string{
		"VSUUID": fmt.Sprintf("virtualservice-ako-gw-%s--%s-%s-EVH-random-uuid", lib.GetClusterName(), DEFAULT_NAMESPACE, gatewayName),
	}
	messageBytes, err := json.Marshal(vsUUIDMap)
	if err != nil {
		t.Fatalf("Couldn't marshal the vsUUIDMap, err: %+v", err)
	}
	programmedConditionMessage := string(messageBytes)
	expectedStatus := &gatewayv1.GatewayStatus{
		Conditions: []metav1.Condition{
			{
				Type:               string(gatewayv1.GatewayConditionAccepted),
				Status:             metav1.ConditionTrue,
				Message:            "Gateway configuration is valid",
				ObservedGeneration: 1,
				Reason:             string(gatewayv1.GatewayReasonAccepted),
			},
			{
				Type:               string(gatewayv1.GatewayConditionProgrammed),
				Status:             metav1.ConditionTrue,
				Message:            programmedConditionMessage,
				ObservedGeneration: 1,
				Reason:             string(gatewayv1.GatewayReasonProgrammed),
			},
		},
		Listeners: tests.GetListenerStatusV1(ports, []int32{0}, true, false),
	}

	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Fatalf("Couldn't get the gateway, err: %+v", err)
		}
		return tests.ValidateGatewayStatusWithRetry(t, &gateway.Status, expectedStatus)
	}, 30*time.Second).Should(gomega.Equal(true))

	tests.TeardownGateway(t, gatewayName, DEFAULT_NAMESPACE)
	tests.TeardownGatewayClass(t, gatewayClassName)
}

/* Negative test cases for Dedicated Gateway Mode
 * - Gateway with hostname in listeners (should fail in dedicated mode)
 * - Gateway with AllowedRoutes from all namespaces (should fail in dedicated mode)
 * - Gateway with multiple listeners having different restrictions
 */

func TestDedicatedGatewayWithHostnameInListeners(t *testing.T) {
	gatewayName := "dedicated-gateway-neg-01"
	gatewayClassName := "dedicated-gateway-class-neg-01"
	ports := []int32{8080}

	tests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	listeners := tests.GetListenersV1(ports, true, false)
	// Add hostname to listener (not supported in dedicated mode)
	hostname := "example.com"
	listeners[0].Hostname = (*gatewayv1.Hostname)(&hostname)
	tests.SetupDedicatedGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	expectedStatus := &gatewayv1.GatewayStatus{
		Conditions: []metav1.Condition{
			{
				Type:               string(gatewayv1.GatewayConditionAccepted),
				Status:             metav1.ConditionFalse,
				Message:            "Gateway does not contain any valid listener",
				ObservedGeneration: 1,
				Reason:             string(gatewayv1.GatewayReasonListenersNotValid),
			},
			{
				Type:               string(gatewayv1.GatewayConditionProgrammed),
				Status:             metav1.ConditionFalse,
				Message:            "Gateway not programmed",
				ObservedGeneration: 1,
				Reason:             string(gatewayv1.GatewayReasonInvalid),
			},
		},
		Listeners: []gatewayv1.ListenerStatus{
			{
				Name: "listener-8080",
				SupportedKinds: []gatewayv1.RouteGroupKind{
					{
						Kind: "HTTPRoute",
					},
				},
				AttachedRoutes: 0,
				Conditions: []metav1.Condition{
					{
						Type:               string(gatewayv1.ListenerConditionAccepted),
						Status:             metav1.ConditionFalse,
						Reason:             string(gatewayv1.ListenerReasonInvalid),
						Message:            "Hostname is not supported in dedicated mode",
						ObservedGeneration: 1,
					},
					{
						Type:               string(gatewayv1.ListenerConditionProgrammed),
						Status:             metav1.ConditionFalse,
						Reason:             string(gatewayv1.ListenerReasonInvalid),
						Message:            "Virtual service not configured/updated for this listener",
						ObservedGeneration: 1,
					},
				},
			},
		},
	}

	gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
	if err != nil || gateway == nil {
		t.Fatalf("Couldn't get the gateway, err: %+v", err)
	}

	tests.ValidateGatewayStatus(t, &gateway.Status, expectedStatus)
	tests.TeardownGateway(t, gatewayName, DEFAULT_NAMESPACE)
	tests.TeardownGatewayClass(t, gatewayClassName)
}

func TestDedicatedGatewayWithAllowedRoutesFromAllNamespaces(t *testing.T) {
	gatewayName := "dedicated-gateway-neg-02"
	gatewayClassName := "dedicated-gateway-class-neg-02"
	ports := []int32{8080}

	tests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	listeners := tests.GetListenersV1(ports, true, false)
	// Add AllowedRoutes from all namespaces (not supported in dedicated mode)
	fromAll := gatewayv1.NamespacesFromAll
	allowedRoutes := gatewayv1.AllowedRoutes{
		Namespaces: &gatewayv1.RouteNamespaces{
			From: &fromAll,
		},
	}
	listeners[0].AllowedRoutes = &allowedRoutes
	tests.SetupDedicatedGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	expectedStatus := &gatewayv1.GatewayStatus{
		Conditions: []metav1.Condition{
			{
				Type:               string(gatewayv1.GatewayConditionAccepted),
				Status:             metav1.ConditionFalse,
				Message:            "Gateway does not contain any valid listener",
				ObservedGeneration: 1,
				Reason:             string(gatewayv1.GatewayReasonListenersNotValid),
			},
			{
				Type:               string(gatewayv1.GatewayConditionProgrammed),
				Status:             metav1.ConditionFalse,
				Message:            "Gateway not programmed",
				ObservedGeneration: 1,
				Reason:             string(gatewayv1.GatewayReasonInvalid),
			},
		},
		Listeners: []gatewayv1.ListenerStatus{
			{
				Name: "listener-8080",
				SupportedKinds: []gatewayv1.RouteGroupKind{
					{
						Kind: "HTTPRoute",
					},
				},
				AttachedRoutes: 0,
				Conditions: []metav1.Condition{
					{
						Type:               string(gatewayv1.ListenerConditionAccepted),
						Status:             metav1.ConditionFalse,
						Reason:             string(gatewayv1.ListenerReasonInvalid),
						Message:            "Routes from all namespaces is not supported in dedicated mode",
						ObservedGeneration: 1,
					},
					{
						Type:               string(gatewayv1.ListenerConditionProgrammed),
						Status:             metav1.ConditionFalse,
						Reason:             string(gatewayv1.ListenerReasonInvalid),
						Message:            "Virtual service not configured/updated for this listener",
						ObservedGeneration: 1,
					},
				},
			},
		},
	}

	gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
	if err != nil || gateway == nil {
		t.Fatalf("Couldn't get the gateway, err: %+v", err)
	}

	tests.ValidateGatewayStatus(t, &gateway.Status, expectedStatus)
	tests.TeardownGateway(t, gatewayName, DEFAULT_NAMESPACE)
	tests.TeardownGatewayClass(t, gatewayClassName)
}

func TestDedicatedGatewayWithMixedValidInvalidListeners(t *testing.T) {
	gatewayName := "dedicated-gateway-neg-03"
	gatewayClassName := "dedicated-gateway-class-neg-03"
	ports := []int32{8080, 8081}

	tests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	listeners := tests.GetListenersV1(ports, true, false)
	// First listener has hostname (invalid in dedicated mode)
	hostname := "example.com"
	listeners[0].Hostname = (*gatewayv1.Hostname)(&hostname)
	// Second listener is valid (no hostname)
	tests.SetupDedicatedGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	vsUUIDMap := map[string]string{
		"VSUUID": fmt.Sprintf("virtualservice-ako-gw-%s--%s-%s-L7-dedicated-EVH-random-uuid", lib.GetClusterName(), DEFAULT_NAMESPACE, gatewayName),
	}
	messageBytes, err := json.Marshal(vsUUIDMap)
	if err != nil {
		t.Fatalf("Couldn't marshal the vsUUIDMap, err: %+v", err)
	}
	programmedConditionMessage := string(messageBytes)
	expectedStatus := &gatewayv1.GatewayStatus{
		Conditions: []metav1.Condition{
			{
				Type:               string(gatewayv1.GatewayConditionAccepted),
				Status:             metav1.ConditionTrue,
				Message:            "Gateway contains atleast one valid listener",
				ObservedGeneration: 1,
				Reason:             string(gatewayv1.GatewayReasonListenersNotValid),
			},
			{
				Type:               string(gatewayv1.GatewayConditionProgrammed),
				Status:             metav1.ConditionTrue,
				Message:            programmedConditionMessage,
				ObservedGeneration: 1,
				Reason:             string(gatewayv1.GatewayReasonProgrammed),
			},
		},
		Listeners: tests.GetListenerStatusV1(ports, []int32{0, 0}, true, false),
	}
	// First listener should be invalid due to hostname
	expectedStatus.Listeners[0].Conditions[0].Reason = string(gatewayv1.ListenerReasonInvalid)
	expectedStatus.Listeners[0].Conditions[0].Status = metav1.ConditionFalse
	expectedStatus.Listeners[0].Conditions[0].Message = "Hostname is not supported in dedicated mode"
	expectedStatus.Listeners[0].Conditions[0].Type = string(gatewayv1.ListenerConditionAccepted)

	expectedStatus.Listeners[0].Conditions[1].Type = string(gatewayv1.ListenerConditionProgrammed)
	expectedStatus.Listeners[0].Conditions[1].Status = metav1.ConditionFalse
	expectedStatus.Listeners[0].Conditions[1].Reason = string(gatewayv1.ListenerReasonInvalid)
	expectedStatus.Listeners[0].Conditions[1].Message = "Virtual service not configured/updated for this listener"

	// Second listener should be valid
	expectedStatus.Listeners[1].Conditions[0].Reason = string(gatewayv1.ListenerReasonAccepted)
	expectedStatus.Listeners[1].Conditions[0].Status = metav1.ConditionTrue
	expectedStatus.Listeners[1].Conditions[0].Message = "Listener is valid"
	expectedStatus.Listeners[1].Conditions[0].Type = string(gatewayv1.ListenerConditionAccepted)

	programmedCondition := metav1.Condition{
		Type:               string(gatewayv1.ListenerConditionProgrammed),
		Status:             metav1.ConditionTrue,
		Message:            programmedConditionMessage,
		ObservedGeneration: 1,
		Reason:             string(gatewayv1.ListenerReasonProgrammed),
	}

	expectedStatus.Listeners[1].Conditions = append(expectedStatus.Listeners[1].Conditions, programmedCondition)

	gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
	if err != nil || gateway == nil {
		t.Fatalf("Couldn't get the gateway, err: %+v", err)
	}

	tests.ValidateGatewayStatus(t, &gateway.Status, expectedStatus)
	tests.TeardownGateway(t, gatewayName, DEFAULT_NAMESPACE)
	tests.TeardownGatewayClass(t, gatewayClassName)
}

func TestDedicatedGatewaySecretCreateDelete(t *testing.T) {
	gatewayName := "dedicated-gateway-03"
	gatewayClassName := "dedicated-gateway-class-03"
	ports := []int32{8080}
	secrets := []string{"dedicated-secret-03"}

	tests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	listeners := tests.GetListenersV1(ports, true, false, secrets...)
	tests.SetupDedicatedGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
	if err != nil || gateway == nil {
		t.Fatalf("Couldn't get the gateway, err: %+v", err)
	}
	expectedStatus := tests.GetNegativeConditions(ports)
	tests.ValidateGatewayStatus(t, &gateway.Status, expectedStatus)

	// Add secret
	integrationtest.AddSecret(secrets[0], DEFAULT_NAMESPACE, "cert", "key")
	expectedStatus = tests.GetPositiveConditions(ports)

	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		condition := apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionProgrammed))
		return condition != nil && condition.Status == metav1.ConditionTrue
	}, 40*time.Second).Should(gomega.Equal(true))

	gateway, err = tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
	if err != nil || gateway == nil {
		t.Fatalf("Couldn't get the gateway, err: %+v", err)
	}
	tests.ValidateGatewayStatus(t, &gateway.Status, expectedStatus)

	// Delete secret
	integrationtest.DeleteSecret(secrets[0], DEFAULT_NAMESPACE)
	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		condition := apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionProgrammed))
		return condition != nil && condition.Status == metav1.ConditionTrue
	}, 40*time.Second).Should(gomega.Equal(false))
	expectedStatus = tests.GetNegativeConditions(ports)

	gateway, err = tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
	if err != nil || gateway == nil {
		t.Fatalf("Couldn't get the gateway, err: %+v", err)
	}
	tests.ValidateGatewayStatus(t, &gateway.Status, expectedStatus)
	tests.TeardownGateway(t, gatewayName, DEFAULT_NAMESPACE)
	tests.TeardownGatewayClass(t, gatewayClassName)
}
