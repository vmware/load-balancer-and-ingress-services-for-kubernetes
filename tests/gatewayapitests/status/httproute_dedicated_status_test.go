/*
 * Copyright Â© 2025 Broadcom Inc. and/or its subsidiaries. All Rights Reserved.
 * All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*   http://www.apache.org/licenses/LICENSE-2.0
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

package status

import (
	"context"
	"fmt"
	"testing"
	"time"

	"github.com/onsi/gomega"
	corev1 "k8s.io/api/core/v1"
	apimeta "k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"

	akogatewayapilib "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-gateway-api/lib"
	akogatewayapitests "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/tests/gatewayapitests"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/tests/integrationtest"
)

// @AI-Generated
// [Generated by Cursor claude-4-sonnet]

// TestHTTPRouteWithMultipleParentRefsInDedicatedMode tests that HTTPRoute with multiple parent references
// is rejected in dedicated mode with appropriate status conditions
func TestHTTPRouteWithMultipleParentRefsInDedicatedMode(t *testing.T) {
	gatewayClassName := "gateway-class-dedicated-multiple-parents"
	gatewayName := "gateway-dedicated-multiple-parents"
	gatewayName2 := "gateway-dedicated-multiple-parents-2"
	httpRouteName := "httproute-dedicated-multiple-parents"
	namespace := DEFAULT_NAMESPACE
	svcName := "avisvc-dedicated-multiple-parents"
	ports := []int32{8080}

	akogatewayapitests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	integrationtest.CreateSVC(t, namespace, svcName, "TCP", corev1.ServiceTypeClusterIP, false)
	integrationtest.CreateEPS(t, namespace, svcName, false, false, "1.1.1")

	// Create first Gateway with dedicated mode
	listeners := akogatewayapitests.GetListenersV1(ports, false, false)
	akogatewayapitests.SetupDedicatedGateway(t, gatewayName, namespace, gatewayClassName, nil, listeners)

	// Create second Gateway with dedicated mode for multiple parent refs
	akogatewayapitests.SetupDedicatedGateway(t, gatewayName2, namespace, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := akogatewayapitests.GatewayClient.GatewayV1().Gateways(namespace).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	// Create HTTPRoute with multiple parent references (should fail in dedicated mode)
	parentRefs := akogatewayapitests.GetParentReferencesV1([]string{gatewayName, gatewayName2}, namespace, ports)
	rule := akogatewayapitests.GetHTTPRouteRuleV1(integrationtest.PATHPREFIX, []string{"/"}, []string{},
		map[string][]string{},
		[][]string{{svcName, namespace, "8080", "1"}}, nil)
	rules := []gatewayv1.HTTPRouteRule{rule}

	akogatewayapitests.SetupHTTPRoute(t, httpRouteName, namespace, parentRefs, nil, rules)

	// Verify HTTPRoute status shows rejection due to multiple parent refs
	g.Eventually(func() bool {
		httpRoute, err := akogatewayapitests.GatewayClient.GatewayV1().HTTPRoutes(namespace).Get(context.TODO(), httpRouteName, metav1.GetOptions{})
		if err != nil || httpRoute == nil {
			t.Logf("Couldn't get the HTTPRoute, err: %+v", err)
			return false
		}
		if len(httpRoute.Status.Parents) == 0 {
			return false
		}
		// Check for UnsupportedValue condition
		condition := apimeta.FindStatusCondition(httpRoute.Status.Parents[0].Conditions, string(gatewayv1.RouteConditionAccepted))
		return condition != nil && condition.Reason == string(gatewayv1.RouteReasonUnsupportedValue) &&
			condition.Status == metav1.ConditionFalse
	}, 30*time.Second).Should(gomega.Equal(true))

	// Verify the error message mentions multiple parent refs restriction
	httpRoute, err := akogatewayapitests.GatewayClient.GatewayV1().HTTPRoutes(namespace).Get(context.TODO(), httpRouteName, metav1.GetOptions{})
	g.Expect(err).ToNot(gomega.HaveOccurred())
	g.Expect(httpRoute.Status.Parents).To(gomega.HaveLen(2)) // Both parent refs should have status entries

	condition := apimeta.FindStatusCondition(httpRoute.Status.Parents[0].Conditions, string(gatewayv1.RouteConditionAccepted))
	g.Expect(condition).ToNot(gomega.BeNil())
	g.Expect(condition.Message).To(gomega.ContainSubstring("Only one parent reference is allowed"))

	// Cleanup
	akogatewayapitests.TeardownHTTPRoute(t, httpRouteName, namespace)
	akogatewayapitests.TeardownGateway(t, gatewayName2, namespace)
	akogatewayapitests.TeardownGateway(t, gatewayName, namespace)
	akogatewayapitests.TeardownGatewayClass(t, gatewayClassName)
	integrationtest.DelSVC(t, namespace, svcName)
	integrationtest.DelEPS(t, namespace, svcName)
}

// TestHTTPRouteWithHostnamesInDedicatedMode tests that HTTPRoute with hostnames
// is rejected in dedicated mode with appropriate status conditions
func TestHTTPRouteWithHostnamesInDedicatedMode(t *testing.T) {
	gatewayClassName := "gateway-class-dedicated-hostnames"
	gatewayName := "gateway-dedicated-hostnames"
	httpRouteName := "httproute-dedicated-hostnames"
	namespace := DEFAULT_NAMESPACE
	svcName := "avisvc-dedicated-hostnames"
	ports := []int32{8080}

	akogatewayapitests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	integrationtest.CreateSVC(t, namespace, svcName, "TCP", corev1.ServiceTypeClusterIP, false)
	integrationtest.CreateEPS(t, namespace, svcName, false, false, "1.1.1")

	// Create Gateway with dedicated mode
	listeners := akogatewayapitests.GetListenersV1(ports, false, false)
	akogatewayapitests.SetupDedicatedGateway(t, gatewayName, namespace, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := akogatewayapitests.GatewayClient.GatewayV1().Gateways(namespace).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	// Create HTTPRoute with hostnames (should fail in dedicated mode)
	parentRefs := akogatewayapitests.GetParentReferencesV1([]string{gatewayName}, namespace, ports)
	hostnames := []gatewayv1.Hostname{"example.com", "api.example.com"}
	rule := akogatewayapitests.GetHTTPRouteRuleV1(integrationtest.PATHPREFIX, []string{"/"}, []string{},
		map[string][]string{},
		[][]string{{svcName, namespace, "8080", "1"}}, nil)
	rules := []gatewayv1.HTTPRouteRule{rule}

	akogatewayapitests.SetupHTTPRoute(t, httpRouteName, namespace, parentRefs, hostnames, rules)

	// Verify HTTPRoute status shows rejection due to hostnames
	g.Eventually(func() bool {
		httpRoute, err := akogatewayapitests.GatewayClient.GatewayV1().HTTPRoutes(namespace).Get(context.TODO(), httpRouteName, metav1.GetOptions{})
		if err != nil || httpRoute == nil {
			t.Logf("Couldn't get the HTTPRoute, err: %+v", err)
			return false
		}
		if len(httpRoute.Status.Parents) == 0 {
			return false
		}
		// Check for UnsupportedValue condition
		condition := apimeta.FindStatusCondition(httpRoute.Status.Parents[0].Conditions, string(gatewayv1.RouteConditionAccepted))
		return condition != nil && condition.Reason == string(gatewayv1.RouteReasonUnsupportedValue) &&
			condition.Status == metav1.ConditionFalse
	}, 30*time.Second).Should(gomega.Equal(true))

	// Verify the error message mentions hostnames restriction
	httpRoute, err := akogatewayapitests.GatewayClient.GatewayV1().HTTPRoutes(namespace).Get(context.TODO(), httpRouteName, metav1.GetOptions{})
	g.Expect(err).ToNot(gomega.HaveOccurred())
	g.Expect(httpRoute.Status.Parents).To(gomega.HaveLen(1))

	condition := apimeta.FindStatusCondition(httpRoute.Status.Parents[0].Conditions, string(gatewayv1.RouteConditionAccepted))
	g.Expect(condition).ToNot(gomega.BeNil())
	g.Expect(condition.Message).To(gomega.ContainSubstring("Hostnames are not allowed"))

	// Cleanup
	akogatewayapitests.TeardownHTTPRoute(t, httpRouteName, namespace)
	akogatewayapitests.TeardownGateway(t, gatewayName, namespace)
	akogatewayapitests.TeardownGatewayClass(t, gatewayClassName)
	integrationtest.DelSVC(t, namespace, svcName)
	integrationtest.DelEPS(t, namespace, svcName)
}

// TestMultipleHTTPRoutesOnDedicatedGateway tests that only one HTTPRoute can be attached
// to a dedicated Gateway, and subsequent HTTPRoutes are rejected
func TestMultipleHTTPRoutesOnDedicatedGateway(t *testing.T) {
	gatewayClassName := "gateway-class-dedicated-multiple-routes"
	gatewayName := "gateway-dedicated-multiple-routes"
	httpRouteName1 := "httproute-dedicated-first"
	httpRouteName2 := "httproute-dedicated-second"
	namespace := DEFAULT_NAMESPACE
	svcName1 := "avisvc-dedicated-first"
	svcName2 := "avisvc-dedicated-second"
	ports := []int32{8080}

	akogatewayapitests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	integrationtest.CreateSVC(t, namespace, svcName1, "TCP", corev1.ServiceTypeClusterIP, false)
	integrationtest.CreateEPS(t, namespace, svcName1, false, false, "1.1.1")
	integrationtest.CreateSVC(t, namespace, svcName2, "TCP", corev1.ServiceTypeClusterIP, false)
	integrationtest.CreateEPS(t, namespace, svcName2, false, false, "1.1.2")

	// Create Gateway with dedicated mode
	listeners := akogatewayapitests.GetListenersV1(ports, true, false)
	akogatewayapitests.SetupDedicatedGateway(t, gatewayName, namespace, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := akogatewayapitests.GatewayClient.GatewayV1().Gateways(namespace).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	// Create first HTTPRoute (should succeed)
	parentRefs := akogatewayapitests.GetParentReferencesV1([]string{gatewayName}, namespace, ports)
	rule1 := akogatewayapitests.GetHTTPRouteRuleV1(integrationtest.PATHPREFIX, []string{"/"}, []string{},
		map[string][]string{},
		[][]string{{svcName1, namespace, "8080", "1"}}, nil)
	rules1 := []gatewayv1.HTTPRouteRule{rule1}

	akogatewayapitests.SetupHTTPRoute(t, httpRouteName1, namespace, parentRefs, []gatewayv1.Hostname{}, rules1)

	// Verify first HTTPRoute is accepted
	g.Eventually(func() bool {
		httpRoute, err := akogatewayapitests.GatewayClient.GatewayV1().HTTPRoutes(namespace).Get(context.TODO(), httpRouteName1, metav1.GetOptions{})
		if err != nil || httpRoute == nil {
			return false
		}
		if len(httpRoute.Status.Parents) == 0 {
			return false
		}
		condition := apimeta.FindStatusCondition(httpRoute.Status.Parents[0].Conditions, string(gatewayv1.RouteConditionAccepted))
		return condition != nil && condition.Status == metav1.ConditionTrue
	}, 30*time.Second).Should(gomega.Equal(true))

	// Create second HTTPRoute (should be rejected due to dedicated mode restriction)
	rule2 := akogatewayapitests.GetHTTPRouteRuleV1(integrationtest.PATHPREFIX, []string{"/api"}, []string{},
		map[string][]string{},
		[][]string{{svcName2, namespace, "8080", "1"}}, nil)
	rules2 := []gatewayv1.HTTPRouteRule{rule2}

	akogatewayapitests.SetupHTTPRoute(t, httpRouteName2, namespace, parentRefs, nil, rules2)

	// Verify second HTTPRoute is rejected
	g.Eventually(func() bool {
		httpRoute, err := akogatewayapitests.GatewayClient.GatewayV1().HTTPRoutes(namespace).Get(context.TODO(), httpRouteName2, metav1.GetOptions{})
		if err != nil || httpRoute == nil {
			t.Logf("Couldn't get the HTTPRoute, err: %+v", err)
			return false
		}
		if len(httpRoute.Status.Parents) == 0 {
			return false
		}
		condition := apimeta.FindStatusCondition(httpRoute.Status.Parents[0].Conditions, string(gatewayv1.RouteConditionAccepted))
		return condition != nil && condition.Reason == string(gatewayv1.RouteReasonUnsupportedValue) &&
			condition.Status == metav1.ConditionFalse
	}, 60*time.Second).Should(gomega.Equal(true))

	// Verify the error message mentions one route per gateway restriction
	httpRoute2, err := akogatewayapitests.GatewayClient.GatewayV1().HTTPRoutes(namespace).Get(context.TODO(), httpRouteName2, metav1.GetOptions{})
	g.Expect(err).ToNot(gomega.HaveOccurred())
	g.Expect(httpRoute2.Status.Parents).To(gomega.HaveLen(1))

	condition := apimeta.FindStatusCondition(httpRoute2.Status.Parents[0].Conditions, string(gatewayv1.RouteConditionAccepted))
	g.Expect(condition).ToNot(gomega.BeNil())
	g.Expect(condition.Message).To(gomega.ContainSubstring("Only one route is allowed per listener"))

	// Cleanup
	akogatewayapitests.TeardownHTTPRoute(t, httpRouteName2, namespace)
	akogatewayapitests.TeardownHTTPRoute(t, httpRouteName1, namespace)
	akogatewayapitests.TeardownGateway(t, gatewayName, namespace)
	akogatewayapitests.TeardownGatewayClass(t, gatewayClassName)
	integrationtest.DelSVC(t, namespace, svcName1)
	integrationtest.DelEPS(t, namespace, svcName1)
	integrationtest.DelSVC(t, namespace, svcName2)
	integrationtest.DelEPS(t, namespace, svcName2)
}

// TestValidHTTPRouteInDedicatedMode tests that a valid HTTPRoute configuration
// is accepted in dedicated mode with proper status conditions
func TestValidHTTPRouteInDedicatedMode(t *testing.T) {
	gatewayClassName := "gateway-class-dedicated-valid"
	gatewayName := "gateway-dedicated-valid"
	httpRouteName := "httproute-dedicated-valid"
	namespace := DEFAULT_NAMESPACE
	svcName := "avisvc-dedicated-valid"
	ports := []int32{8080}

	akogatewayapitests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	integrationtest.CreateSVC(t, namespace, svcName, "TCP", corev1.ServiceTypeClusterIP, false)
	integrationtest.CreateEPS(t, namespace, svcName, false, false, "1.1.1")

	// Create Gateway with dedicated mode
	listeners := akogatewayapitests.GetListenersV1(ports, true, false)
	akogatewayapitests.SetupDedicatedGateway(t, gatewayName, namespace, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := akogatewayapitests.GatewayClient.GatewayV1().Gateways(namespace).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	// Create valid HTTPRoute (single parent ref, no hostnames, same namespace)
	parentRefs := akogatewayapitests.GetParentReferencesV1([]string{gatewayName}, namespace, ports)
	rule := akogatewayapitests.GetHTTPRouteRuleV1(integrationtest.PATHPREFIX, []string{"/"}, []string{},
		map[string][]string{},
		[][]string{{svcName, namespace, "8080", "1"}}, nil)
	rules := []gatewayv1.HTTPRouteRule{rule}

	akogatewayapitests.SetupHTTPRoute(t, httpRouteName, namespace, parentRefs, nil, rules)

	// Verify HTTPRoute is accepted with proper status conditions
	g.Eventually(func() bool {
		httpRoute, err := akogatewayapitests.GatewayClient.GatewayV1().HTTPRoutes(namespace).Get(context.TODO(), httpRouteName, metav1.GetOptions{})
		if err != nil || httpRoute == nil {
			t.Logf("Couldn't get the HTTPRoute, err: %+v", err)
			return false
		}
		if len(httpRoute.Status.Parents) == 0 {
			return false
		}
		acceptedCondition := apimeta.FindStatusCondition(httpRoute.Status.Parents[0].Conditions, string(gatewayv1.RouteConditionAccepted))
		resolvedRefsCondition := apimeta.FindStatusCondition(httpRoute.Status.Parents[0].Conditions, string(gatewayv1.RouteConditionResolvedRefs))
		return acceptedCondition != nil && acceptedCondition.Status == metav1.ConditionTrue &&
			resolvedRefsCondition != nil && resolvedRefsCondition.Status == metav1.ConditionTrue
	}, 30*time.Second).Should(gomega.Equal(true))

	// Verify status conditions are correct
	conditionMap := make(map[string][]metav1.Condition)
	conditions := []metav1.Condition{{
		Type:    string(gatewayv1.RouteConditionAccepted),
		Reason:  string(gatewayv1.RouteReasonAccepted),
		Status:  metav1.ConditionTrue,
		Message: "Parent reference is valid",
	}, {
		Type:   string(gatewayv1.RouteConditionResolvedRefs),
		Reason: string(gatewayv1.RouteReasonResolvedRefs),
		Status: metav1.ConditionTrue,
	}}
	conditionMap[fmt.Sprintf("%s-%d", gatewayName, ports[0])] = conditions
	expectedRouteStatus := akogatewayapitests.GetRouteStatusV1([]string{gatewayName}, namespace, ports, conditionMap)

	httpRoute, err := akogatewayapitests.GatewayClient.GatewayV1().HTTPRoutes(namespace).Get(context.TODO(), httpRouteName, metav1.GetOptions{})
	if err != nil || httpRoute == nil {
		t.Fatalf("Couldn't get the HTTPRoute, err: %+v", err)
	}
	akogatewayapitests.ValidateHTTPRouteStatus(t, &httpRoute.Status, &gatewayv1.HTTPRouteStatus{RouteStatus: *expectedRouteStatus})

	// Cleanup
	akogatewayapitests.TeardownHTTPRoute(t, httpRouteName, namespace)
	akogatewayapitests.TeardownGateway(t, gatewayName, namespace)
	akogatewayapitests.TeardownGatewayClass(t, gatewayClassName)
	integrationtest.DelSVC(t, namespace, svcName)
	integrationtest.DelEPS(t, namespace, svcName)
}

// TestHTTPRouteStatusTransitionFromInvalidToValid tests the status transition when
// an HTTPRoute is updated from invalid to valid configuration in dedicated mode
func TestHTTPRouteStatusTransitionFromInvalidToValid(t *testing.T) {
	gatewayClassName := "gateway-class-dedicated-transition"
	gatewayName := "gateway-dedicated-transition"
	httpRouteName := "httproute-dedicated-transition"
	namespace := DEFAULT_NAMESPACE
	svcName := "avisvc-dedicated-transition"
	ports := []int32{8080}

	akogatewayapitests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	integrationtest.CreateSVC(t, namespace, svcName, "TCP", corev1.ServiceTypeClusterIP, false)
	integrationtest.CreateEPS(t, namespace, svcName, false, false, "1.1.1")

	// Create Gateway with dedicated mode
	listeners := akogatewayapitests.GetListenersV1(ports, true, false)
	akogatewayapitests.SetupDedicatedGateway(t, gatewayName, namespace, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := akogatewayapitests.GatewayClient.GatewayV1().Gateways(namespace).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	// Create HTTPRoute with invalid configuration (hostnames in dedicated mode)
	parentRefs := akogatewayapitests.GetParentReferencesV1([]string{gatewayName}, namespace, ports)
	hostnames := []gatewayv1.Hostname{"invalid.com"}
	rule := akogatewayapitests.GetHTTPRouteRuleV1(integrationtest.PATHPREFIX, []string{"/"}, []string{},
		map[string][]string{},
		[][]string{{svcName, namespace, "8080", "1"}}, nil)
	rules := []gatewayv1.HTTPRouteRule{rule}

	akogatewayapitests.SetupHTTPRoute(t, httpRouteName, namespace, parentRefs, hostnames, rules)

	// Verify HTTPRoute is initially rejected
	g.Eventually(func() bool {
		httpRoute, err := akogatewayapitests.GatewayClient.GatewayV1().HTTPRoutes(namespace).Get(context.TODO(), httpRouteName, metav1.GetOptions{})
		if err != nil || httpRoute == nil {
			return false
		}
		if len(httpRoute.Status.Parents) == 0 {
			return false
		}
		condition := apimeta.FindStatusCondition(httpRoute.Status.Parents[0].Conditions, string(gatewayv1.RouteConditionAccepted))
		return condition != nil && condition.Status == metav1.ConditionFalse
	}, 30*time.Second).Should(gomega.Equal(true))

	// Update HTTPRoute to valid configuration (remove hostnames)
	akogatewayapitests.UpdateHTTPRoute(t, httpRouteName, namespace, parentRefs, nil, rules)

	// Verify HTTPRoute status transitions to accepted
	g.Eventually(func() bool {
		httpRoute, err := akogatewayapitests.GatewayClient.GatewayV1().HTTPRoutes(namespace).Get(context.TODO(), httpRouteName, metav1.GetOptions{})
		if err != nil || httpRoute == nil {
			return false
		}
		if len(httpRoute.Status.Parents) == 0 {
			return false
		}
		acceptedCondition := apimeta.FindStatusCondition(httpRoute.Status.Parents[0].Conditions, string(gatewayv1.RouteConditionAccepted))
		resolvedRefsCondition := apimeta.FindStatusCondition(httpRoute.Status.Parents[0].Conditions, string(gatewayv1.RouteConditionResolvedRefs))
		return acceptedCondition != nil && acceptedCondition.Status == metav1.ConditionTrue &&
			resolvedRefsCondition != nil && resolvedRefsCondition.Status == metav1.ConditionTrue
	}, 30*time.Second).Should(gomega.Equal(true))

	// Verify final status is valid using the standard validation helper
	conditionMap := make(map[string][]metav1.Condition)
	conditions := []metav1.Condition{{
		Type:    string(gatewayv1.RouteConditionAccepted),
		Reason:  string(gatewayv1.RouteReasonAccepted),
		Status:  metav1.ConditionTrue,
		Message: "Parent reference is valid",
	}, {
		Type:   string(gatewayv1.RouteConditionResolvedRefs),
		Reason: string(gatewayv1.RouteReasonResolvedRefs),
		Status: metav1.ConditionTrue,
	}}
	conditionMap[fmt.Sprintf("%s-%d", gatewayName, ports[0])] = conditions
	expectedRouteStatus := akogatewayapitests.GetRouteStatusV1([]string{gatewayName}, namespace, ports, conditionMap)

	httpRoute, err := akogatewayapitests.GatewayClient.GatewayV1().HTTPRoutes(namespace).Get(context.TODO(), httpRouteName, metav1.GetOptions{})
	if err != nil || httpRoute == nil {
		t.Fatalf("Couldn't get the HTTPRoute, err: %+v", err)
	}
	akogatewayapitests.ValidateHTTPRouteStatus(t, &httpRoute.Status, &gatewayv1.HTTPRouteStatus{RouteStatus: *expectedRouteStatus})

	// Cleanup
	akogatewayapitests.TeardownHTTPRoute(t, httpRouteName, namespace)
	akogatewayapitests.TeardownGateway(t, gatewayName, namespace)
	akogatewayapitests.TeardownGatewayClass(t, gatewayClassName)
	integrationtest.DelSVC(t, namespace, svcName)
	integrationtest.DelEPS(t, namespace, svcName)
}

// TestHTTPRouteWithInvalidBackendKindInDedicatedMode tests that HTTPRoute with invalid backend kind
// is properly handled in dedicated mode with appropriate status conditions
func TestHTTPRouteWithInvalidBackendKindInDedicatedMode(t *testing.T) {
	gatewayClassName := "gateway-class-dedicated-invalid-backend"
	gatewayName := "gateway-dedicated-invalid-backend"
	httpRouteName := "httproute-dedicated-invalid-backend"
	namespace := DEFAULT_NAMESPACE
	svcName := "avisvc-dedicated-invalid-backend"
	ports := []int32{8080}

	akogatewayapitests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	integrationtest.CreateSVC(t, namespace, svcName, "TCP", corev1.ServiceTypeClusterIP, false)
	integrationtest.CreateEPS(t, namespace, svcName, false, false, "1.1.1")

	// Create Gateway with dedicated mode
	listeners := akogatewayapitests.GetListenersV1(ports, true, false)
	akogatewayapitests.SetupDedicatedGateway(t, gatewayName, namespace, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := akogatewayapitests.GatewayClient.GatewayV1().Gateways(namespace).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	// Create HTTPRoute with invalid backend kind
	parentRefs := akogatewayapitests.GetParentReferencesV1([]string{gatewayName}, namespace, ports)
	rule := akogatewayapitests.GetHTTPRouteRuleV1(integrationtest.PATHPREFIX, []string{"/"}, []string{},
		map[string][]string{},
		[][]string{{svcName, namespace, "8080", "1"}}, nil)

	// Set invalid backend kind
	invalidKind := gatewayv1.Kind("InvalidKind")
	rule.BackendRefs[0].BackendRef.Kind = &invalidKind
	rules := []gatewayv1.HTTPRouteRule{rule}

	akogatewayapitests.SetupHTTPRoute(t, httpRouteName, namespace, parentRefs, nil, rules)

	// Verify HTTPRoute status shows proper error for invalid backend kind
	g.Eventually(func() bool {
		httpRoute, err := akogatewayapitests.GatewayClient.GatewayV1().HTTPRoutes(namespace).Get(context.TODO(), httpRouteName, metav1.GetOptions{})
		if err != nil || httpRoute == nil {
			t.Logf("Couldn't get the HTTPRoute, err: %+v", err)
			return false
		}
		if len(httpRoute.Status.Parents) == 0 {
			return false
		}
		// Should be accepted but have unresolved refs due to invalid backend kind
		acceptedCondition := apimeta.FindStatusCondition(httpRoute.Status.Parents[0].Conditions, string(gatewayv1.RouteConditionAccepted))
		resolvedRefsCondition := apimeta.FindStatusCondition(httpRoute.Status.Parents[0].Conditions, string(gatewayv1.RouteConditionResolvedRefs))
		return acceptedCondition != nil && acceptedCondition.Status == metav1.ConditionTrue &&
			resolvedRefsCondition != nil && resolvedRefsCondition.Status == metav1.ConditionFalse &&
			resolvedRefsCondition.Reason == string(gatewayv1.RouteReasonInvalidKind)
	}, 30*time.Second).Should(gomega.Equal(true))

	// Verify the error message mentions invalid backend kind
	httpRoute, err := akogatewayapitests.GatewayClient.GatewayV1().HTTPRoutes(namespace).Get(context.TODO(), httpRouteName, metav1.GetOptions{})
	g.Expect(err).ToNot(gomega.HaveOccurred())
	g.Expect(httpRoute.Status.Parents).To(gomega.HaveLen(1))

	resolvedRefsCondition := apimeta.FindStatusCondition(httpRoute.Status.Parents[0].Conditions, string(gatewayv1.RouteConditionResolvedRefs))
	g.Expect(resolvedRefsCondition).ToNot(gomega.BeNil())
	g.Expect(resolvedRefsCondition.Message).To(gomega.Equal("backendRef avisvc-dedicated-invalid-backend has invalid kind InvalidKind"))

	// Cleanup
	akogatewayapitests.TeardownHTTPRoute(t, httpRouteName, namespace)
	akogatewayapitests.TeardownGateway(t, gatewayName, namespace)
	akogatewayapitests.TeardownGatewayClass(t, gatewayClassName)
	integrationtest.DelSVC(t, namespace, svcName)
	integrationtest.DelEPS(t, namespace, svcName)
}

// TestHTTPRouteWithUnsupportedFilterInDedicatedMode tests that HTTPRoute with unsupported filters
// is properly handled in dedicated mode with appropriate status conditions
func TestHTTPRouteWithUnsupportedFilterInDedicatedMode(t *testing.T) {
	gatewayClassName := "gateway-class-dedicated-unsupported-filter"
	gatewayName := "gateway-dedicated-unsupported-filter"
	httpRouteName := "httproute-dedicated-unsupported-filter"
	namespace := DEFAULT_NAMESPACE
	svcName := "avisvc-dedicated-unsupported-filter"
	ports := []int32{8080}

	akogatewayapitests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	integrationtest.CreateSVC(t, namespace, svcName, "TCP", corev1.ServiceTypeClusterIP, false)
	integrationtest.CreateEPS(t, namespace, svcName, false, false, "1.1.1")

	// Create Gateway with dedicated mode
	listeners := akogatewayapitests.GetListenersV1(ports, true, false)
	akogatewayapitests.SetupDedicatedGateway(t, gatewayName, namespace, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := akogatewayapitests.GatewayClient.GatewayV1().Gateways(namespace).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	// Create HTTPRoute with unsupported URLRewrite filter (PrefixMatchHTTPPathModifier)
	parentRefs := akogatewayapitests.GetParentReferencesV1([]string{gatewayName}, namespace, ports)
	rule := akogatewayapitests.GetHTTPRouteRuleV1(integrationtest.PATHPREFIX, []string{"/foo"}, []string{},
		map[string][]string{"URLRewrite": {}},
		[][]string{{svcName, namespace, "8080", "1"}}, nil)

	// Set unsupported URLRewrite path type
	rule.Filters[0].URLRewrite.Path.Type = gatewayv1.PrefixMatchHTTPPathModifier
	rules := []gatewayv1.HTTPRouteRule{rule}

	akogatewayapitests.SetupHTTPRoute(t, httpRouteName, namespace, parentRefs, nil, rules)

	// Verify HTTPRoute status shows rejection due to unsupported filter
	g.Eventually(func() bool {
		httpRoute, err := akogatewayapitests.GatewayClient.GatewayV1().HTTPRoutes(namespace).Get(context.TODO(), httpRouteName, metav1.GetOptions{})
		if err != nil || httpRoute == nil {
			t.Logf("Couldn't get the HTTPRoute, err: %+v", err)
			return false
		}
		if len(httpRoute.Status.Parents) == 0 {
			return false
		}
		// Check for UnsupportedValue condition
		condition := apimeta.FindStatusCondition(httpRoute.Status.Parents[0].Conditions, string(gatewayv1.RouteConditionAccepted))
		return condition != nil && condition.Reason == string(gatewayv1.RouteReasonUnsupportedValue) &&
			condition.Status == metav1.ConditionFalse
	}, 30*time.Second).Should(gomega.Equal(true))

	// Verify the error message mentions unsupported URLRewrite path type
	httpRoute, err := akogatewayapitests.GatewayClient.GatewayV1().HTTPRoutes(namespace).Get(context.TODO(), httpRouteName, metav1.GetOptions{})
	g.Expect(err).ToNot(gomega.HaveOccurred())
	g.Expect(httpRoute.Status.Parents).To(gomega.HaveLen(1))

	condition := apimeta.FindStatusCondition(httpRoute.Status.Parents[0].Conditions, string(gatewayv1.RouteConditionAccepted))
	g.Expect(condition).ToNot(gomega.BeNil())
	g.Expect(condition.Message).To(gomega.ContainSubstring("HTTPUrlRewrite PathType has Unsupported value"))

	// Cleanup
	akogatewayapitests.TeardownHTTPRoute(t, httpRouteName, namespace)
	akogatewayapitests.TeardownGateway(t, gatewayName, namespace)
	akogatewayapitests.TeardownGatewayClass(t, gatewayClassName)
	integrationtest.DelSVC(t, namespace, svcName)
	integrationtest.DelEPS(t, namespace, svcName)
}

// TestHTTPRouteWithCrossNamespaceBackendInDedicatedMode tests that HTTPRoute with cross-namespace backend
// is properly handled in dedicated mode with appropriate status conditions
func TestHTTPRouteWithCrossNamespaceBackendInDedicatedMode(t *testing.T) {
	gatewayClassName := "gateway-class-dedicated-cross-ns-backend"
	gatewayName := "gateway-dedicated-cross-ns-backend"
	httpRouteName := "httproute-dedicated-cross-ns-backend"
	namespace := DEFAULT_NAMESPACE
	backendNamespace := "backend-namespace"
	svcName := "avisvc-dedicated-cross-ns-backend"
	ports := []int32{8080}

	akogatewayapitests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)

	// Create backend namespace and service
	integrationtest.AddNamespace(t, backendNamespace, map[string]string{})
	integrationtest.CreateSVC(t, backendNamespace, svcName, "TCP", corev1.ServiceTypeClusterIP, false)
	integrationtest.CreateEPS(t, backendNamespace, svcName, false, false, "1.1.1")

	// Create Gateway with dedicated mode
	listeners := akogatewayapitests.GetListenersV1(ports, true, false)
	akogatewayapitests.SetupDedicatedGateway(t, gatewayName, namespace, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := akogatewayapitests.GatewayClient.GatewayV1().Gateways(namespace).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	// Create HTTPRoute with cross-namespace backend reference
	parentRefs := akogatewayapitests.GetParentReferencesV1([]string{gatewayName}, namespace, ports)
	rule := akogatewayapitests.GetHTTPRouteRuleV1(integrationtest.PATHPREFIX, []string{"/"}, []string{},
		map[string][]string{},
		[][]string{{svcName, backendNamespace, "8080", "1"}}, nil)
	rules := []gatewayv1.HTTPRouteRule{rule}

	akogatewayapitests.SetupHTTPRoute(t, httpRouteName, namespace, parentRefs, nil, rules)

	// Verify HTTPRoute status - cross-namespace backend should work in dedicated mode
	// (unlike some other cross-namespace references that might be restricted)
	g.Eventually(func() bool {
		httpRoute, err := akogatewayapitests.GatewayClient.GatewayV1().HTTPRoutes(namespace).Get(context.TODO(), httpRouteName, metav1.GetOptions{})
		if err != nil || httpRoute == nil {
			t.Logf("Couldn't get the HTTPRoute, err: %+v", err)
			return false
		}
		if len(httpRoute.Status.Parents) == 0 {
			return false
		}
		acceptedCondition := apimeta.FindStatusCondition(httpRoute.Status.Parents[0].Conditions, string(gatewayv1.RouteConditionAccepted))
		resolvedRefsCondition := apimeta.FindStatusCondition(httpRoute.Status.Parents[0].Conditions, string(gatewayv1.RouteConditionResolvedRefs))
		return acceptedCondition != nil && acceptedCondition.Status == metav1.ConditionTrue &&
			resolvedRefsCondition != nil && resolvedRefsCondition.Status == metav1.ConditionTrue
	}, 30*time.Second).Should(gomega.Equal(true))

	// Verify status conditions are correct for cross-namespace backend
	conditionMap := make(map[string][]metav1.Condition)
	conditions := []metav1.Condition{{
		Type:    string(gatewayv1.RouteConditionAccepted),
		Reason:  string(gatewayv1.RouteReasonAccepted),
		Status:  metav1.ConditionTrue,
		Message: "Parent reference is valid",
	}, {
		Type:   string(gatewayv1.RouteConditionResolvedRefs),
		Reason: string(gatewayv1.RouteReasonResolvedRefs),
		Status: metav1.ConditionTrue,
	}}
	conditionMap[fmt.Sprintf("%s-%d", gatewayName, ports[0])] = conditions
	expectedRouteStatus := akogatewayapitests.GetRouteStatusV1([]string{gatewayName}, namespace, ports, conditionMap)

	httpRoute, err := akogatewayapitests.GatewayClient.GatewayV1().HTTPRoutes(namespace).Get(context.TODO(), httpRouteName, metav1.GetOptions{})
	if err != nil || httpRoute == nil {
		t.Fatalf("Couldn't get the HTTPRoute, err: %+v", err)
	}
	akogatewayapitests.ValidateHTTPRouteStatus(t, &httpRoute.Status, &gatewayv1.HTTPRouteStatus{RouteStatus: *expectedRouteStatus})

	// Cleanup
	akogatewayapitests.TeardownHTTPRoute(t, httpRouteName, namespace)
	akogatewayapitests.TeardownGateway(t, gatewayName, namespace)
	akogatewayapitests.TeardownGatewayClass(t, gatewayClassName)
	integrationtest.DelSVC(t, backendNamespace, svcName)
	integrationtest.DelEPS(t, backendNamespace, svcName)
	integrationtest.DeleteNamespace(backendNamespace)
}

// TestHTTPRouteWithNoParentRefInDedicatedMode tests that HTTPRoute with no parent references
// behaves correctly in dedicated mode (should have no status entries)
func TestHTTPRouteWithNoParentRefInDedicatedMode(t *testing.T) {
	gatewayClassName := "gateway-class-dedicated-no-parent"
	gatewayName := "gateway-dedicated-no-parent"
	httpRouteName := "httproute-dedicated-no-parent"
	namespace := DEFAULT_NAMESPACE
	svcName := "avisvc-dedicated-no-parent"
	ports := []int32{8080}

	akogatewayapitests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	integrationtest.CreateSVC(t, namespace, svcName, "TCP", corev1.ServiceTypeClusterIP, false)
	integrationtest.CreateEPS(t, namespace, svcName, false, false, "1.1.1")

	// Create Gateway with dedicated mode
	listeners := akogatewayapitests.GetListenersV1(ports, true, false)
	akogatewayapitests.SetupDedicatedGateway(t, gatewayName, namespace, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := akogatewayapitests.GatewayClient.GatewayV1().Gateways(namespace).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	// Create HTTPRoute with no parent references
	rule := akogatewayapitests.GetHTTPRouteRuleV1(integrationtest.PATHPREFIX, []string{"/"}, []string{},
		map[string][]string{},
		[][]string{{svcName, namespace, "8080", "1"}}, nil)
	rules := []gatewayv1.HTTPRouteRule{rule}

	akogatewayapitests.SetupHTTPRoute(t, httpRouteName, namespace, nil, nil, rules)

	// wait for http route to be processed
	time.Sleep(5 * time.Second)

	// Verify HTTPRoute has no parent status entries (since no parent refs)
	g.Eventually(func() bool {
		httpRoute, err := akogatewayapitests.GatewayClient.GatewayV1().HTTPRoutes(namespace).Get(context.TODO(), httpRouteName, metav1.GetOptions{})
		if err != nil || httpRoute == nil {
			t.Logf("Couldn't get the HTTPRoute, err: %+v", err)
			return false
		}
		// HTTPRoute with no parent refs should have no parent status entries
		return len(httpRoute.Status.Parents) == 0
	}, 30*time.Second).Should(gomega.Equal(true))

	// Verify the HTTPRoute exists but has empty status
	httpRoute, err := akogatewayapitests.GatewayClient.GatewayV1().HTTPRoutes(namespace).Get(context.TODO(), httpRouteName, metav1.GetOptions{})
	g.Expect(err).ToNot(gomega.HaveOccurred())
	g.Expect(httpRoute.Status.Parents).To(gomega.HaveLen(0))

	// Cleanup
	akogatewayapitests.TeardownHTTPRoute(t, httpRouteName, namespace)
	akogatewayapitests.TeardownGateway(t, gatewayName, namespace)
	akogatewayapitests.TeardownGatewayClass(t, gatewayClassName)
	integrationtest.DelSVC(t, namespace, svcName)
	integrationtest.DelEPS(t, namespace, svcName)
}
