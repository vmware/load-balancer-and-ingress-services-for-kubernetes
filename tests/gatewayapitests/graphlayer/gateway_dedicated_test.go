/*
 * Copyright Â© 2025 Broadcom Inc. and/or its subsidiaries. All Rights Reserved.
 * All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*   http://www.apache.org/licenses/LICENSE-2.0
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

package graphlayer

import (
	"context"
	"testing"
	"time"

	"github.com/onsi/gomega"
	apimeta "k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"

	akogatewayapilib "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-gateway-api/lib"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/lib"
	avinodes "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/nodes"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/objects"
	tests "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/tests/gatewayapitests"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/tests/integrationtest"
)

// @AI-Generated
// [Generated by Cursor claude-4-sonnet]

// Helper function to create listeners for dedicated mode (no hostname, correct protocol)

/*
Test Cases for Gateway in Dedicated Mode:
1. Basic Gateway creation in dedicated mode (no TLS)
2. Gateway with TLS in dedicated mode
3. Gateway transition from regular to dedicated mode
4. Gateway transition from dedicated to regular mode
5. Gateway deletion in dedicated mode
6. Gateway with multiple listeners in dedicated mode
7. Gateway with HTTPRoute in dedicated mode
8. Secret management in dedicated mode
*/

func TestDedicatedGatewayBasic(t *testing.T) {
	gatewayName := "gateway-dedicated-01"
	gatewayClassName := "gateway-class-dedicated-01"
	ports := []int32{8080}

	tests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	listeners := tests.GetDedicatedListenersV1(ports)
	tests.SetupDedicatedGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)

	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		if gateway.Annotations[akogatewayapilib.DedicatedGatewayModeAnnotation] != "true" {
			t.Logf("Gateway is not in dedicated mode, annotations: %+v", gateway.Annotations)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	modelName := lib.GetModelName(lib.GetTenant(), akogatewayapilib.GetGatewayParentName(DEFAULT_NAMESPACE, gatewayName))

	g.Eventually(func() bool {
		found, _ := objects.SharedAviGraphLister().Get(modelName)
		return found
	}, 25*time.Second).Should(gomega.Equal(true))

	_, aviModel := objects.SharedAviGraphLister().Get(modelName)
	nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()
	g.Expect(nodes).To(gomega.HaveLen(1))
	g.Expect(nodes[0].PortProto).To(gomega.HaveLen(1))
	g.Expect(nodes[0].SSLKeyCertRefs).To(gomega.HaveLen(0))
	g.Expect(nodes[0].VSVIPRefs).To(gomega.HaveLen(1))
	g.Expect(*nodes[0].TrafficEnabled).To(gomega.BeTrue())

	// Key difference: In dedicated mode, EVHParent should be false and Dedicated should be true
	g.Expect(nodes[0].EVHParent).To(gomega.BeFalse())
	g.Expect(nodes[0].Dedicated).To(gomega.BeTrue())

	// In dedicated mode without HTTPRoutes, there might not be any HTTP policies initially
	// This is different from regular mode where a default 404 policy is created
	// The policies are created when HTTPRoutes are attached

	tests.TeardownGateway(t, gatewayName, DEFAULT_NAMESPACE)
	tests.TeardownGatewayClass(t, gatewayClassName)
}

func TestDedicatedGatewayWithTLS(t *testing.T) {
	gatewayName := "gateway-dedicated-02"
	gatewayClassName := "gateway-class-dedicated-02"
	ports := []int32{8443}

	secrets := []string{"secret-dedicated-01"}
	for _, secret := range secrets {
		integrationtest.AddSecret(secret, DEFAULT_NAMESPACE, "cert", "key")
	}

	tests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	listeners := tests.GetDedicatedListenersV1(ports, secrets...)
	tests.SetupDedicatedGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)
	g := gomega.NewGomegaWithT(t)

	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		if gateway.Annotations[akogatewayapilib.DedicatedGatewayModeAnnotation] != "true" {
			t.Logf("Gateway is not in dedicated mode, annotations: %+v", gateway.Annotations)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	modelName := lib.GetModelName(lib.GetTenant(), akogatewayapilib.GetGatewayParentName(DEFAULT_NAMESPACE, gatewayName))

	g.Eventually(func() bool {
		found, _ := objects.SharedAviGraphLister().Get(modelName)
		return found
	}, 25*time.Second).Should(gomega.Equal(true))

	_, aviModel := objects.SharedAviGraphLister().Get(modelName)
	nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()
	g.Expect(nodes).To(gomega.HaveLen(1))
	g.Expect(nodes[0].PortProto).To(gomega.HaveLen(1))
	g.Expect(nodes[0].PortProto[0].EnableSSL).To(gomega.Equal(true))
	g.Expect(nodes[0].SSLKeyCertRefs).To(gomega.HaveLen(1))
	g.Expect(nodes[0].VSVIPRefs).To(gomega.HaveLen(1))

	// Verify dedicated mode properties
	g.Expect(nodes[0].EVHParent).To(gomega.BeFalse())
	g.Expect(nodes[0].Dedicated).To(gomega.BeTrue())

	tests.TeardownGateway(t, gatewayName, DEFAULT_NAMESPACE)
	tests.TeardownGatewayClass(t, gatewayClassName)
	integrationtest.DeleteSecret(secrets[0], DEFAULT_NAMESPACE)
}

func TestGatewayRegularToDedicatedMode(t *testing.T) {
	gatewayName := "gateway-dedicated-03"
	gatewayClassName := "gateway-class-dedicated-03"
	ports := []int32{8080}

	tests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	listeners := tests.GetDedicatedListenersV1(ports)
	// First create regular gateway
	tests.SetupGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)

	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	modelName := lib.GetModelName(lib.GetTenant(), akogatewayapilib.GetGatewayParentName(DEFAULT_NAMESPACE, gatewayName))

	g.Eventually(func() bool {
		found, _ := objects.SharedAviGraphLister().Get(modelName)
		return found
	}, 25*time.Second).Should(gomega.Equal(true))

	_, aviModel := objects.SharedAviGraphLister().Get(modelName)
	nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()
	g.Expect(nodes).To(gomega.HaveLen(1))

	// Verify it's in regular mode initially
	g.Expect(nodes[0].EVHParent).To(gomega.BeTrue())
	g.Expect(nodes[0].Dedicated).To(gomega.BeFalse())

	// Now update to dedicated mode
	tests.UpdateDedicatedGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)

	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	// TODO: remove stale gateway model

	modelName = lib.GetModelName(lib.GetTenant(), akogatewayapilib.GetGatewayParentName(DEFAULT_NAMESPACE, gatewayName))
	g.Eventually(func() bool {
		found, aviModel := objects.SharedAviGraphLister().Get(modelName)
		if !found {
			return false
		}
		nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()
		return len(nodes) > 0 && !nodes[0].EVHParent && nodes[0].Dedicated
	}, 40*time.Second).Should(gomega.Equal(true))

	_, aviModel = objects.SharedAviGraphLister().Get(modelName)
	nodes = aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()
	g.Expect(nodes).To(gomega.HaveLen(1))

	// Verify it's now in dedicated mode
	g.Expect(nodes[0].EVHParent).To(gomega.BeFalse())
	g.Expect(nodes[0].Dedicated).To(gomega.BeTrue())

	tests.TeardownGateway(t, gatewayName, DEFAULT_NAMESPACE)
	tests.TeardownGatewayClass(t, gatewayClassName)
}

func TestGatewayDedicatedToRegularMode(t *testing.T) {
	gatewayName := "gateway-dedicated-04"
	gatewayClassName := "gateway-class-dedicated-04"
	ports := []int32{8080}

	tests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	listeners := tests.GetDedicatedListenersV1(ports)
	// First create dedicated gateway
	tests.SetupDedicatedGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		if gateway.Annotations[akogatewayapilib.DedicatedGatewayModeAnnotation] != "true" {
			t.Logf("Gateway is not in dedicated mode, annotations: %+v", gateway.Annotations)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	modelName := lib.GetModelName(lib.GetTenant(), akogatewayapilib.GetGatewayParentName(DEFAULT_NAMESPACE, gatewayName))

	g.Eventually(func() bool {
		found, _ := objects.SharedAviGraphLister().Get(modelName)
		return found
	}, 25*time.Second).Should(gomega.Equal(true))

	_, aviModel := objects.SharedAviGraphLister().Get(modelName)
	nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()
	g.Expect(nodes).To(gomega.HaveLen(1))

	// Verify it's in dedicated mode initially
	g.Expect(nodes[0].EVHParent).To(gomega.BeFalse())
	g.Expect(nodes[0].Dedicated).To(gomega.BeTrue())

	// Now update to regular mode (remove annotation)
	tests.UpdateGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)

	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	// TODO: remove stale gateway model

	modelName = lib.GetModelName(lib.GetTenant(), akogatewayapilib.GetGatewayParentName(DEFAULT_NAMESPACE, gatewayName))

	g.Eventually(func() bool {
		found, aviModel := objects.SharedAviGraphLister().Get(modelName)
		if !found {
			return false
		}
		nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()
		return len(nodes) > 0 && nodes[0].EVHParent && !nodes[0].Dedicated
	}, 40*time.Second).Should(gomega.Equal(true))

	_, aviModel = objects.SharedAviGraphLister().Get(modelName)
	nodes = aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()
	g.Expect(nodes).To(gomega.HaveLen(1))

	// Verify it's now in regular mode
	g.Expect(nodes[0].EVHParent).To(gomega.BeTrue())
	g.Expect(nodes[0].Dedicated).To(gomega.BeFalse())

	tests.TeardownGateway(t, gatewayName, DEFAULT_NAMESPACE)
	tests.TeardownGatewayClass(t, gatewayClassName)
}

func TestDedicatedGatewayDelete(t *testing.T) {
	gatewayName := "gateway-dedicated-05"
	gatewayClassName := "gateway-class-dedicated-05"
	ports := []int32{8080}

	tests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	listeners := tests.GetDedicatedListenersV1(ports)
	tests.SetupDedicatedGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		if gateway.Annotations[akogatewayapilib.DedicatedGatewayModeAnnotation] != "true" {
			t.Logf("Gateway is not in dedicated mode, annotations: %+v", gateway.Annotations)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	modelName := lib.GetModelName(lib.GetTenant(), akogatewayapilib.GetGatewayParentName(DEFAULT_NAMESPACE, gatewayName))

	g.Eventually(func() bool {
		found, _ := objects.SharedAviGraphLister().Get(modelName)
		return found
	}, 25*time.Second).Should(gomega.Equal(true))

	tests.TeardownGateway(t, gatewayName, DEFAULT_NAMESPACE)

	g.Eventually(func() bool {
		found, gwModel := objects.SharedAviGraphLister().Get(modelName)
		if found {
			return gwModel == nil
		}
		return true
	}, 25*time.Second).Should(gomega.Equal(true))

	tests.TeardownGatewayClass(t, gatewayClassName)
}

func TestDedicatedGatewayWithMultipleListeners(t *testing.T) {
	gatewayName := "gateway-dedicated-06"
	gatewayClassName := "gateway-class-dedicated-06"
	ports := []int32{8080, 8443}

	secrets := []string{"secret-dedicated-02"}
	integrationtest.AddSecret(secrets[0], DEFAULT_NAMESPACE, "cert", "key")

	tests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	listeners := tests.GetDedicatedListenersV1(ports, secrets...)
	tests.SetupDedicatedGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		if gateway.Annotations[akogatewayapilib.DedicatedGatewayModeAnnotation] != "true" {
			t.Logf("Gateway is not in dedicated mode, annotations: %+v", gateway.Annotations)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	modelName := lib.GetModelName(lib.GetTenant(), akogatewayapilib.GetGatewayParentName(DEFAULT_NAMESPACE, gatewayName))

	g.Eventually(func() bool {
		found, _ := objects.SharedAviGraphLister().Get(modelName)
		return found
	}, 25*time.Second).Should(gomega.Equal(true))

	_, aviModel := objects.SharedAviGraphLister().Get(modelName)
	nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()
	g.Expect(nodes).To(gomega.HaveLen(1))
	g.Expect(nodes[0].PortProto).To(gomega.HaveLen(2))
	g.Expect(nodes[0].SSLKeyCertRefs).To(gomega.HaveLen(1))
	g.Expect(nodes[0].VSVIPRefs).To(gomega.HaveLen(1))

	// Verify dedicated mode properties
	g.Expect(nodes[0].EVHParent).To(gomega.BeFalse())
	g.Expect(nodes[0].Dedicated).To(gomega.BeTrue())

	// Check both ports are configured
	g.Expect(nodes[0].PortProto[0].Port).To(gomega.BeElementOf([]int32{8080, 8443}))
	g.Expect(nodes[0].PortProto[1].Port).To(gomega.BeElementOf([]int32{8080, 8443}))

	integrationtest.DeleteSecret(secrets[0], DEFAULT_NAMESPACE)
	tests.TeardownGateway(t, gatewayName, DEFAULT_NAMESPACE)
	tests.TeardownGatewayClass(t, gatewayClassName)

}
func TestDedicatedGatewaySecretCreateDelete(t *testing.T) {
	gatewayName := "gateway-dedicated-08"
	gatewayClassName := "gateway-class-dedicated-08"
	ports := []int32{8443}
	secrets := []string{"secret-dedicated-03"}

	tests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	listeners := tests.GetDedicatedListenersV1(ports, secrets...)
	tests.SetupDedicatedGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)
	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		if gateway.Annotations[akogatewayapilib.DedicatedGatewayModeAnnotation] != "true" {
			t.Logf("Gateway is not in dedicated mode, annotations: %+v", gateway.Annotations)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	modelName := lib.GetModelName(lib.GetTenant(), akogatewayapilib.GetGatewayParentName(DEFAULT_NAMESPACE, gatewayName))
	// Initially no model should exist as secret doesn't exist
	g.Eventually(func() bool {
		found, _ := objects.SharedAviGraphLister().Get(modelName)
		return found
	}, 30*time.Second).Should(gomega.Equal(false))

	integrationtest.AddSecret(secrets[0], DEFAULT_NAMESPACE, "cert", "key")

	g.Eventually(func() bool {
		found, aviModel := objects.SharedAviGraphLister().Get(modelName)
		if found {
			nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()
			g.Expect(nodes).To(gomega.HaveLen(1))
			g.Expect(nodes[0].SSLKeyCertRefs).To(gomega.HaveLen(1))
			// Verify dedicated mode
			g.Expect(nodes[0].EVHParent).To(gomega.BeFalse())
			g.Expect(nodes[0].Dedicated).To(gomega.BeTrue())
			return true
		}
		return found
	}, 30*time.Second).Should(gomega.Equal(true))

	// Update secret
	integrationtest.UpdateSecret(secrets[0], DEFAULT_NAMESPACE, "certnew", "keynew")

	g.Eventually(func() bool {
		found, aviModel := objects.SharedAviGraphLister().Get(modelName)
		if found {
			nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()
			g.Expect(nodes).To(gomega.HaveLen(1))
			g.Expect(nodes[0].SSLKeyCertRefs).To(gomega.HaveLen(1))
			g.Expect(string(nodes[0].SSLKeyCertRefs[0].Cert)).To(gomega.Equal("certnew"))
			g.Expect(string(nodes[0].SSLKeyCertRefs[0].Key)).To(gomega.Equal("keynew"))
			return true
		}
		return found
	}, 30*time.Second).Should(gomega.Equal(true))

	// Delete secret
	integrationtest.DeleteSecret(secrets[0], DEFAULT_NAMESPACE)

	g.Eventually(func() bool {
		_, aviModel := objects.SharedAviGraphLister().Get(modelName)
		return aviModel == nil
	}, 30*time.Second).Should(gomega.Equal(true))

	tests.TeardownGateway(t, gatewayName, DEFAULT_NAMESPACE)
	tests.TeardownGatewayClass(t, gatewayClassName)
}

func TestDedicatedGatewayWithTrafficDisabledAnnotation(t *testing.T) {
	gatewayName := "gateway-dedicated-09"
	gatewayClassName := "gateway-class-dedicated-09"
	ports := []int32{8080}

	tests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	listeners := tests.GetDedicatedListenersV1(ports)

	// Create gateway with both dedicated mode and traffic disabled annotations
	g := &tests.Gateway{}
	g.Gateway = g.GatewayV1(gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)
	if g.Gateway.Annotations == nil {
		g.Gateway.Annotations = make(map[string]string)
	}
	g.Gateway.Annotations[akogatewayapilib.DedicatedGatewayModeAnnotation] = "true"
	g.Gateway.Annotations[lib.VSTrafficDisabled] = "true"
	g.Create(t)

	gomegaG := gomega.NewGomegaWithT(t)

	gomegaG.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	modelName := lib.GetModelName(lib.GetTenant(), akogatewayapilib.GetGatewayParentName(DEFAULT_NAMESPACE, gatewayName))

	gomegaG.Eventually(func() bool {
		found, _ := objects.SharedAviGraphLister().Get(modelName)
		return found
	}, 25*time.Second).Should(gomega.Equal(true))

	_, aviModel := objects.SharedAviGraphLister().Get(modelName)
	nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()
	gomegaG.Expect(nodes).To(gomega.HaveLen(1))
	gomegaG.Expect(nodes[0].PortProto).To(gomega.HaveLen(1))
	gomegaG.Expect(nodes[0].SSLKeyCertRefs).To(gomega.HaveLen(0))
	gomegaG.Expect(nodes[0].VSVIPRefs).To(gomega.HaveLen(1))

	// Verify dedicated mode properties
	gomegaG.Expect(nodes[0].EVHParent).To(gomega.BeFalse())
	gomegaG.Expect(nodes[0].Dedicated).To(gomega.BeTrue())

	// Verify traffic is disabled
	gomegaG.Expect(*nodes[0].TrafficEnabled).To(gomega.BeFalse())

	tests.TeardownGateway(t, gatewayName, DEFAULT_NAMESPACE)
	tests.TeardownGatewayClass(t, gatewayClassName)
}
