package graphlayer

import (
	"context"
	"testing"
	"time"

	"github.com/onsi/gomega"
	corev1 "k8s.io/api/core/v1"
	apimeta "k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
	gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"

	akogatewayapilib "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-gateway-api/lib"
	avinodes "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/nodes"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/objects"
	tests "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/tests/gatewayapitests"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/tests/integrationtest"
)

// @AI-Generated
// [Generated by Cursor claude-4-sonnet]

// TestDedicatedGatewayWithHTTPRoute tests HTTPRoute processing in dedicated mode
// This test is currently failing because HTTPRoute processing is not working in dedicated mode
func TestDedicatedGatewayWithHTTPRoute(t *testing.T) {
	gatewayName := "gateway-dedicated-07"
	gatewayClassName := "gateway-class-dedicated-07"
	httpRouteName := "http-route-dedicated-01"
	ports := []int32{8080}
	// In dedicated mode, the model name has a different suffix
	modelName := "admin/" + akogatewayapilib.Prefix + "cluster--" + DEFAULT_NAMESPACE + "-" + gatewayName + "-L7-dedicated-EVH"

	tests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	listeners := tests.GetDedicatedListenersV1(ports)
	tests.SetupDedicatedGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		if gateway.Annotations[akogatewayapilib.DedicatedGatewayModeAnnotation] != "true" {
			t.Logf("Gateway is not in dedicated mode, annotations: %+v", gateway.Annotations)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	g.Eventually(func() bool {
		found, _ := objects.SharedAviGraphLister().Get(modelName)
		return found
	}, 25*time.Second).Should(gomega.Equal(true))

	// Create service and endpoints
	svcExample := (integrationtest.FakeService{
		Name:         "avisvc-dedicated",
		Namespace:    "default",
		Type:         corev1.ServiceTypeClusterIP,
		ServicePorts: []integrationtest.Serviceport{{PortName: "foo", Protocol: "TCP", PortNumber: 8080, TargetPort: intstr.FromInt(8080)}},
	}).Service()

	_, err := tests.KubeClient.CoreV1().Services("default").Create(context.TODO(), svcExample, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("error in adding Service: %v", err)
	}
	integrationtest.CreateEPS(t, "default", "avisvc-dedicated", false, false, "1.1.1")

	// Create HTTPRoute
	parentRefs := tests.GetParentReferencesV1([]string{gatewayName}, DEFAULT_NAMESPACE, ports)
	rule := tests.GetHTTPRouteRuleV1(integrationtest.PATHPREFIX, []string{"/foo"}, []string{},
		map[string][]string{}, [][]string{{"avisvc-dedicated", "default", "8080", "1"}}, nil)
	rules := []gatewayv1.HTTPRouteRule{rule}
	hostnames := []gatewayv1.Hostname{}
	tests.SetupHTTPRoute(t, httpRouteName, DEFAULT_NAMESPACE, parentRefs, hostnames, rules)

	g.Eventually(func() bool {
		found, aviModel := objects.SharedAviGraphLister().Get(modelName)
		if !found {
			return false
		}
		nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()
		if len(nodes) == 0 {
			return false
		}

		// Check if HTTPRoute has been processed (should have HTTP policies)
		return len(nodes[0].HttpPolicyRefs) > 0
	}, 60*time.Second).Should(gomega.Equal(true))

	_, aviModel := objects.SharedAviGraphLister().Get(modelName)
	nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()

	// Verify dedicated mode properties
	g.Expect(nodes[0].EVHParent).To(gomega.BeFalse())
	g.Expect(nodes[0].Dedicated).To(gomega.BeTrue())

	// In dedicated mode, there should be no child EVH nodes
	g.Expect(nodes[0].EvhNodes).To(gomega.HaveLen(0))

	// HTTPRoute rules should be attached directly to the main VS
	// Should have 1 HTTP policy containing HTTPRoute rules and default-backend-rule
	g.Expect(nodes[0].HttpPolicyRefs).To(gomega.HaveLen(1))
	g.Expect(nodes[0].PoolRefs).To(gomega.HaveLen(1))
	g.Expect(nodes[0].PoolGroupRefs).To(gomega.HaveLen(1))

	// Verify AVI markers include HTTPRoute information
	g.Expect(nodes[0].AviMarkers.HTTPRouteName).To(gomega.Equal(httpRouteName))
	g.Expect(nodes[0].AviMarkers.HTTPRouteNamespace).To(gomega.Equal(DEFAULT_NAMESPACE))

	// Clean up service and endpoints
	integrationtest.DelSVC(t, DEFAULT_NAMESPACE, "avisvc-dedicated")
	integrationtest.DelEPS(t, DEFAULT_NAMESPACE, "avisvc-dedicated")
	tests.TeardownHTTPRoute(t, httpRouteName, DEFAULT_NAMESPACE)
	tests.TeardownGateway(t, gatewayName, DEFAULT_NAMESPACE)
	tests.TeardownGatewayClass(t, gatewayClassName)

}

// TestDedicatedGatewayWithMultipleHTTPRouteRules tests HTTPRoute with multiple rules and path ordering in dedicated mode
func TestDedicatedGatewayWithMultipleHTTPRouteRules(t *testing.T) {
	gatewayName := "gateway-dedicated-multi-rules"
	gatewayClassName := "gateway-class-dedicated-multi-rules"
	httpRouteName := "http-route-dedicated-multi-rules"
	ports := []int32{8080}
	modelName := "admin/" + akogatewayapilib.Prefix + "cluster--" + DEFAULT_NAMESPACE + "-" + gatewayName + "-L7-dedicated-EVH"

	tests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	listeners := tests.GetDedicatedListenersV1(ports)
	tests.SetupDedicatedGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)
	g := gomega.NewGomegaWithT(t)

	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		if gateway.Annotations[akogatewayapilib.DedicatedGatewayModeAnnotation] != "true" {
			t.Logf("Gateway is not in dedicated mode, annotations: %+v", gateway.Annotations)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	g.Eventually(func() bool {
		found, _ := objects.SharedAviGraphLister().Get(modelName)
		return found
	}, 25*time.Second).Should(gomega.Equal(true))

	// Create single service for all backends
	integrationtest.CreateSVC(t, "default", "avisvc-backend", corev1.ProtocolTCP, corev1.ServiceTypeClusterIP, false)
	integrationtest.CreateEPS(t, "default", "avisvc-backend", false, false, "1.1.1")

	// Create HTTPRoute with multiple rules testing path ordering
	parentRefs := tests.GetParentReferencesV1([]string{gatewayName}, DEFAULT_NAMESPACE, ports)

	// Rule 1: Exact match for /api/v1/users (should have highest priority)
	rule1 := tests.GetHTTPRouteRuleV1(akogatewayapilib.EXACT, []string{"/api/v1/users"}, []string{},
		map[string][]string{}, [][]string{{"avisvc-backend", "default", "8080", "1"}}, nil)

	// Rule 2: Path prefix for /api (should have medium priority)
	rule2 := tests.GetHTTPRouteRuleV1(integrationtest.PATHPREFIX, []string{"/api"}, []string{},
		map[string][]string{}, [][]string{{"avisvc-backend", "default", "8080", "1"}}, nil)

	// Rule 3: Path prefix for /admin (should be ordered by length)
	rule3 := tests.GetHTTPRouteRuleV1(integrationtest.PATHPREFIX, []string{"/admin"}, []string{},
		map[string][]string{}, [][]string{{"avisvc-backend", "default", "8080", "1"}}, nil)

	// Rule 4: Regex path matching for API versioning: /api/v[0-9]+/.*
	rule4 := tests.GetHTTPRouteRuleV1(integrationtest.REGULAREXPRESSION, []string{"/api/v[0-9]+/.*"}, []string{},
		map[string][]string{}, [][]string{{"avisvc-backend", "default", "8080", "1"}}, nil)

	rules := []gatewayv1.HTTPRouteRule{rule1, rule2, rule3, rule4}
	hostnames := []gatewayv1.Hostname{}
	tests.SetupHTTPRoute(t, httpRouteName, DEFAULT_NAMESPACE, parentRefs, hostnames, rules)

	g.Eventually(func() bool {
		found, aviModel := objects.SharedAviGraphLister().Get(modelName)
		if !found {
			return false
		}
		nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()
		if len(nodes) == 0 {
			return false
		}

		// Check if HTTPRoute has been processed (should have HTTP policies)
		return len(nodes[0].HttpPolicyRefs) > 0
	}, 30*time.Second).Should(gomega.Equal(true))

	_, aviModel := objects.SharedAviGraphLister().Get(modelName)
	nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()

	// Verify dedicated mode properties
	g.Expect(nodes[0].EVHParent).To(gomega.BeFalse())
	g.Expect(nodes[0].Dedicated).To(gomega.BeTrue())

	// In dedicated mode, there should be no child EVH nodes
	g.Expect(nodes[0].EvhNodes).To(gomega.HaveLen(0))

	// HTTPRoute rules should be attached directly to the main VS
	// Should have 1 HTTP policy since one of the paths is "/" (root path doesn't create default backend policy)
	g.Expect(nodes[0].HttpPolicyRefs).To(gomega.HaveLen(1))

	// Should have 4 pools (one for each rule)
	g.Eventually(func() bool {
		return len(nodes[0].PoolRefs) == 4 && len(nodes[0].PoolGroupRefs) == 4
	}, 30*time.Second).Should(gomega.Equal(true))

	// Verify AVI markers include HTTPRoute information
	g.Expect(nodes[0].AviMarkers.HTTPRouteName).To(gomega.Equal(httpRouteName))
	g.Expect(nodes[0].AviMarkers.HTTPRouteNamespace).To(gomega.Equal(DEFAULT_NAMESPACE))

	// Verify HTTP policy has correct number of request rules (4 HTTPRoute rules with one default-backend-rule)
	httpPolicy := nodes[0].HttpPolicyRefs[0]
	g.Expect(httpPolicy.RequestRules).To(gomega.HaveLen(5))

	// Verify rule ordering: Exact match should come first, then longest path prefixes, then regex
	// The rules should be ordered by path match type priority and then by path length
	expectedPaths := []string{"/api/v1/users", "/admin", "/api", "/api/v[0-9]+/.*", "/"}
	for i, rule := range httpPolicy.RequestRules {
		if i < len(expectedPaths) {
			// For non-regex rules, check MatchStr
			if rule.Match.Path.MatchCriteria != nil && *rule.Match.Path.MatchCriteria != "REGEX_MATCH" {
				g.Expect(rule.Match.Path.MatchStr).To(gomega.Equal([]string{expectedPaths[i]}))
				i++
			} else if rule.Match.Path.MatchCriteria != nil && *rule.Match.Path.MatchCriteria == "REGEX_MATCH" {
				g.Expect(rule.Match.Path.MatchStr).To(gomega.BeEmpty())
				g.Expect(rule.Match.Path.StringGroupRefs).ToNot(gomega.BeEmpty())
				i++
			}
		}
	}

	// Verify string group is created for regex pattern
	g.Expect(nodes[0].StringGroupRefs).To(gomega.HaveLen(1))
	stringGroup := nodes[0].StringGroupRefs[0]
	g.Expect(stringGroup.StringGroup.Kv).To(gomega.HaveLen(1))
	g.Expect(*stringGroup.StringGroup.Kv[0].Key).To(gomega.Equal("/api/v[0-9]+/.*"))

	// Clean up
	integrationtest.DelSVC(t, DEFAULT_NAMESPACE, "avisvc-backend")
	integrationtest.DelEPS(t, DEFAULT_NAMESPACE, "avisvc-backend")
	tests.TeardownHTTPRoute(t, httpRouteName, DEFAULT_NAMESPACE)
	tests.TeardownGateway(t, gatewayName, DEFAULT_NAMESPACE)
	tests.TeardownGatewayClass(t, gatewayClassName)
}

// TestDedicatedGatewayWithHeaderMatching tests HTTPRoute with header matching in dedicated mode
func TestDedicatedGatewayWithHeaderMatching(t *testing.T) {
	gatewayName := "gateway-dedicated-header-match"
	gatewayClassName := "gateway-class-dedicated-header-match"
	httpRouteName := "http-route-dedicated-header-match"
	ports := []int32{8080}
	modelName := "admin/" + akogatewayapilib.Prefix + "cluster--" + DEFAULT_NAMESPACE + "-" + gatewayName + "-L7-dedicated-EVH"

	tests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	listeners := tests.GetDedicatedListenersV1(ports)
	tests.SetupDedicatedGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		if gateway.Annotations[akogatewayapilib.DedicatedGatewayModeAnnotation] != "true" {
			t.Logf("Gateway is not in dedicated mode, annotations: %+v", gateway.Annotations)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	g.Eventually(func() bool {
		found, _ := objects.SharedAviGraphLister().Get(modelName)
		return found
	}, 25*time.Second).Should(gomega.Equal(true))

	// Create single service for all backends
	integrationtest.CreateSVC(t, "default", "avisvc-backend", corev1.ProtocolTCP, corev1.ServiceTypeClusterIP, false)
	integrationtest.CreateEPS(t, "default", "avisvc-backend", false, false, "1.1.1")

	// Create HTTPRoute with header matching
	parentRefs := tests.GetParentReferencesV1([]string{gatewayName}, DEFAULT_NAMESPACE, ports)

	// Rule 1: Match requests with API version header
	rule1 := tests.GetHTTPRouteRuleV1(integrationtest.PATHPREFIX, []string{"/api"}, []string{"x-api-version:v1"},
		map[string][]string{}, [][]string{{"avisvc-backend", "default", "8080", "1"}}, nil)

	// Rule 2: Match requests with mobile user agent
	rule2 := tests.GetHTTPRouteRuleV1(integrationtest.PATHPREFIX, []string{"/"}, []string{"user-agent:mobile"},
		map[string][]string{}, [][]string{{"avisvc-backend", "default", "8080", "1"}}, nil)

	rules := []gatewayv1.HTTPRouteRule{rule1, rule2}
	hostnames := []gatewayv1.Hostname{}
	tests.SetupHTTPRoute(t, httpRouteName, DEFAULT_NAMESPACE, parentRefs, hostnames, rules)

	g.Eventually(func() bool {
		found, aviModel := objects.SharedAviGraphLister().Get(modelName)
		if !found {
			return false
		}
		nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()
		if len(nodes) == 0 {
			return false
		}

		// Check if HTTPRoute has been processed (should have HTTP policies)
		return len(nodes[0].HttpPolicyRefs) > 0
	}, 60*time.Second).Should(gomega.Equal(true))

	_, aviModel := objects.SharedAviGraphLister().Get(modelName)
	nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()

	// Verify dedicated mode properties
	g.Expect(nodes[0].EVHParent).To(gomega.BeFalse())
	g.Expect(nodes[0].Dedicated).To(gomega.BeTrue())

	// In dedicated mode, there should be no child EVH nodes
	g.Expect(nodes[0].EvhNodes).To(gomega.HaveLen(0))

	// HTTPRoute rules should be attached directly to the main VS
	// Should have 1 HTTP policy since one of the paths is "/" (root path doesn't create default backend policy)
	g.Expect(nodes[0].HttpPolicyRefs).To(gomega.HaveLen(1))

	// Should have 2 pools (one for each rule)
	g.Expect(nodes[0].PoolRefs).To(gomega.HaveLen(2))
	g.Expect(nodes[0].PoolGroupRefs).To(gomega.HaveLen(2))

	// Verify AVI markers include HTTPRoute information
	g.Expect(nodes[0].AviMarkers.HTTPRouteName).To(gomega.Equal(httpRouteName))
	g.Expect(nodes[0].AviMarkers.HTTPRouteNamespace).To(gomega.Equal(DEFAULT_NAMESPACE))

	// Verify HTTP policy has correct number of request rules (2 HTTPRoute rules, no default-backend-rule since we have root path)
	httpPolicy := nodes[0].HttpPolicyRefs[0]
	g.Expect(httpPolicy.RequestRules).To(gomega.HaveLen(2))

	// Verify header matching is configured in the HTTPRoute rules
	for _, rule := range httpPolicy.RequestRules {
		g.Expect(rule.Match.Hdrs).ToNot(gomega.BeEmpty())
		// Each rule should have exactly one header match
		g.Expect(rule.Match.Hdrs).To(gomega.HaveLen(1))

		// Verify header match criteria
		hdrMatch := rule.Match.Hdrs[0]
		g.Expect(*hdrMatch.MatchCriteria).To(gomega.Equal("HDR_EQUALS"))
		g.Expect(*hdrMatch.MatchCase).To(gomega.Equal("SENSITIVE"))
	}

	// Clean up
	integrationtest.DelSVC(t, DEFAULT_NAMESPACE, "avisvc-backend")
	integrationtest.DelEPS(t, DEFAULT_NAMESPACE, "avisvc-backend")
	tests.TeardownHTTPRoute(t, httpRouteName, DEFAULT_NAMESPACE)
	tests.TeardownGateway(t, gatewayName, DEFAULT_NAMESPACE)
	tests.TeardownGatewayClass(t, gatewayClassName)
}

// TestDedicatedGatewayWithRequestFilters tests HTTPRoute with request filters in dedicated mode
func TestDedicatedGatewayWithRequestFilters(t *testing.T) {
	gatewayName := "gateway-dedicated-req-filters"
	gatewayClassName := "gateway-class-dedicated-req-filters"
	httpRouteName := "http-route-dedicated-req-filters"
	ports := []int32{8080}
	modelName := "admin/" + akogatewayapilib.Prefix + "cluster--" + DEFAULT_NAMESPACE + "-" + gatewayName + "-L7-dedicated-EVH"

	tests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	listeners := tests.GetDedicatedListenersV1(ports)
	tests.SetupDedicatedGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		if gateway.Annotations[akogatewayapilib.DedicatedGatewayModeAnnotation] != "true" {
			t.Logf("Gateway is not in dedicated mode, annotations: %+v", gateway.Annotations)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	g.Eventually(func() bool {
		found, _ := objects.SharedAviGraphLister().Get(modelName)
		return found
	}, 25*time.Second).Should(gomega.Equal(true))

	// Create single service for all backends
	integrationtest.CreateSVC(t, "default", "avisvc-backend", corev1.ProtocolTCP, corev1.ServiceTypeClusterIP, false)
	integrationtest.CreateEPS(t, "default", "avisvc-backend", false, false, "1.1.1")

	// Create HTTPRoute with different request filters
	parentRefs := tests.GetParentReferencesV1([]string{gatewayName}, DEFAULT_NAMESPACE, ports)

	// Rule 1: Request header modification
	rule1 := tests.GetHTTPRouteRuleV1(integrationtest.PATHPREFIX, []string{"/api"}, []string{},
		map[string][]string{"RequestHeaderModifier": {"add", "remove", "replace"}},
		[][]string{{"avisvc-backend", "default", "8080", "1"}}, nil)

	// Rule 2: Request redirect
	rule2 := tests.GetHTTPRouteRuleV1(integrationtest.PATHPREFIX, []string{"/old"}, []string{},
		map[string][]string{"RequestRedirect": {}},
		[][]string{{"avisvc-backend", "default", "8080", "1"}}, nil)

	// Rule 3: URL rewrite
	rule3 := tests.GetHTTPRouteRuleV1(integrationtest.PATHPREFIX, []string{"/rewrite"}, []string{},
		map[string][]string{"URLRewrite": {}},
		[][]string{{"avisvc-backend", "default", "8080", "1"}}, nil)

	rules := []gatewayv1.HTTPRouteRule{rule1, rule2, rule3}
	hostnames := []gatewayv1.Hostname{}
	tests.SetupHTTPRoute(t, httpRouteName, DEFAULT_NAMESPACE, parentRefs, hostnames, rules)

	g.Eventually(func() bool {
		found, aviModel := objects.SharedAviGraphLister().Get(modelName)
		if !found {
			return false
		}
		nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()
		if len(nodes) == 0 {
			return false
		}

		// Check if HTTPRoute has been processed (should have HTTP policies)
		return len(nodes[0].HttpPolicyRefs) > 0
	}, 60*time.Second).Should(gomega.Equal(true))

	_, aviModel := objects.SharedAviGraphLister().Get(modelName)
	nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()

	// Verify dedicated mode properties
	g.Expect(nodes[0].EVHParent).To(gomega.BeFalse())
	g.Expect(nodes[0].Dedicated).To(gomega.BeTrue())

	// In dedicated mode, there should be no child EVH nodes
	g.Expect(nodes[0].EvhNodes).To(gomega.HaveLen(0))

	// HTTPRoute rules should be attached directly to the main VS
	// Should have 1 HTTP policy containing HTTPRoute rules and default-backend-rule (since all paths are non-root)
	g.Expect(nodes[0].HttpPolicyRefs).To(gomega.HaveLen(1))

	// Should have 3 pools (one for each rule)
	g.Expect(nodes[0].PoolRefs).To(gomega.HaveLen(3))
	g.Expect(nodes[0].PoolGroupRefs).To(gomega.HaveLen(3))

	// Verify AVI markers include HTTPRoute information
	g.Expect(nodes[0].AviMarkers.HTTPRouteName).To(gomega.Equal(httpRouteName))
	g.Expect(nodes[0].AviMarkers.HTTPRouteNamespace).To(gomega.Equal(DEFAULT_NAMESPACE))

	// Verify HTTP policy has correct number of request rules (3 HTTPRoute rules + 1 default-backend-rule)
	httpPolicy := nodes[0].HttpPolicyRefs[0]
	g.Expect(httpPolicy.RequestRules).To(gomega.HaveLen(4))

	// Verify the last rule is the default-backend-rule
	lastRule := httpPolicy.RequestRules[len(httpPolicy.RequestRules)-1]
	g.Expect(*lastRule.Name).To(gomega.Equal("default-backend-rule"))
	g.Expect(*lastRule.SwitchingAction.Action).To(gomega.Equal("HTTP_SWITCHING_SELECT_LOCAL"))
	g.Expect(*lastRule.SwitchingAction.StatusCode).To(gomega.Equal("HTTP_LOCAL_RESPONSE_STATUS_CODE_404"))

	// Verify request filters are applied
	for _, rule := range httpPolicy.RequestRules {
		// Check for header actions (add, remove, replace)
		if len(rule.HdrAction) > 0 {
			g.Expect(rule.HdrAction).ToNot(gomega.BeEmpty())
			// Should have header actions for add, remove, replace
			g.Expect(*rule.HdrAction[0].Action).To(gomega.Equal("HTTP_ADD_HDR"))
			g.Expect(*rule.HdrAction[1].Action).To(gomega.Equal("HTTP_REPLACE_HDR"))
			g.Expect(*rule.HdrAction[2].Action).To(gomega.Equal("HTTP_REMOVE_HDR"))
		}

		// Check for redirect action
		if rule.RedirectAction != nil {
			g.Expect(rule.RedirectAction.Host).ToNot(gomega.BeNil())
			g.Expect(rule.RedirectAction.StatusCode).ToNot(gomega.BeNil())
		}

		// Check for URL rewrite action
		if rule.RewriteURLAction != nil {
			g.Expect(rule.RewriteURLAction.Path).ToNot(gomega.BeNil())
			g.Expect(rule.RewriteURLAction.HostHdr).ToNot(gomega.BeNil())
		}
	}

	// Clean up
	integrationtest.DelSVC(t, DEFAULT_NAMESPACE, "avisvc-backend")
	integrationtest.DelEPS(t, DEFAULT_NAMESPACE, "avisvc-backend")
	tests.TeardownHTTPRoute(t, httpRouteName, DEFAULT_NAMESPACE)
	tests.TeardownGateway(t, gatewayName, DEFAULT_NAMESPACE)
	tests.TeardownGatewayClass(t, gatewayClassName)
}

// TestDedicatedGatewayWithResponseFilters tests HTTPRoute with response filters in dedicated mode
func TestDedicatedGatewayWithResponseFilters(t *testing.T) {
	gatewayName := "gateway-dedicated-resp-filters"
	gatewayClassName := "gateway-class-dedicated-resp-filters"
	httpRouteName := "http-route-dedicated-resp-filters"
	ports := []int32{8080}
	modelName := "admin/" + akogatewayapilib.Prefix + "cluster--" + DEFAULT_NAMESPACE + "-" + gatewayName + "-L7-dedicated-EVH"

	tests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	listeners := tests.GetDedicatedListenersV1(ports)
	tests.SetupDedicatedGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)
	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		if gateway.Annotations[akogatewayapilib.DedicatedGatewayModeAnnotation] != "true" {
			t.Logf("Gateway is not in dedicated mode, annotations: %+v", gateway.Annotations)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	g.Eventually(func() bool {
		found, _ := objects.SharedAviGraphLister().Get(modelName)
		return found
	}, 25*time.Second).Should(gomega.Equal(true))

	// Create service for backend
	svcExample := (integrationtest.FakeService{
		Name:         "avisvc-backend",
		Namespace:    "default",
		Type:         corev1.ServiceTypeClusterIP,
		ServicePorts: []integrationtest.Serviceport{{PortName: "foo", Protocol: "TCP", PortNumber: 8080, TargetPort: intstr.FromInt(8080)}},
	}).Service()

	_, err := tests.KubeClient.CoreV1().Services("default").Create(context.TODO(), svcExample, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("error in adding Service: %v", err)
	}
	integrationtest.CreateEPS(t, "default", "avisvc-backend", false, false, "1.1.1")

	// Create HTTPRoute with response filters
	parentRefs := tests.GetParentReferencesV1([]string{gatewayName}, DEFAULT_NAMESPACE, ports)

	// Rule with response header modification
	rule := tests.GetHTTPRouteRuleV1(integrationtest.PATHPREFIX, []string{"/api"}, []string{},
		map[string][]string{"ResponseHeaderModifier": {"add", "remove", "replace"}},
		[][]string{{"avisvc-backend", "default", "8080", "1"}}, nil)

	rules := []gatewayv1.HTTPRouteRule{rule}
	hostnames := []gatewayv1.Hostname{}
	tests.SetupHTTPRoute(t, httpRouteName, DEFAULT_NAMESPACE, parentRefs, hostnames, rules)

	g.Eventually(func() bool {
		found, aviModel := objects.SharedAviGraphLister().Get(modelName)
		if !found {
			return false
		}
		nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()
		if len(nodes) == 0 {
			return false
		}

		// Check if HTTPRoute has been processed (should have HTTP policies)
		return len(nodes[0].HttpPolicyRefs) > 0
	}, 60*time.Second).Should(gomega.Equal(true))

	_, aviModel := objects.SharedAviGraphLister().Get(modelName)
	nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()

	// Verify dedicated mode properties
	g.Expect(nodes[0].EVHParent).To(gomega.BeFalse())
	g.Expect(nodes[0].Dedicated).To(gomega.BeTrue())

	// In dedicated mode, there should be no child EVH nodes
	g.Expect(nodes[0].EvhNodes).To(gomega.HaveLen(0))

	// HTTPRoute rules should be attached directly to the main VS
	// Should have 1 HTTP policy containing HTTPRoute rules and default-backend-rule (since path is non-root)
	g.Expect(nodes[0].HttpPolicyRefs).To(gomega.HaveLen(1))

	// Should have 1 pool
	g.Expect(nodes[0].PoolRefs).To(gomega.HaveLen(1))
	g.Expect(nodes[0].PoolGroupRefs).To(gomega.HaveLen(1))

	// Verify AVI markers include HTTPRoute information
	g.Expect(nodes[0].AviMarkers.HTTPRouteName).To(gomega.Equal(httpRouteName))
	g.Expect(nodes[0].AviMarkers.HTTPRouteNamespace).To(gomega.Equal(DEFAULT_NAMESPACE))

	// Verify HTTP policy has response rules and default-backend-rule
	httpPolicy := nodes[0].HttpPolicyRefs[0]
	g.Expect(httpPolicy.RequestRules).To(gomega.HaveLen(2)) // 1 HTTPRoute rule + 1 default-backend-rule
	g.Expect(httpPolicy.ResponseRules).To(gomega.HaveLen(1))

	// Verify the last rule is the default-backend-rule
	lastRule := httpPolicy.RequestRules[1]
	g.Expect(*lastRule.Name).To(gomega.Equal("default-backend-rule"))

	// Verify response filters are applied
	responseRule := httpPolicy.ResponseRules[0]
	g.Expect(responseRule.HdrAction).ToNot(gomega.BeEmpty())
	// Should have header actions for add, remove, replace
	g.Expect(*responseRule.HdrAction[0].Action).To(gomega.Equal("HTTP_ADD_HDR"))
	g.Expect(*responseRule.HdrAction[1].Action).To(gomega.Equal("HTTP_REPLACE_HDR"))
	g.Expect(*responseRule.HdrAction[2].Action).To(gomega.Equal("HTTP_REMOVE_HDR"))

	// Clean up
	integrationtest.DelSVC(t, DEFAULT_NAMESPACE, "avisvc-backend")
	integrationtest.DelEPS(t, DEFAULT_NAMESPACE, "avisvc-backend")
	tests.TeardownHTTPRoute(t, httpRouteName, DEFAULT_NAMESPACE)
	tests.TeardownGateway(t, gatewayName, DEFAULT_NAMESPACE)
	tests.TeardownGatewayClass(t, gatewayClassName)
}

// TestDedicatedGatewayWithMultipleBackends tests HTTPRoute with multiple backends and weight distribution in dedicated mode
func TestDedicatedGatewayWithMultipleBackends(t *testing.T) {
	gatewayName := "gateway-dedicated-multi-backends"
	gatewayClassName := "gateway-class-dedicated-multi-backends"
	httpRouteName := "http-route-dedicated-multi-backends"
	ports := []int32{8080}
	modelName := "admin/" + akogatewayapilib.Prefix + "cluster--" + DEFAULT_NAMESPACE + "-" + gatewayName + "-L7-dedicated-EVH"

	tests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	listeners := tests.GetDedicatedListenersV1(ports)
	tests.SetupDedicatedGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		if gateway.Annotations[akogatewayapilib.DedicatedGatewayModeAnnotation] != "true" {
			t.Logf("Gateway is not in dedicated mode, annotations: %+v", gateway.Annotations)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	g.Eventually(func() bool {
		found, _ := objects.SharedAviGraphLister().Get(modelName)
		return found
	}, 25*time.Second).Should(gomega.Equal(true))

	// Create single service for all backends (demonstrating weight distribution with same service)
	integrationtest.CreateSVC(t, "default", "avisvc-backend", corev1.ProtocolTCP, corev1.ServiceTypeClusterIP, false)
	integrationtest.CreateEPS(t, "default", "avisvc-backend", false, false, "1.1.1")

	// Create HTTPRoute with multiple backends with different weights
	parentRefs := tests.GetParentReferencesV1([]string{gatewayName}, DEFAULT_NAMESPACE, ports)

	// Rule with multiple backend references to same service with different weights: 70% + 20% + 10%
	rule := tests.GetHTTPRouteRuleV1(integrationtest.PATHPREFIX, []string{"/api"}, []string{},
		map[string][]string{},
		[][]string{
			{"avisvc-backend", "default", "8080", "70"},
			{"avisvc-backend", "default", "8080", "20"},
			{"avisvc-backend", "default", "8080", "10"},
		}, nil)

	rules := []gatewayv1.HTTPRouteRule{rule}
	hostnames := []gatewayv1.Hostname{}
	tests.SetupHTTPRoute(t, httpRouteName, DEFAULT_NAMESPACE, parentRefs, hostnames, rules)

	g.Eventually(func() bool {
		found, aviModel := objects.SharedAviGraphLister().Get(modelName)
		if !found {
			return false
		}
		nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()
		if len(nodes) == 0 {
			return false
		}

		// Check if HTTPRoute has been processed (should have HTTP policies)
		return len(nodes[0].HttpPolicyRefs) > 0
	}, 60*time.Second).Should(gomega.Equal(true))

	_, aviModel := objects.SharedAviGraphLister().Get(modelName)
	nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()

	// Verify dedicated mode properties
	g.Expect(nodes[0].EVHParent).To(gomega.BeFalse())
	g.Expect(nodes[0].Dedicated).To(gomega.BeTrue())

	// In dedicated mode, there should be no child EVH nodes
	g.Expect(nodes[0].EvhNodes).To(gomega.HaveLen(0))

	// HTTPRoute rules should be attached directly to the main VS
	// Should have 1 HTTP policy containing HTTPRoute rules and default-backend-rule (since path is non-root)
	g.Expect(nodes[0].HttpPolicyRefs).To(gomega.HaveLen(1))

	// Should have 1 pool (same service referenced multiple times creates only one pool)
	// AVI optimizes by creating a single pool when the same service is referenced multiple times
	g.Expect(nodes[0].PoolRefs).To(gomega.HaveLen(1))
	g.Expect(nodes[0].PoolGroupRefs).To(gomega.HaveLen(1))

	// Verify AVI markers include HTTPRoute information
	g.Expect(nodes[0].AviMarkers.HTTPRouteName).To(gomega.Equal(httpRouteName))
	g.Expect(nodes[0].AviMarkers.HTTPRouteNamespace).To(gomega.Equal(DEFAULT_NAMESPACE))

	// Verify pool group has correct members with weights
	poolGroup := nodes[0].PoolGroupRefs[0]
	// When same service is referenced multiple times with different weights, AVI creates separate members
	// even though they point to the same pool, because each has different weight
	g.Expect(poolGroup.Members).To(gomega.HaveLen(3))

	// Verify weights are correctly set (70, 20, 10)
	expectedWeights := []uint32{70, 20, 10}
	actualWeights := make([]uint32, len(poolGroup.Members))
	for i, member := range poolGroup.Members {
		actualWeights[i] = *member.Ratio
	}
	g.Expect(actualWeights).To(gomega.ConsistOf(expectedWeights))

	// Clean up
	integrationtest.DelSVC(t, DEFAULT_NAMESPACE, "avisvc-backend")
	integrationtest.DelEPS(t, DEFAULT_NAMESPACE, "avisvc-backend")
	tests.TeardownHTTPRoute(t, httpRouteName, DEFAULT_NAMESPACE)
	tests.TeardownGateway(t, gatewayName, DEFAULT_NAMESPACE)
	tests.TeardownGatewayClass(t, gatewayClassName)
}

// TestDedicatedGatewayWithRegexPathMatching tests HTTPRoute with regular expression path matching in dedicated mode
func TestDedicatedGatewayWithRegexPathMatching(t *testing.T) {
	gatewayName := "gateway-dedicated-regex"
	gatewayClassName := "gateway-class-dedicated-regex"
	httpRouteName := "http-route-dedicated-regex"
	ports := []int32{8080}
	modelName := "admin/" + akogatewayapilib.Prefix + "cluster--" + DEFAULT_NAMESPACE + "-" + gatewayName + "-L7-dedicated-EVH"

	tests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	listeners := tests.GetDedicatedListenersV1(ports)
	tests.SetupDedicatedGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)
	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		if gateway.Annotations[akogatewayapilib.DedicatedGatewayModeAnnotation] != "true" {
			t.Logf("Gateway is not in dedicated mode, annotations: %+v", gateway.Annotations)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	g.Eventually(func() bool {
		found, _ := objects.SharedAviGraphLister().Get(modelName)
		return found
	}, 25*time.Second).Should(gomega.Equal(true))

	// Create service for backend
	svcExample := (integrationtest.FakeService{
		Name:         "avisvc-regex",
		Namespace:    "default",
		Type:         corev1.ServiceTypeClusterIP,
		ServicePorts: []integrationtest.Serviceport{{PortName: "foo", Protocol: "TCP", PortNumber: 8080, TargetPort: intstr.FromInt(8080)}},
	}).Service()

	_, err := tests.KubeClient.CoreV1().Services("default").Create(context.TODO(), svcExample, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("error in adding Service: %v", err)
	}
	integrationtest.CreateEPS(t, "default", "avisvc-regex", false, false, "1.1.1")

	// Create HTTPRoute with regex path matching
	parentRefs := tests.GetParentReferencesV1([]string{gatewayName}, DEFAULT_NAMESPACE, ports)

	// Rule with regex path matching for API versioning: /api/v[0-9]+/.*
	rule := tests.GetHTTPRouteRuleV1(integrationtest.REGULAREXPRESSION, []string{"/api/v[0-9]+/.*"}, []string{},
		map[string][]string{},
		[][]string{{"avisvc-regex", "default", "8080", "1"}}, nil)

	rules := []gatewayv1.HTTPRouteRule{rule}
	hostnames := []gatewayv1.Hostname{}
	tests.SetupHTTPRoute(t, httpRouteName, DEFAULT_NAMESPACE, parentRefs, hostnames, rules)

	g.Eventually(func() bool {
		found, aviModel := objects.SharedAviGraphLister().Get(modelName)
		if !found {
			return false
		}
		nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()
		if len(nodes) == 0 {
			return false
		}

		// Check if HTTPRoute has been processed (should have HTTP policies)
		return len(nodes[0].HttpPolicyRefs) > 0
	}, 60*time.Second).Should(gomega.Equal(true))

	_, aviModel := objects.SharedAviGraphLister().Get(modelName)
	nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()

	// Verify dedicated mode properties
	g.Expect(nodes[0].EVHParent).To(gomega.BeFalse())
	g.Expect(nodes[0].Dedicated).To(gomega.BeTrue())

	// In dedicated mode, there should be no child EVH nodes
	g.Expect(nodes[0].EvhNodes).To(gomega.HaveLen(0))

	// HTTPRoute rules should be attached directly to the main VS
	// Should have 1 HTTP policy containing HTTPRoute rules and default-backend-rule (since path is non-root)
	g.Expect(nodes[0].HttpPolicyRefs).To(gomega.HaveLen(1))

	// Should have 1 pool
	g.Expect(nodes[0].PoolRefs).To(gomega.HaveLen(1))
	g.Expect(nodes[0].PoolGroupRefs).To(gomega.HaveLen(1))

	// Verify AVI markers include HTTPRoute information
	g.Expect(nodes[0].AviMarkers.HTTPRouteName).To(gomega.Equal(httpRouteName))
	g.Expect(nodes[0].AviMarkers.HTTPRouteNamespace).To(gomega.Equal(DEFAULT_NAMESPACE))

	// Verify HTTP policy has regex matching configured and default-backend-rule
	httpPolicy := nodes[0].HttpPolicyRefs[0]
	g.Expect(httpPolicy.RequestRules).To(gomega.HaveLen(2)) // 1 HTTPRoute rule + 1 default-backend-rule

	// Verify the last rule is the default-backend-rule
	lastRule := httpPolicy.RequestRules[1]
	g.Expect(*lastRule.Name).To(gomega.Equal("default-backend-rule"))

	// Verify regex path matching is configured
	requestRule := httpPolicy.RequestRules[0]
	g.Expect(*requestRule.Match.Path.MatchCriteria).To(gomega.Equal("REGEX_MATCH"))
	g.Expect(requestRule.Match.Path.MatchStr).To(gomega.BeEmpty()) // Regex uses string groups, not MatchStr
	g.Expect(requestRule.Match.Path.StringGroupRefs).ToNot(gomega.BeEmpty())

	// Verify string group is created for regex pattern
	g.Expect(nodes[0].StringGroupRefs).To(gomega.HaveLen(1))
	stringGroup := nodes[0].StringGroupRefs[0]
	g.Expect(stringGroup.StringGroup.Kv).To(gomega.HaveLen(1))
	g.Expect(*stringGroup.StringGroup.Kv[0].Key).To(gomega.Equal("/api/v[0-9]+/.*"))

	// Clean up
	integrationtest.DelSVC(t, DEFAULT_NAMESPACE, "avisvc-regex")
	integrationtest.DelEPS(t, DEFAULT_NAMESPACE, "avisvc-regex")
	tests.TeardownHTTPRoute(t, httpRouteName, DEFAULT_NAMESPACE)
	tests.TeardownGateway(t, gatewayName, DEFAULT_NAMESPACE)
	tests.TeardownGatewayClass(t, gatewayClassName)
}

// TestDedicatedGatewayComplexScenario tests a complex scenario combining multiple features in dedicated mode
func TestDedicatedGatewayComplexScenario(t *testing.T) {
	gatewayName := "gateway-dedicated-complex"
	gatewayClassName := "gateway-class-dedicated-complex"
	httpRouteName := "http-route-dedicated-complex"
	ports := []int32{8080}
	modelName := "admin/" + akogatewayapilib.Prefix + "cluster--" + DEFAULT_NAMESPACE + "-" + gatewayName + "-L7-dedicated-EVH"

	tests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	listeners := tests.GetDedicatedListenersV1(ports)
	tests.SetupDedicatedGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		if gateway.Annotations[akogatewayapilib.DedicatedGatewayModeAnnotation] != "true" {
			t.Logf("Gateway is not in dedicated mode, annotations: %+v", gateway.Annotations)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	g.Eventually(func() bool {
		found, _ := objects.SharedAviGraphLister().Get(modelName)
		return found
	}, 25*time.Second).Should(gomega.Equal(true))

	// Create single service for all backends
	integrationtest.CreateSVC(t, "default", "avisvc-complex", corev1.ProtocolTCP, corev1.ServiceTypeClusterIP, false)
	integrationtest.CreateEPS(t, "default", "avisvc-complex", false, false, "1.1.1")

	// Create complex HTTPRoute with multiple rules, filters, and backends
	parentRefs := tests.GetParentReferencesV1([]string{gatewayName}, DEFAULT_NAMESPACE, ports)

	// Rule 1: Exact match for admin with header matching and request header modification
	rule1 := tests.GetHTTPRouteRuleV1(akogatewayapilib.EXACT, []string{"/admin"}, []string{"x-admin-token:secret"},
		map[string][]string{"RequestHeaderModifier": {"add"}},
		[][]string{{"avisvc-complex", "default", "8080", "1"}}, nil)

	// Rule 2: API v2 with multiple backend references and response header modification
	rule2 := tests.GetHTTPRouteRuleV1(integrationtest.PATHPREFIX, []string{"/api/v2"}, []string{},
		map[string][]string{"ResponseHeaderModifier": {"add", "replace"}},
		[][]string{
			{"avisvc-complex", "default", "8080", "80"},
			{"avisvc-complex", "default", "8080", "20"}, // Multiple references to same service
		}, nil)

	// Rule 3: API v1 with URL rewrite
	rule3 := tests.GetHTTPRouteRuleV1(integrationtest.PATHPREFIX, []string{"/api/v1"}, []string{},
		map[string][]string{"URLRewrite": {}},
		[][]string{{"avisvc-complex", "default", "8080", "1"}}, nil)

	// Rule 4: Default web traffic
	rule4 := tests.GetHTTPRouteRuleV1(integrationtest.PATHPREFIX, []string{"/"}, []string{},
		map[string][]string{},
		[][]string{{"avisvc-complex", "default", "8080", "1"}}, nil)

	rules := []gatewayv1.HTTPRouteRule{rule1, rule2, rule3, rule4}
	hostnames := []gatewayv1.Hostname{}
	tests.SetupHTTPRoute(t, httpRouteName, DEFAULT_NAMESPACE, parentRefs, hostnames, rules)

	g.Eventually(func() bool {
		found, aviModel := objects.SharedAviGraphLister().Get(modelName)
		if !found {
			return false
		}
		nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()
		if len(nodes) == 0 {
			return false
		}

		// Check if HTTPRoute has been processed (should have HTTP policies)
		return len(nodes[0].HttpPolicyRefs) > 0
	}, 60*time.Second).Should(gomega.Equal(true))

	_, aviModel := objects.SharedAviGraphLister().Get(modelName)
	nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()

	// Verify dedicated mode properties
	g.Expect(nodes[0].EVHParent).To(gomega.BeFalse())
	g.Expect(nodes[0].Dedicated).To(gomega.BeTrue())

	// In dedicated mode, there should be no child EVH nodes
	g.Expect(nodes[0].EvhNodes).To(gomega.HaveLen(0))

	// HTTPRoute rules should be attached directly to the main VS
	// Should have 1 HTTP policy since one of the paths is "/" (root path doesn't create default backend policy)
	g.Eventually(func() bool {
		return len(nodes[0].HttpPolicyRefs) == 1 &&
			len(nodes[0].PoolRefs) == 4 &&
			len(nodes[0].PoolGroupRefs) == 4
	}, 30*time.Second).Should(gomega.Equal(true))

	// Verify AVI markers include HTTPRoute information
	g.Expect(nodes[0].AviMarkers.HTTPRouteName).To(gomega.Equal(httpRouteName))
	g.Expect(nodes[0].AviMarkers.HTTPRouteNamespace).To(gomega.Equal(DEFAULT_NAMESPACE))

	// Verify HTTP policy has correct number of rules (4 HTTPRoute rules, no default-backend-rule since we have root path)
	httpPolicy := nodes[0].HttpPolicyRefs[0]
	g.Expect(httpPolicy.RequestRules).To(gomega.HaveLen(4))
	g.Expect(httpPolicy.ResponseRules).To(gomega.HaveLen(1)) // Only rule2 has response filters

	// Verify rule ordering: Exact match first, then by path length
	expectedPaths := []string{"/admin", "/api/v2", "/api/v1", "/"}
	for i, rule := range httpPolicy.RequestRules {
		if i < len(expectedPaths) {
			g.Expect(rule.Match.Path.MatchStr).To(gomega.ContainElement(expectedPaths[i]))
		}
	}

	// Verify complex features are configured
	hasHeaderMatch := false
	hasHeaderAction := false
	hasRewriteAction := false

	for _, rule := range httpPolicy.RequestRules {
		if len(rule.Match.Hdrs) > 0 {
			hasHeaderMatch = true
		}
		if len(rule.HdrAction) > 0 {
			hasHeaderAction = true
		}
		if rule.RewriteURLAction != nil {
			hasRewriteAction = true
		}
	}

	g.Expect(hasHeaderMatch).To(gomega.BeTrue())
	g.Expect(hasHeaderAction).To(gomega.BeTrue())
	g.Expect(hasRewriteAction).To(gomega.BeTrue())

	// Clean up
	integrationtest.DelSVC(t, DEFAULT_NAMESPACE, "avisvc-complex")
	integrationtest.DelEPS(t, DEFAULT_NAMESPACE, "avisvc-complex")
	tests.TeardownHTTPRoute(t, httpRouteName, DEFAULT_NAMESPACE)
	tests.TeardownGateway(t, gatewayName, DEFAULT_NAMESPACE)
	tests.TeardownGatewayClass(t, gatewayClassName)
}

// TestDedicatedGatewayWithMultipleMatches tests HTTPRoute with 2 rules having multiple matches in dedicated mode
func TestDedicatedGatewayWithMultipleMatches(t *testing.T) {
	gatewayName := "gateway-dedicated-multi-matches"
	gatewayClassName := "gateway-class-dedicated-multi-matches"
	httpRouteName := "http-route-dedicated-multi-matches"
	ports := []int32{8080}
	modelName := "admin/" + akogatewayapilib.Prefix + "cluster--" + DEFAULT_NAMESPACE + "-" + gatewayName + "-L7-dedicated-EVH"

	tests.SetupGatewayClass(t, gatewayClassName, akogatewayapilib.GatewayController)
	listeners := tests.GetDedicatedListenersV1(ports)
	tests.SetupDedicatedGateway(t, gatewayName, DEFAULT_NAMESPACE, gatewayClassName, nil, listeners)

	g := gomega.NewGomegaWithT(t)
	g.Eventually(func() bool {
		gateway, err := tests.GatewayClient.GatewayV1().Gateways(DEFAULT_NAMESPACE).Get(context.TODO(), gatewayName, metav1.GetOptions{})
		if err != nil || gateway == nil {
			t.Logf("Couldn't get the gateway, err: %+v", err)
			return false
		}
		if gateway.Annotations[akogatewayapilib.DedicatedGatewayModeAnnotation] != "true" {
			t.Logf("Gateway is not in dedicated mode, annotations: %+v", gateway.Annotations)
			return false
		}
		return apimeta.FindStatusCondition(gateway.Status.Conditions, string(gatewayv1.GatewayConditionAccepted)) != nil
	}, 30*time.Second).Should(gomega.Equal(true))

	g.Eventually(func() bool {
		found, _ := objects.SharedAviGraphLister().Get(modelName)
		return found
	}, 25*time.Second).Should(gomega.Equal(true))

	// Create single service for all backends
	integrationtest.CreateSVC(t, "default", "avisvc-multi-match", corev1.ProtocolTCP, corev1.ServiceTypeClusterIP, false)
	integrationtest.CreateEPS(t, "default", "avisvc-multi-match", false, false, "1.1.1")

	// Create HTTPRoute with 2 rules having multiple matches each
	parentRefs := tests.GetParentReferencesV1([]string{gatewayName}, DEFAULT_NAMESPACE, ports)

	// Rule 1: Multiple path matches with multiple header matches
	// This rule matches multiple API endpoints with version and auth headers
	rule1 := tests.GetHTTPRouteRuleV1(integrationtest.PATHPREFIX,
		[]string{"/api/v1", "/api/v2", "/api/v3"},            // Multiple path matches
		[]string{"x-api-version:v1", "authorization:Bearer"}, // Multiple header matches
		map[string][]string{},
		[][]string{{"avisvc-multi-match", "default", "8080", "1"}}, nil)

	// Rule 2: Multiple path matches with different header combinations
	// This rule matches admin and management endpoints with admin tokens
	rule2 := tests.GetHTTPRouteRuleV1(akogatewayapilib.EXACT,
		[]string{"/admin", "/management", "/dashboard"},       // Multiple exact path matches
		[]string{"x-admin-token:secret", "x-role:admin"},      // Multiple header matches
		map[string][]string{"RequestHeaderModifier": {"add"}}, // Add request header modification
		[][]string{{"avisvc-multi-match", "default", "8080", "1"}}, nil)

	rules := []gatewayv1.HTTPRouteRule{rule1, rule2}
	hostnames := []gatewayv1.Hostname{}
	tests.SetupHTTPRoute(t, httpRouteName, DEFAULT_NAMESPACE, parentRefs, hostnames, rules)

	g.Eventually(func() bool {
		found, aviModel := objects.SharedAviGraphLister().Get(modelName)
		if !found {
			return false
		}
		nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()
		if len(nodes) == 0 {
			return false
		}

		// Check if HTTPRoute has been processed (should have HTTP policies)
		return len(nodes[0].HttpPolicyRefs) > 0
	}, 60*time.Second).Should(gomega.Equal(true))

	_, aviModel := objects.SharedAviGraphLister().Get(modelName)
	nodes := aviModel.(*avinodes.AviObjectGraph).GetAviEvhVS()

	// Verify dedicated mode properties
	g.Expect(nodes[0].EVHParent).To(gomega.BeFalse())
	g.Expect(nodes[0].Dedicated).To(gomega.BeTrue())

	// In dedicated mode, there should be no child EVH nodes
	g.Expect(nodes[0].EvhNodes).To(gomega.HaveLen(0))

	// HTTPRoute rules should be attached directly to the main VS
	// Should have 1 HTTP policy containing HTTPRoute rules and default-backend-rule
	g.Eventually(func() bool {
		return len(nodes[0].HttpPolicyRefs) == 1
	}, 30*time.Second).Should(gomega.Equal(true))

	// Should have 2 pools (one for each rule)
	g.Eventually(func() bool {
		return len(nodes[0].PoolRefs) == 2 && len(nodes[0].PoolGroupRefs) == 2
	}, 30*time.Second).Should(gomega.Equal(true))

	// Verify AVI markers include HTTPRoute information
	g.Expect(nodes[0].AviMarkers.HTTPRouteName).To(gomega.Equal(httpRouteName))
	g.Expect(nodes[0].AviMarkers.HTTPRouteNamespace).To(gomega.Equal(DEFAULT_NAMESPACE))

	// Verify HTTP policies have correct number of request rules
	// Each HTTPRoute rule with multiple matches creates separate AVI request rules
	// Rule 1: 3 paths × 2 headers = 6 combinations
	// Rule 2: 3 paths × 2 headers = 6 combinations
	// Total: 6 HTTPRoute rules + 1 default-backend-rule = 7 rules

	httpPolicy := nodes[0].HttpPolicyRefs[0]
	g.Expect(httpPolicy.RequestRules).To(gomega.HaveLen(7)) // 6 HTTPRoute rules + 1 default-backend-rule

	// Verify the last rule is the default-backend-rule
	lastRule := httpPolicy.RequestRules[6]
	g.Expect(*lastRule.Name).To(gomega.Equal("default-backend-rule"))
	g.Expect(*lastRule.SwitchingAction.Action).To(gomega.Equal("HTTP_SWITCHING_SELECT_LOCAL"))
	g.Expect(*lastRule.SwitchingAction.StatusCode).To(gomega.Equal("HTTP_LOCAL_RESPONSE_STATUS_CODE_404"))

	// Verify HTTPRoute rules (first 6 rules)
	httpRouteRules := httpPolicy.RequestRules[:len(httpPolicy.RequestRules)-1] // All except the last (default) rule
	g.Expect(len(httpRouteRules)).To(gomega.Equal(6))                          // 6 combinations

	// Verify that HTTPRoute rules contain the actual HTTPRoute rules
	// The 6 rules should be combinations of paths and headers from both HTTPRoute rules

	allPaths := []string{"/management", "/dashboard", "/admin", "/api/v1", "/api/v2", "/api/v3", "/"}

	for i, rule := range httpRouteRules {
		// Each rule should have path matching
		g.Expect(rule.Match.Path.MatchStr).ToNot(gomega.BeEmpty())
		g.Expect(rule.Match.Path.MatchStr).To(gomega.Equal([]string{allPaths[i]}))

		// Each rule should have header matching
		g.Expect(rule.Match.Hdrs).ToNot(gomega.BeEmpty())
		g.Expect(rule.Match.Hdrs).To(gomega.HaveLen(2)) // Each rule has 2 header matches

		// Verify header match criteria
		for _, hdrMatch := range rule.Match.Hdrs {
			g.Expect(*hdrMatch.MatchCriteria).To(gomega.Equal("HDR_EQUALS"))
			g.Expect(*hdrMatch.MatchCase).To(gomega.Equal("SENSITIVE"))
		}

		// Check if this rule has header modification (from rule2)
		if len(rule.HdrAction) > 0 {
			// This should be from the second HTTPRoute rule (Exact matching with header modification)
			g.Expect(*rule.Match.Path.MatchCriteria).To(gomega.Equal("EQUALS"))
			adminPaths := []string{"/admin", "/management", "/dashboard"}
			g.Expect(rule.Match.Path.MatchStr).To(gomega.ContainElement(gomega.BeElementOf(adminPaths)))
		} else {
			// This should be from the first HTTPRoute rule (PathPrefix matching)
			g.Expect(*rule.Match.Path.MatchCriteria).To(gomega.Equal("BEGINS_WITH"))
			apiPaths := []string{"/api/v1", "/api/v2", "/api/v3"}
			g.Expect(rule.Match.Path.MatchStr).To(gomega.ContainElement(gomega.BeElementOf(apiPaths)))
		}
	}

	// Clean up
	integrationtest.DelSVC(t, DEFAULT_NAMESPACE, "avisvc-multi-match")
	integrationtest.DelEPS(t, DEFAULT_NAMESPACE, "avisvc-multi-match")
	tests.TeardownHTTPRoute(t, httpRouteName, DEFAULT_NAMESPACE)
	tests.TeardownGateway(t, gatewayName, DEFAULT_NAMESPACE)
	tests.TeardownGatewayClass(t, gatewayClassName)
}
