/*
 * Copyright 2024 VMware, Inc.
 * All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*   http://www.apache.org/licenses/LICENSE-2.0
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

// @AI-Generated
// This test file was generated by Claude AI assistant.

package lib

import (
	"fmt"
	"strings"
	"testing"

	"google.golang.org/protobuf/proto"

	"github.com/vmware/alb-sdk/go/models"
)

func TestGenerateSecurePassword(t *testing.T) {
	t.Run("BasicGeneration", func(t *testing.T) {
		password, err := generateSecurePassword()
		if err != nil {
			t.Fatalf("generateSecurePassword failed: %v", err)
		}

		// Check length
		if len(password) != 16 {
			t.Errorf("Expected length 16, got %d", len(password))
		}

		// Check character set
		validChars := "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
		for i, c := range password {
			if !strings.ContainsRune(validChars, c) {
				t.Errorf("Invalid character at position %d: %c", i, c)
			}
		}
	})

	t.Run("Uniqueness", func(t *testing.T) {
		passwords := make(map[string]bool)
		for i := 0; i < 50; i++ {
			password, err := generateSecurePassword()
			if err != nil {
				t.Fatalf("generateSecurePassword failed on iteration %d: %v", i, err)
			}
			if passwords[password] {
				t.Errorf("Duplicate password generated: %s", password)
			}
			passwords[password] = true
		}
	})
}

// TestValidateRolePermissions tests permission validation logic
func TestValidateRolePermissions(t *testing.T) {
	t.Run("ValidPermissions", func(t *testing.T) {
		role := &models.Role{
			Name: proto.String("valid-role"),
			Privileges: []*models.Permission{
				{Resource: proto.String("PERMISSION_VIRTUALSERVICE"), Type: proto.String("WRITE_ACCESS")},
				{Resource: proto.String("PERMISSION_POOL"), Type: proto.String("READ_ACCESS")},
			},
		}

		expected := []AKOPermission{
			{"PERMISSION_VIRTUALSERVICE", "WRITE_ACCESS"},
			{"PERMISSION_POOL", "READ_ACCESS"},
		}

		err := validateRolePermissions(role, expected)
		if err != nil {
			t.Errorf("Expected no error, got: %v", err)
		}
	})

	t.Run("MissingPermissions", func(t *testing.T) {
		role := &models.Role{
			Name: proto.String("incomplete-role"),
			Privileges: []*models.Permission{
				{Resource: proto.String("PERMISSION_VIRTUALSERVICE"), Type: proto.String("WRITE_ACCESS")},
			},
		}

		expected := []AKOPermission{
			{"PERMISSION_VIRTUALSERVICE", "WRITE_ACCESS"},
			{"PERMISSION_POOL", "READ_ACCESS"},
		}

		err := validateRolePermissions(role, expected)
		if err == nil {
			t.Fatal("Expected error for missing permissions")
		}
		if !strings.Contains(err.Error(), "missing permissions") {
			t.Errorf("Expected 'missing permissions' in error, got: %v", err)
		}
	})

	t.Run("WrongPermissionType", func(t *testing.T) {
		role := &models.Role{
			Name: proto.String("wrong-type-role"),
			Privileges: []*models.Permission{
				{Resource: proto.String("PERMISSION_VIRTUALSERVICE"), Type: proto.String("READ_ACCESS")},
			},
		}

		expected := []AKOPermission{
			{"PERMISSION_VIRTUALSERVICE", "WRITE_ACCESS"},
		}

		err := validateRolePermissions(role, expected)
		if err == nil {
			t.Fatal("Expected error for wrong permission type")
		}
		if !strings.Contains(err.Error(), "permission mismatch") {
			t.Errorf("Expected 'permission mismatch' in error, got: %v", err)
		}
	})

	t.Run("NoPrivileges", func(t *testing.T) {
		role := &models.Role{
			Name:       proto.String("empty-role"),
			Privileges: nil,
		}

		expected := []AKOPermission{
			{"PERMISSION_VIRTUALSERVICE", "WRITE_ACCESS"},
		}

		err := validateRolePermissions(role, expected)
		if err == nil {
			t.Fatal("Expected error for role with no privileges")
		}
		if !strings.Contains(err.Error(), "no privileges defined") {
			t.Errorf("Expected 'no privileges defined' in error, got: %v", err)
		}
	})

	t.Run("ExtraPermissions", func(t *testing.T) {
		role := &models.Role{
			Name: proto.String("extra-perms-role"),
			Privileges: []*models.Permission{
				{Resource: proto.String("PERMISSION_VIRTUALSERVICE"), Type: proto.String("WRITE_ACCESS")},
				{Resource: proto.String("PERMISSION_EXTRA"), Type: proto.String("READ_ACCESS")},
			},
		}

		expected := []AKOPermission{
			{"PERMISSION_VIRTUALSERVICE", "WRITE_ACCESS"},
		}

		// Extra permissions should not cause error (only warning)
		err := validateRolePermissions(role, expected)
		if err != nil {
			t.Errorf("Expected no error for extra permissions, got: %v", err)
		}
	})
}

// TestCreateClusterRoles tests cluster role creation
func TestCreateClusterRoles(t *testing.T) {
	t.Run("NilClient", func(t *testing.T) {
		_, err := CreateClusterRoles(nil, "test", "tenant")
		if err == nil {
			t.Fatal("Expected error for nil client")
		}
		expected := "avi Controller client not available - ensure AKO infra is properly initialized"
		if err.Error() != expected {
			t.Errorf("Expected error %q, got %q", expected, err.Error())
		}
	})

	t.Run("RoleNameGeneration", func(t *testing.T) {
		cluster := "my-cluster"

		// Test shared role names (no cluster prefix)
		sharedAdminRole := "vks-admin-role"
		sharedAllTenantsRole := "vks-all-tenants-role"

		// Test cluster-specific role name
		clusterTenantRole := fmt.Sprintf("%s-tenant-role", cluster)

		if sharedAdminRole != "vks-admin-role" {
			t.Error("Shared admin role name incorrect")
		}
		if clusterTenantRole != "my-cluster-tenant-role" {
			t.Error("Cluster-specific tenant role name generation incorrect")
		}
		if sharedAllTenantsRole != "vks-all-tenants-role" {
			t.Error("Shared all-tenants role name incorrect")
		}
	})

	t.Run("SharedRoleOptimization", func(t *testing.T) {
		// Test that shared roles are used for admin and all-tenants permissions
		cluster1 := "cluster-1"
		cluster2 := "cluster-2"

		// Both clusters should use the same shared role names
		sharedAdminRole := "vks-admin-role"
		sharedAllTenantsRole := "vks-all-tenants-role"

		// But different cluster-specific tenant roles
		cluster1TenantRole := fmt.Sprintf("%s-tenant-role", cluster1)
		cluster2TenantRole := fmt.Sprintf("%s-tenant-role", cluster2)

		// Verify admin and all-tenants roles are shared
		if sharedAdminRole != "vks-admin-role" {
			t.Error("Admin role should be shared across clusters")
		}
		if sharedAllTenantsRole != "vks-all-tenants-role" {
			t.Error("All-tenants role should be shared across clusters")
		}

		// Verify tenant roles are cluster-specific
		if cluster1TenantRole == cluster2TenantRole {
			t.Error("Tenant roles should be cluster-specific")
		}
		if cluster1TenantRole != "cluster-1-tenant-role" {
			t.Error("Cluster 1 tenant role name incorrect")
		}
		if cluster2TenantRole != "cluster-2-tenant-role" {
			t.Error("Cluster 2 tenant role name incorrect")
		}
	})

	t.Run("RoleUpdateCapability", func(t *testing.T) {
		// Test that roles can be updated when permissions change
		// This verifies the auto-update mechanism for role evolution

		// Simulate role name construction
		adminRoleName := "vks-admin-role"
		allTenantsRoleName := "vks-all-tenants-role"
		clusterTenantRoleName := fmt.Sprintf("%s-tenant-role", "test-cluster")

		// Verify consistent naming
		if adminRoleName != "vks-admin-role" {
			t.Error("Admin role name should be consistent across updates")
		}
		if allTenantsRoleName != "vks-all-tenants-role" {
			t.Error("All-tenants role name should be consistent across updates")
		}
		if clusterTenantRoleName != "test-cluster-tenant-role" {
			t.Error("Cluster tenant role should include cluster name")
		}

		// Test role update detection logic would be here in integration tests
		// The system will detect outdated permissions and recreate roles automatically
	})

	// Note: Full integration tests with real Avi client would be in integration test suite
	// These unit tests focus on the business logic that can be tested in isolation
}

// TestCreateClusterUserWithRoles tests user creation
func TestCreateClusterUserWithRoles(t *testing.T) {
	t.Run("NilClient", func(t *testing.T) {
		roles := &ClusterRoles{}
		_, _, err := CreateClusterUserWithRoles(nil, "test", roles, "tenant")
		if err == nil {
			t.Fatal("Expected error for nil client")
		}
		expected := "avi Controller client not available - ensure AKO infra is properly initialized"
		if err.Error() != expected {
			t.Errorf("Expected error %q, got %q", expected, err.Error())
		}
	})

	t.Run("UserNameGeneration", func(t *testing.T) {
		cluster := "test-cluster"
		expected := fmt.Sprintf("%s-user", cluster)
		if expected != "test-cluster-user" {
			t.Error("User name generation incorrect")
		}
	})

	t.Run("UserAccessStructure", func(t *testing.T) {
		// Test user access role structure
		tenant := "my-tenant"
		roles := &ClusterRoles{
			AdminRole:      &models.Role{UUID: proto.String("admin-uuid")},
			TenantRole:     &models.Role{UUID: proto.String("tenant-uuid")},
			AllTenantsRole: &models.Role{UUID: proto.String("all-uuid")},
		}

		userAccess := []*models.UserRole{
			{
				RoleRef:   roles.AdminRole.UUID,
				TenantRef: proto.String("/api/tenant/?name=admin"),
			},
			{
				RoleRef:   roles.TenantRole.UUID,
				TenantRef: proto.String(fmt.Sprintf("/api/tenant/?name=%s", tenant)),
			},
			{
				RoleRef:    roles.AllTenantsRole.UUID,
				AllTenants: proto.Bool(true),
			},
		}

		if len(userAccess) != 3 {
			t.Error("Expected 3 user access roles")
		}

		// Check admin role
		if *userAccess[0].RoleRef != "admin-uuid" {
			t.Error("Admin role ref incorrect")
		}
		if *userAccess[0].TenantRef != "/api/tenant/?name=admin" {
			t.Error("Admin tenant ref incorrect")
		}

		// Check tenant role
		if *userAccess[1].RoleRef != "tenant-uuid" {
			t.Error("Tenant role ref incorrect")
		}
		if *userAccess[1].TenantRef != "/api/tenant/?name=my-tenant" {
			t.Error("Tenant ref incorrect")
		}

		// Check all-tenants role
		if *userAccess[2].RoleRef != "all-uuid" {
			t.Error("All-tenants role ref incorrect")
		}
		if !*userAccess[2].AllTenants {
			t.Error("AllTenants should be true")
		}
	})
}

// TestDeleteClusterRoles tests role deletion
func TestDeleteClusterRoles(t *testing.T) {
	t.Run("NilClientHandling", func(t *testing.T) {
		err := DeleteClusterRoles(nil, "test")
		if err != nil {
			t.Errorf("Should handle nil client gracefully, got: %v", err)
		}
	})

	t.Run("ClusterSpecificRoleDeletion", func(t *testing.T) {
		cluster := "del-cluster"

		// Only cluster-specific tenant role is deleted (shared roles are preserved)
		clusterTenantRole := fmt.Sprintf("%s-tenant-role", cluster)

		if clusterTenantRole != "del-cluster-tenant-role" {
			t.Errorf("Expected cluster-specific tenant role name del-cluster-tenant-role, got %s", clusterTenantRole)
		}

		// Verify shared roles are NOT in deletion list
		sharedRoles := []string{"vks-admin-role", "vks-all-tenants-role"}
		for _, shared := range sharedRoles {
			if strings.Contains(shared, cluster) {
				t.Errorf("Shared role %s should not contain cluster name", shared)
			}
		}
	})
}

// TestDeleteClusterUser tests user deletion
func TestDeleteClusterUser(t *testing.T) {
	t.Run("NilClientHandling", func(t *testing.T) {
		err := DeleteClusterUser(nil, "test")
		if err != nil {
			t.Errorf("Should handle nil client gracefully, got: %v", err)
		}
	})

	t.Run("UserNameConstruction", func(t *testing.T) {
		cluster := "del-user-cluster"
		expected := fmt.Sprintf("%s-user", cluster)
		if expected != "del-user-cluster-user" {
			t.Error("User name construction for deletion incorrect")
		}
	})
}

// TestPermissionConstants tests the permission constant arrays
func TestPermissionConstants(t *testing.T) {
	t.Run("AdminPermissions", func(t *testing.T) {
		if len(akoAdminPermissions) == 0 {
			t.Error("Admin permissions should not be empty")
		}

		// Check for critical permissions
		found := make(map[string]bool)
		for _, perm := range akoAdminPermissions {
			found[perm.Resource] = true
		}

		critical := []string{"PERMISSION_CLOUD", "PERMISSION_TENANT"}
		for _, crit := range critical {
			if !found[crit] {
				t.Errorf("Missing critical admin permission: %s", crit)
			}
		}
	})

	t.Run("TenantPermissions", func(t *testing.T) {
		if len(akoTenantPermissions) == 0 {
			t.Error("Tenant permissions should not be empty")
		}

		// Check for critical permissions
		found := make(map[string]bool)
		for _, perm := range akoTenantPermissions {
			found[perm.Resource] = true
		}

		critical := []string{"PERMISSION_VIRTUALSERVICE", "PERMISSION_POOL"}
		for _, crit := range critical {
			if !found[crit] {
				t.Errorf("Missing critical tenant permission: %s", crit)
			}
		}
	})

	t.Run("AllTenantsPermissions", func(t *testing.T) {
		if len(akoAllTenantsPermissions) == 0 {
			t.Error("All-tenants permissions should not be empty")
		}

		// Check for controller permission
		found := false
		for _, perm := range akoAllTenantsPermissions {
			if perm.Resource == "PERMISSION_CONTROLLER" {
				found = true
				break
			}
		}
		if !found {
			t.Error("Missing PERMISSION_CONTROLLER in all-tenants permissions")
		}
	})

	t.Run("PermissionStructure", func(t *testing.T) {
		allPerms := [][]AKOPermission{
			akoAdminPermissions,
			akoTenantPermissions,
			akoAllTenantsPermissions,
		}
		names := []string{"admin", "tenant", "all-tenants"}

		for i, perms := range allPerms {
			for j, perm := range perms {
				// Check non-empty resource
				if perm.Resource == "" {
					t.Errorf("%s permission %d has empty resource", names[i], j)
				}

				// Check valid type
				if perm.Type != "READ_ACCESS" && perm.Type != "WRITE_ACCESS" {
					t.Errorf("%s permission %d has invalid type: %s", names[i], j, perm.Type)
				}

				// Check naming convention
				if !strings.HasPrefix(perm.Resource, "PERMISSION_") {
					t.Errorf("%s permission %d doesn't follow naming convention: %s", names[i], j, perm.Resource)
				}
			}
		}
	})
}

// TestClusterFilterConstruction tests the cluster filter logic
func TestClusterFilterConstruction(t *testing.T) {
	t.Run("FilterStructure", func(t *testing.T) {
		cluster := "filter-cluster"

		filter := &models.RoleFilter{
			MatchOperation: proto.String("ROLE_FILTER_EQUALS"),
			MatchLabel: &models.RoleFilterMatchLabel{
				Key:    proto.String("clustername"),
				Values: []string{cluster},
			},
			Enabled: proto.Bool(true),
		}

		// Verify structure
		if *filter.MatchOperation != "ROLE_FILTER_EQUALS" {
			t.Error("Expected ROLE_FILTER_EQUALS")
		}

		if *filter.MatchLabel.Key != "clustername" {
			t.Error("Expected key 'clustername'")
		}

		if len(filter.MatchLabel.Values) != 1 || filter.MatchLabel.Values[0] != cluster {
			t.Error("Expected cluster name in values")
		}

		if !*filter.Enabled {
			t.Error("Expected filter to be enabled")
		}
	})
}

// TestDataStructures tests the struct definitions
func TestDataStructures(t *testing.T) {
	t.Run("ClusterCredentials", func(t *testing.T) {
		creds := &ClusterCredentials{
			Username: "testuser",
			Password: "testpass",
		}

		if creds.Username != "testuser" {
			t.Errorf("Expected username 'testuser', got %s", creds.Username)
		}
		if creds.Password != "testpass" {
			t.Errorf("Expected password 'testpass', got %s", creds.Password)
		}
	})

	t.Run("ClusterRoles", func(t *testing.T) {
		admin := &models.Role{Name: proto.String("admin")}
		tenant := &models.Role{Name: proto.String("tenant")}
		allTenants := &models.Role{Name: proto.String("all")}

		roles := &ClusterRoles{
			AdminRole:      admin,
			TenantRole:     tenant,
			AllTenantsRole: allTenants,
		}

		if roles.AdminRole != admin {
			t.Error("AdminRole not set correctly")
		}
		if roles.TenantRole != tenant {
			t.Error("TenantRole not set correctly")
		}
		if roles.AllTenantsRole != allTenants {
			t.Error("AllTenantsRole not set correctly")
		}
	})

	t.Run("AKOPermission", func(t *testing.T) {
		perm := AKOPermission{
			Resource: "PERMISSION_TEST",
			Type:     "WRITE_ACCESS",
		}

		if perm.Resource != "PERMISSION_TEST" {
			t.Errorf("Expected resource 'PERMISSION_TEST', got %s", perm.Resource)
		}
		if perm.Type != "WRITE_ACCESS" {
			t.Errorf("Expected type 'WRITE_ACCESS', got %s", perm.Type)
		}
	})
}

// BenchmarkGenerateSecurePassword benchmarks password generation
func BenchmarkGenerateSecurePassword(b *testing.B) {
	for i := 0; i < b.N; i++ {
		_, err := generateSecurePassword()
		if err != nil {
			b.Fatalf("generateSecurePassword failed: %v", err)
		}
	}
}

// BenchmarkValidateRolePermissions benchmarks permission validation
func BenchmarkValidateRolePermissions(b *testing.B) {
	role := &models.Role{
		Name: proto.String("bench-role"),
		Privileges: []*models.Permission{
			{Resource: proto.String("PERMISSION_VIRTUALSERVICE"), Type: proto.String("WRITE_ACCESS")},
			{Resource: proto.String("PERMISSION_POOL"), Type: proto.String("READ_ACCESS")},
		},
	}

	perms := []AKOPermission{
		{"PERMISSION_VIRTUALSERVICE", "WRITE_ACCESS"},
		{"PERMISSION_POOL", "READ_ACCESS"},
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		err := validateRolePermissions(role, perms)
		if err != nil {
			b.Fatalf("validateRolePermissions failed: %v", err)
		}
	}
}
