// @AI-Generated
// [Generated by Cursor claude-4-sonnet]
package session

import (
	"context"
	"os"
	"sync"
	"testing"

	"github.com/golang/mock/gomock"
	"github.com/stretchr/testify/assert"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-crd-operator/internal/event"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-crd-operator/test/mock"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/lib"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/utils"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/kubernetes"
	kubefake "k8s.io/client-go/kubernetes/fake"
)

// createFakeK8sClient creates a fake kubernetes client for testing
func createFakeK8sClient(objects ...runtime.Object) kubernetes.Interface {
	return kubefake.NewSimpleClientset(objects...)
}

func TestNewSession(t *testing.T) {
	eventManager := &event.EventManager{}
	k8sClient := createFakeK8sClient()

	session := NewSession(k8sClient, eventManager)

	assert.NotNil(t, session)
	assert.NotNil(t, session.sync)
	assert.Equal(t, utils.AVIAPI_INITIATING, session.status)
	assert.Equal(t, k8sClient, session.k8sClient)
	assert.Equal(t, eventManager, session.eventManager)
	assert.NotNil(t, session.ctrlProperties)
	assert.NotNil(t, session.aviRestClientPoolFactory)
}

func TestPopulateControllerProperties(t *testing.T) {
	tests := []struct {
		name        string
		setupSecret func() *corev1.Secret
		wantErr     bool
		wantProps   map[string]string
	}{
		{
			name: "success: populate properties from secret",
			setupSecret: func() *corev1.Secret {
				return &corev1.Secret{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "avi-secret",
						Namespace: utils.GetAKONamespace(),
					},
					Data: map[string][]byte{
						"username":                 []byte("admin"),
						"password":                 []byte("password123"),
						"authtoken":                []byte("token123"),
						"certificateAuthorityData": []byte("ca-data"),
					},
				}
			},
			wantErr: false,
			wantProps: map[string]string{
				utils.ENV_CTRL_USERNAME:  "admin",
				utils.ENV_CTRL_PASSWORD:  "password123",
				utils.ENV_CTRL_AUTHTOKEN: "token123",
				utils.ENV_CTRL_CADATA:    "ca-data",
			},
		},
		{
			name: "error: secret not found",
			setupSecret: func() *corev1.Secret {
				return nil // No secret
			},
			wantErr:   true,
			wantProps: nil,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var k8sClient kubernetes.Interface
			if tt.setupSecret() != nil {
				k8sClient = createFakeK8sClient(tt.setupSecret())
			} else {
				k8sClient = createFakeK8sClient()
			}

			eventManager := &event.EventManager{}
			session := NewSession(k8sClient, eventManager)

			err := session.PopulateControllerProperties(context.Background())

			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
				for key, expectedValue := range tt.wantProps {
					assert.Equal(t, expectedValue, session.ctrlProperties[key])
				}
			}
		})
	}
}

func TestCreateAviClients(t *testing.T) {
	tests := []struct {
		name              string
		ctrlProperties    map[string]string
		setupControllerIP func()
		setupEnv          func() func() // Setup function that returns cleanup function
		prepareMock       func(*mock.MockAviRestClientPoolFactory)
		wantStatus        string
		wantVersion       string
		wantErr           bool
		wantClientPool    bool
	}{
		{
			name: "success: create clients with password",
			ctrlProperties: map[string]string{
				utils.ENV_CTRL_USERNAME:  "admin",
				utils.ENV_CTRL_PASSWORD:  "password123",
				utils.ENV_CTRL_AUTHTOKEN: "",
				utils.ENV_CTRL_CADATA:    "ca-data",
			},
			setupControllerIP: func() { lib.SetControllerIP("10.1.1.1") },
			prepareMock: func(mockFactory *mock.MockAviRestClientPoolFactory) {
				mockClientPool := &utils.AviRestClientPool{}
				mockFactory.EXPECT().NewAviRestClientPool(
					1, "10.1.1.1", "admin", "password123", "", "", "ca-data", "admin", "", gomock.Any(),
				).Return(mockClientPool, utils.MaxAviVersion, nil)
			},
			wantStatus:     utils.AVIAPI_CONNECTED,
			wantVersion:    utils.MaxAviVersion,
			wantClientPool: true,
		},
		{
			name: "success: create clients with auth token",
			ctrlProperties: map[string]string{
				utils.ENV_CTRL_USERNAME:  "admin",
				utils.ENV_CTRL_PASSWORD:  "",
				utils.ENV_CTRL_AUTHTOKEN: "token123",
				utils.ENV_CTRL_CADATA:    "ca-data",
			},
			setupControllerIP: func() { lib.SetControllerIP("10.1.1.1") },
			prepareMock: func(mockFactory *mock.MockAviRestClientPoolFactory) {
				mockClientPool := &utils.AviRestClientPool{}
				mockFactory.EXPECT().NewAviRestClientPool(
					1, "10.1.1.1", "admin", "", "token123", "", "ca-data", "admin", "", gomock.Any(),
				).Return(mockClientPool, utils.MaxAviVersion, nil)
			},
			wantStatus:     utils.AVIAPI_CONNECTED,
			wantVersion:    utils.MaxAviVersion,
			wantClientPool: true,
		},
		{
			name: "success: create clients from environment variables",
			ctrlProperties: map[string]string{
				utils.ENV_CTRL_USERNAME:  "admin",
				utils.ENV_CTRL_PASSWORD:  "password123",
				utils.ENV_CTRL_AUTHTOKEN: "",
				utils.ENV_CTRL_CADATA:    "ca-data",
			},
			setupControllerIP: func() { lib.SetControllerIP("") }, // Clear to read from env
			setupEnv: func() func() {
				os.Setenv(utils.ENV_CTRL_IPADDRESS, "192.168.1.100")
				return func() { os.Unsetenv(utils.ENV_CTRL_IPADDRESS) }
			},
			prepareMock: func(mockFactory *mock.MockAviRestClientPoolFactory) {
				mockClientPool := &utils.AviRestClientPool{}
				mockFactory.EXPECT().NewAviRestClientPool(
					1, "192.168.1.100", "admin", "password123", "", "", "ca-data", "admin", "", gomock.Any(),
				).Return(mockClientPool, utils.MaxAviVersion, nil)
			},
			wantStatus:     utils.AVIAPI_CONNECTED,
			wantVersion:    utils.MaxAviVersion,
			wantClientPool: true,
		},
		{
			name: "error: missing username",
			ctrlProperties: map[string]string{
				utils.ENV_CTRL_USERNAME:  "",
				utils.ENV_CTRL_PASSWORD:  "password123",
				utils.ENV_CTRL_AUTHTOKEN: "",
				utils.ENV_CTRL_CADATA:    "ca-data",
			},
			setupControllerIP: func() { lib.SetControllerIP("10.1.1.1") },
			// Note: This test relies on log.Fatalf which would exit in production
		},
		{
			name: "error: missing password and auth token",
			ctrlProperties: map[string]string{
				utils.ENV_CTRL_USERNAME:  "admin",
				utils.ENV_CTRL_PASSWORD:  "",
				utils.ENV_CTRL_AUTHTOKEN: "",
				utils.ENV_CTRL_CADATA:    "ca-data",
			},
			setupControllerIP: func() { lib.SetControllerIP("10.1.1.1") },
			// Note: This test relies on log.Fatalf which would exit in production
		},
		{
			name: "error: missing controller IP",
			ctrlProperties: map[string]string{
				utils.ENV_CTRL_USERNAME:  "admin",
				utils.ENV_CTRL_PASSWORD:  "password123",
				utils.ENV_CTRL_AUTHTOKEN: "",
				utils.ENV_CTRL_CADATA:    "ca-data",
			},
			setupControllerIP: func() { lib.SetControllerIP("") },
			// Note: This test relies on log.Fatalf which would exit in production
		},
		{
			name: "error: empty controller IP from environment",
			ctrlProperties: map[string]string{
				utils.ENV_CTRL_USERNAME:  "admin",
				utils.ENV_CTRL_PASSWORD:  "password123",
				utils.ENV_CTRL_AUTHTOKEN: "",
				utils.ENV_CTRL_CADATA:    "ca-data",
			},
			setupControllerIP: func() { lib.SetControllerIP("") },
			setupEnv: func() func() {
				os.Setenv(utils.ENV_CTRL_IPADDRESS, "")
				return func() { os.Unsetenv(utils.ENV_CTRL_IPADDRESS) }
			},
			// Note: This test relies on log.Fatalf which would exit in production
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup environment if needed
			var cleanup func()
			if tt.setupEnv != nil {
				cleanup = tt.setupEnv()
				defer cleanup()
			}

			// Setup controller IP
			if tt.setupControllerIP != nil {
				tt.setupControllerIP()
			}

			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			var mockFactory *mock.MockAviRestClientPoolFactory
			var aviRestClientPoolFactory AviRestClientPoolFactory

			if tt.prepareMock != nil {
				mockFactory = mock.NewMockAviRestClientPoolFactory(ctrl)
				tt.prepareMock(mockFactory)
				aviRestClientPoolFactory = mockFactory
			} else {
				aviRestClientPoolFactory = &AviRestClientPoolFactoryImpl{}
			}

			k8sClient := createFakeK8sClient()
			eventManager := &event.EventManager{}

			session := &Session{
				sync:                     &sync.Mutex{},
				aviRestClientPoolFactory: aviRestClientPoolFactory,
				ctrlProperties:           tt.ctrlProperties,
				k8sClient:                k8sClient,
				status:                   utils.AVIAPI_INITIATING,
				eventManager:             eventManager,
				tenant:                   "",
			}

			// Handle fatal errors with defer/recover
			defer func() {
				if r := recover(); r != nil {
					// Expected to panic/exit due to validation errors
					t.Logf("Recovered from panic: %v", r)
				}
			}()

			session.CreateAviClients(context.Background(), 1)

			// Verify results for non-fatal cases
			if tt.wantStatus != "" {
				assert.Equal(t, tt.wantStatus, session.status)
			}
			if tt.wantVersion != "" {
				assert.Equal(t, tt.wantVersion, session.controllerVersion)
			}
			if tt.wantClientPool {
				assert.NotNil(t, session.aviClientPool)
			} else if tt.wantStatus == utils.AVIAPI_DISCONNECTED {
				assert.Nil(t, session.aviClientPool)
			}
		})
	}
}

func TestCreateAviClients_VersionFormats(t *testing.T) {
	testCases := []struct {
		name            string
		returnedVersion string
		expectedVersion string
	}{
		{
			name:            "semantic version",
			returnedVersion: "22.1.3",
			expectedVersion: "22.1.3",
		},
		{
			name:            "version with build",
			returnedVersion: "22.1.3-9005",
			expectedVersion: "22.1.3-9005",
		},
		{
			name:            "simple version",
			returnedVersion: "22.1",
			expectedVersion: "22.1",
		},
		{
			name:            "empty version",
			returnedVersion: "",
			expectedVersion: "",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			mockFactory := mock.NewMockAviRestClientPoolFactory(ctrl)
			k8sClient := createFakeK8sClient()
			eventManager := &event.EventManager{}

			session := &Session{
				sync:                     &sync.Mutex{},
				aviRestClientPoolFactory: mockFactory,
				ctrlProperties: map[string]string{
					utils.ENV_CTRL_USERNAME:  "admin",
					utils.ENV_CTRL_PASSWORD:  "password123",
					utils.ENV_CTRL_AUTHTOKEN: "",
					utils.ENV_CTRL_CADATA:    "ca-data",
				},
				k8sClient:    k8sClient,
				status:       utils.AVIAPI_INITIATING,
				eventManager: eventManager,
				tenant:       "",
			}

			// Set controller IP for testing
			lib.SetControllerIP("10.1.1.1")

			// Mock the factory to return success with specific version
			mockClientPool := &utils.AviRestClientPool{}
			mockFactory.EXPECT().NewAviRestClientPool(
				1, "10.1.1.1", "admin", "password123", "", "", "ca-data", "admin", "", gomock.Any(),
			).Return(mockClientPool, tc.returnedVersion, nil)

			session.CreateAviClients(context.Background(), 1)

			// Verify version is set correctly
			assert.Equal(t, tc.expectedVersion, session.controllerVersion)
			assert.Equal(t, utils.AVIAPI_CONNECTED, session.status)
		})
	}
}

func TestUpdateAviClients(t *testing.T) {
	tests := []struct {
		name        string
		setupSecret func() *corev1.Secret
		prepareMock func(*mock.MockAviRestClientPoolFactory)
		wantErr     bool
		wantStatus  string
		wantVersion string
	}{
		{
			name: "success: update clients",
			setupSecret: func() *corev1.Secret {
				return &corev1.Secret{
					ObjectMeta: metav1.ObjectMeta{
						Name:      "avi-secret",
						Namespace: utils.GetAKONamespace(),
					},
					Data: map[string][]byte{
						"username":                 []byte("admin"),
						"password":                 []byte("password123"),
						"authtoken":                []byte(""),
						"certificateAuthorityData": []byte("ca-data"),
					},
				}
			},
			prepareMock: func(mockFactory *mock.MockAviRestClientPoolFactory) {
				mockClientPool := &utils.AviRestClientPool{}
				mockFactory.EXPECT().NewAviRestClientPool(
					2, "10.1.1.1", "admin", "password123", "", "", "ca-data", "admin", "", gomock.Any(),
				).Return(mockClientPool, utils.MaxAviVersion, nil)
			},
			wantErr:     false,
			wantStatus:  utils.AVIAPI_CONNECTED,
			wantVersion: utils.MaxAviVersion,
		},
		{
			name: "error: populate properties fails",
			setupSecret: func() *corev1.Secret {
				return nil // No secret
			},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			var k8sClient kubernetes.Interface
			if tt.setupSecret() != nil {
				k8sClient = createFakeK8sClient(tt.setupSecret())
			} else {
				k8sClient = createFakeK8sClient()
			}

			var mockFactory *mock.MockAviRestClientPoolFactory
			var aviRestClientPoolFactory AviRestClientPoolFactory

			if tt.prepareMock != nil {
				mockFactory = mock.NewMockAviRestClientPoolFactory(ctrl)
				tt.prepareMock(mockFactory)
				aviRestClientPoolFactory = mockFactory
			} else {
				aviRestClientPoolFactory = &AviRestClientPoolFactoryImpl{}
			}

			eventManager := &event.EventManager{}

			session := &Session{
				sync:                     &sync.Mutex{},
				aviRestClientPoolFactory: aviRestClientPoolFactory,
				ctrlProperties:           make(map[string]string),
				k8sClient:                k8sClient,
				status:                   utils.AVIAPI_INITIATING,
				eventManager:             eventManager,
				tenant:                   "",
			}

			// Set controller IP for testing
			lib.SetControllerIP("10.1.1.1")

			err := session.UpdateAviClients(context.Background(), 2)

			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
				if tt.wantStatus != "" {
					assert.Equal(t, tt.wantStatus, session.status)
				}
				if tt.wantVersion != "" {
					assert.Equal(t, tt.wantVersion, session.controllerVersion)
				}
			}
		})
	}
}

func TestGetAviClients(t *testing.T) {
	tests := []struct {
		name           string
		aviClientPool  *utils.AviRestClientPool
		expectedResult *utils.AviRestClientPool
	}{
		{
			name:           "return existing client pool",
			aviClientPool:  &utils.AviRestClientPool{},
			expectedResult: &utils.AviRestClientPool{},
		},
		{
			name:           "return nil when no client pool",
			aviClientPool:  nil,
			expectedResult: nil,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			session := &Session{
				aviClientPool: tt.aviClientPool,
			}

			result := session.GetAviClients()
			assert.Equal(t, tt.expectedResult, result)
		})
	}
}

func TestCreateAviClients_ConcurrentAccess(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockFactory := mock.NewMockAviRestClientPoolFactory(ctrl)
	k8sClient := createFakeK8sClient()
	eventManager := &event.EventManager{}

	session := &Session{
		sync:                     &sync.Mutex{},
		aviRestClientPoolFactory: mockFactory,
		ctrlProperties: map[string]string{
			utils.ENV_CTRL_USERNAME:  "admin",
			utils.ENV_CTRL_PASSWORD:  "password123",
			utils.ENV_CTRL_AUTHTOKEN: "",
			utils.ENV_CTRL_CADATA:    "ca-data",
		},
		k8sClient:    k8sClient,
		status:       utils.AVIAPI_INITIATING,
		eventManager: eventManager,
		tenant:       "",
	}

	// Set controller IP for testing
	lib.SetControllerIP("10.1.1.1")

	// Mock the factory to return success multiple times
	mockClientPool1 := &utils.AviRestClientPool{}
	mockClientPool2 := &utils.AviRestClientPool{}

	mockFactory.EXPECT().NewAviRestClientPool(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return(mockClientPool1, utils.MaxAviVersion, nil)
	mockFactory.EXPECT().NewAviRestClientPool(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return(mockClientPool2, utils.MaxAviVersion, nil)

	// Test concurrent access
	var wg sync.WaitGroup
	wg.Add(2)

	go func() {
		defer wg.Done()
		session.CreateAviClients(context.Background(), 1)
	}()

	go func() {
		defer wg.Done()
		session.CreateAviClients(context.Background(), 2)
	}()

	wg.Wait()

	// Should have one of the client pools set
	assert.Equal(t, utils.AVIAPI_CONNECTED, session.status)
	assert.NotNil(t, session.aviClientPool)
}

func TestCreateAviClients_VersionHandling(t *testing.T) {
	tests := []struct {
		name                 string
		initialVersion       string
		factoryReturnError   error
		factoryReturnVersion string
		wantVersion          string
		wantStatus           string
	}{
		{
			name:                 "version set on success",
			initialVersion:       "",
			factoryReturnError:   nil,
			factoryReturnVersion: "22.1.3",
			wantVersion:          "22.1.3",
			wantStatus:           utils.AVIAPI_CONNECTED,
		},
		// Note: The "version set even on error" test case has been removed because
		// the code now calls log.Fatalf() when the factory returns an error, which
		// causes os.Exit() and cannot be tested with standard Go testing patterns.
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			mockFactory := mock.NewMockAviRestClientPoolFactory(ctrl)
			k8sClient := createFakeK8sClient()
			eventManager := &event.EventManager{}

			session := &Session{
				sync:                     &sync.Mutex{},
				aviRestClientPoolFactory: mockFactory,
				ctrlProperties: map[string]string{
					utils.ENV_CTRL_USERNAME:  "admin",
					utils.ENV_CTRL_PASSWORD:  "password123",
					utils.ENV_CTRL_AUTHTOKEN: "",
					utils.ENV_CTRL_CADATA:    "ca-data",
				},
				k8sClient:         k8sClient,
				status:            utils.AVIAPI_INITIATING,
				eventManager:      eventManager,
				tenant:            "",
				controllerVersion: tt.initialVersion,
			}

			// Set controller IP for testing
			lib.SetControllerIP("10.1.1.1")

			// Mock the factory
			var mockClientPool *utils.AviRestClientPool
			if tt.factoryReturnError == nil {
				mockClientPool = &utils.AviRestClientPool{}
			}

			mockFactory.EXPECT().NewAviRestClientPool(
				1, "10.1.1.1", "admin", "password123", "", "", "ca-data", "admin", "", gomock.Any(),
			).Return(mockClientPool, tt.factoryReturnVersion, tt.factoryReturnError)

			session.CreateAviClients(context.Background(), 1)

			// Verify version and status
			assert.Equal(t, tt.wantVersion, session.controllerVersion)
			assert.Equal(t, tt.wantStatus, session.status)
		})
	}
}

// @AI-Generated
// [Generated by Cursor claude-4-sonnet]
// Tests for singleton functionality
func TestInitializeSessionInstance(t *testing.T) {
	// Reset singleton before test
	ResetSessionInstance()

	k8sClient := createFakeK8sClient()
	eventManager := &event.EventManager{}

	// Test first initialization
	session1 := InitializeSessionInstance(k8sClient, eventManager)
	assert.NotNil(t, session1)
	assert.Equal(t, k8sClient, session1.k8sClient)
	assert.Equal(t, eventManager, session1.eventManager)

	// Test second initialization returns same instance
	session2 := InitializeSessionInstance(k8sClient, eventManager)
	assert.Equal(t, session1, session2, "InitializeSessionInstance should return the same instance on subsequent calls")

	// Cleanup
	ResetSessionInstance()
}

func TestGetSessionInstance(t *testing.T) {
	// Reset singleton before test
	ResetSessionInstance()

	// Test panic when not initialized
	assert.Panics(t, func() {
		GetSessionInstance()
	}, "GetSessionInstance should panic when singleton is not initialized")

	// Initialize singleton
	k8sClient := createFakeK8sClient()
	eventManager := &event.EventManager{}
	originalSession := InitializeSessionInstance(k8sClient, eventManager)

	// Test successful retrieval
	retrievedSession := GetSessionInstance()
	assert.Equal(t, originalSession, retrievedSession, "GetSessionInstance should return the initialized singleton")

	// Cleanup
	ResetSessionInstance()
}

func TestResetSessionInstance(t *testing.T) {
	// Initialize singleton
	k8sClient := createFakeK8sClient()
	eventManager := &event.EventManager{}
	InitializeSessionInstance(k8sClient, eventManager)

	// Verify it's initialized
	session := GetSessionInstance()
	assert.NotNil(t, session)

	// Reset singleton
	ResetSessionInstance()

	// Verify it's reset (should panic when trying to get)
	assert.Panics(t, func() {
		GetSessionInstance()
	}, "GetSessionInstance should panic after ResetSessionInstance")

	// Test that we can initialize again after reset
	newSession := InitializeSessionInstance(k8sClient, eventManager)
	assert.NotNil(t, newSession)
	// The new session should be a different instance (different memory address)
	assert.False(t, session == newSession, "New session should be a different instance from the reset one")

	// Cleanup
	ResetSessionInstance()
}

func TestSessionInstance_ConcurrentAccess(t *testing.T) {
	// Reset singleton before test
	ResetSessionInstance()

	k8sClient := createFakeK8sClient()
	eventManager := &event.EventManager{}

	// Test concurrent initialization
	const numGoroutines = 10
	sessions := make([]*Session, numGoroutines)
	var wg sync.WaitGroup
	wg.Add(numGoroutines)

	for i := 0; i < numGoroutines; i++ {
		go func(index int) {
			defer wg.Done()
			sessions[index] = InitializeSessionInstance(k8sClient, eventManager)
		}(i)
	}

	wg.Wait()

	// All sessions should be the same instance
	firstSession := sessions[0]
	for i := 1; i < numGoroutines; i++ {
		assert.Equal(t, firstSession, sessions[i], "All concurrent initializations should return the same instance")
	}

	// Cleanup
	ResetSessionInstance()
}

func TestSessionInstance_ThreadSafety(t *testing.T) {
	// Reset singleton before test
	ResetSessionInstance()

	k8sClient := createFakeK8sClient()
	eventManager := &event.EventManager{}

	// Test concurrent access to GetSessionInstance after initialization
	InitializeSessionInstance(k8sClient, eventManager)

	const numGoroutines = 50
	sessions := make([]*Session, numGoroutines)
	var wg sync.WaitGroup
	wg.Add(numGoroutines)

	for i := 0; i < numGoroutines; i++ {
		go func(index int) {
			defer wg.Done()
			sessions[index] = GetSessionInstance()
		}(i)
	}

	wg.Wait()

	// All retrieved sessions should be the same instance
	firstSession := sessions[0]
	for i := 1; i < numGoroutines; i++ {
		assert.Equal(t, firstSession, sessions[i], "All concurrent GetSessionInstance calls should return the same instance")
	}

	// Cleanup
	ResetSessionInstance()
}

// @AI-Generated
// [Generated by Cursor claude-4.5-sonnet]
func TestCreateAviClients_UserHeaders(t *testing.T) {
	tests := []struct {
		name                string
		ctrlProperties      map[string]string
		setupControllerIP   func()
		prepareMock         func(*mock.MockAviRestClientPoolFactory)
		expectedUserHeaders map[string]string
		wantStatus          string
		wantVersion         string
	}{
		{
			name: "success: userHeaders with default AKO user agent",
			ctrlProperties: map[string]string{
				utils.ENV_CTRL_USERNAME:  "admin",
				utils.ENV_CTRL_PASSWORD:  "password123",
				utils.ENV_CTRL_AUTHTOKEN: "",
				utils.ENV_CTRL_CADATA:    "ca-data",
			},
			setupControllerIP: func() { lib.SetControllerIP("10.1.1.1") },
			prepareMock: func(mockFactory *mock.MockAviRestClientPoolFactory) {
				mockClientPool := &utils.AviRestClientPool{}
				// Verify that userHeaders contains the expected X-Avi-UserAgent header
				mockFactory.EXPECT().NewAviRestClientPool(
					1, "10.1.1.1", "admin", "password123", "", "", "ca-data", "admin", "",
					gomock.Any(),
				).DoAndReturn(func(numClients int, ctrlIpAddress, ctrlUsername, ctrlPassword, ctrlAuthToken, controllerVersion, ctrlCAData string, tenant string, protocol string, userHeaders map[string]string) (*utils.AviRestClientPool, string, error) {
					// Verify the userHeaders contain the expected AKO user agent
					assert.Equal(t, "AKO", userHeaders[utils.XAviUserAgentHeader])
					return mockClientPool, utils.MaxAviVersion, nil
				})
			},
			expectedUserHeaders: map[string]string{
				utils.XAviUserAgentHeader: "AKO",
			},
			wantStatus:  utils.AVIAPI_CONNECTED,
			wantVersion: utils.MaxAviVersion,
		},
		{
			name: "success: userHeaders with auth token",
			ctrlProperties: map[string]string{
				utils.ENV_CTRL_USERNAME:  "admin",
				utils.ENV_CTRL_PASSWORD:  "",
				utils.ENV_CTRL_AUTHTOKEN: "token123",
				utils.ENV_CTRL_CADATA:    "ca-data",
			},
			setupControllerIP: func() { lib.SetControllerIP("10.1.1.1") },
			prepareMock: func(mockFactory *mock.MockAviRestClientPoolFactory) {
				mockClientPool := &utils.AviRestClientPool{}
				mockFactory.EXPECT().NewAviRestClientPool(
					1, "10.1.1.1", "admin", "", "token123", "", "ca-data", "admin", "",
					gomock.Any(),
				).DoAndReturn(func(numClients int, ctrlIpAddress, ctrlUsername, ctrlPassword, ctrlAuthToken, controllerVersion, ctrlCAData string, tenant string, protocol string, userHeaders map[string]string) (*utils.AviRestClientPool, string, error) {
					// Verify the userHeaders contain the expected AKO user agent
					assert.Equal(t, "AKO", userHeaders[utils.XAviUserAgentHeader])
					return mockClientPool, utils.MaxAviVersion, nil
				})
			},
			expectedUserHeaders: map[string]string{
				utils.XAviUserAgentHeader: "AKO",
			},
			wantStatus:  utils.AVIAPI_CONNECTED,
			wantVersion: utils.MaxAviVersion,
		},
		{
			name: "success: userHeaders with multiple clients",
			ctrlProperties: map[string]string{
				utils.ENV_CTRL_USERNAME:  "admin",
				utils.ENV_CTRL_PASSWORD:  "password123",
				utils.ENV_CTRL_AUTHTOKEN: "",
				utils.ENV_CTRL_CADATA:    "ca-data",
			},
			setupControllerIP: func() { lib.SetControllerIP("10.1.1.1") },
			prepareMock: func(mockFactory *mock.MockAviRestClientPoolFactory) {
				mockClientPool := &utils.AviRestClientPool{}
				mockFactory.EXPECT().NewAviRestClientPool(
					1, "10.1.1.1", "admin", "password123", "", "", "ca-data", "admin", "",
					gomock.Any(),
				).DoAndReturn(func(numClients int, ctrlIpAddress, ctrlUsername, ctrlPassword, ctrlAuthToken, controllerVersion, ctrlCAData string, tenant string, protocol string, userHeaders map[string]string) (*utils.AviRestClientPool, string, error) {
					// Verify the userHeaders contain the expected AKO user agent
					assert.Equal(t, "AKO", userHeaders[utils.XAviUserAgentHeader])
					return mockClientPool, utils.MaxAviVersion, nil
				})
			},
			expectedUserHeaders: map[string]string{
				utils.XAviUserAgentHeader: "AKO",
			},
			wantStatus:  utils.AVIAPI_CONNECTED,
			wantVersion: utils.MaxAviVersion,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup controller IP
			if tt.setupControllerIP != nil {
				tt.setupControllerIP()
			}

			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			mockFactory := mock.NewMockAviRestClientPoolFactory(ctrl)
			tt.prepareMock(mockFactory)

			k8sClient := createFakeK8sClient()
			eventManager := &event.EventManager{}

			session := &Session{
				sync:                     &sync.Mutex{},
				aviRestClientPoolFactory: mockFactory,
				ctrlProperties:           tt.ctrlProperties,
				k8sClient:                k8sClient,
				status:                   utils.AVIAPI_INITIATING,
				eventManager:             eventManager,
				tenant:                   "",
			}

			session.CreateAviClients(context.Background(), 1)

			// Verify results
			if tt.wantStatus != "" {
				assert.Equal(t, tt.wantStatus, session.status)
			}
			if tt.wantVersion != "" {
				assert.Equal(t, tt.wantVersion, session.controllerVersion)
			}
		})
		// Cleanup
		ResetSessionInstance()
	}
}
