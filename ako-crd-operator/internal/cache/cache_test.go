// @AI-Generated
// [Generated by Cursor claude-4-sonnet]
package cache

import (
	"context"
	"encoding/json"
	"fmt"
	"testing"

	"github.com/golang/mock/gomock"
	"github.com/stretchr/testify/assert"
	"github.com/vmware/alb-sdk/go/session"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-crd-operator/internal/types"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-crd-operator/test/mock"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/utils"
)

func TestNewCache(t *testing.T) {
	mockSession := mock.NewMockAviClientInterface(gomock.NewController(t))
	clusterName := "test-cluster"

	cache := NewCache(mockSession, clusterName)

	assert.NotNil(t, cache)
	assert.Implements(t, (*CacheOperation)(nil), cache)
}

func TestCache_GetObjectByUUID(t *testing.T) {
	tests := []struct {
		name       string
		uuid       string
		setupCache func(*cache)
		expectData types.DataMap
		expectOk   bool
	}{
		{
			name: "existing object",
			uuid: "test-uuid-1",
			setupCache: func(c *cache) {
				c.dataStore.Store("test-uuid-1", map[string]interface{}{
					"uuid":           "test-uuid-1",
					"_last_modified": "1640995200000000",
					"name":           "test-object",
				})
			},
			expectData: types.DataMap{
				"uuid":           "test-uuid-1",
				"_last_modified": "1640995200000000",
				"name":           "test-object",
			},
			expectOk: true,
		},
		{
			name: "non-existing object",
			uuid: "non-existing-uuid",
			setupCache: func(c *cache) {
				// Don't store anything
			},
			expectData: nil,
			expectOk:   false,
		},
		{
			name: "object with different UUID",
			uuid: "different-uuid",
			setupCache: func(c *cache) {
				c.dataStore.Store("test-uuid-1", map[string]interface{}{
					"uuid": "test-uuid-1",
					"name": "test-object",
				})
			},
			expectData: nil,
			expectOk:   false,
		},
		{
			name: "object with invalid type in datastore",
			uuid: "test-uuid-1",
			setupCache: func(c *cache) {
				c.dataStore.Store("test-uuid-1", "invalid-type-string")
			},
			expectData: nil,
			expectOk:   false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cache := &cache{
				clusterName: "test-cluster",
			}

			if tt.setupCache != nil {
				tt.setupCache(cache)
			}

			ctx := utils.LoggerWithContext(context.Background(), utils.AviLog)
			data, ok := cache.GetObjectByUUID(ctx, tt.uuid)

			assert.Equal(t, tt.expectOk, ok)
			if tt.expectOk {
				assert.Equal(t, tt.expectData, data)
			} else {
				assert.Nil(t, data)
			}
		})
	}
}

func TestCache_PopulateCache(t *testing.T) {
	tests := []struct {
		name         string
		urls         []string
		prepare      func(*mock.MockAviClientInterface)
		expectError  bool
		expectedData types.DataMap
		uuid         string
	}{
		{
			name:        "successful population with single URL",
			urls:        []string{"api/healthmonitor"},
			expectError: false,
			prepare: func(mockAviClient *mock.MockAviClientInterface) {
				mockAviClient.EXPECT().GetAviSession().Return(&session.AviSession{})
				mockAviClient.EXPECT().AviSessionGetCollectionRaw(gomock.Any(), gomock.Any()).Return(session.AviCollectionResult{
					Count: 1,
					Results: json.RawMessage(`[{
						"uuid":           "test-uuid-1",
						"_last_modified": "1640995200000000",
						"name":           "test-object"
					}]`),
				}, nil)
			},
			expectedData: types.DataMap{
				"uuid":           "test-uuid-1",
				"_last_modified": "1640995200000000",
				"name":           "test-object",
			},
			uuid: "test-uuid-1",
		},
		{
			name:        "multiple URLs with pagination",
			urls:        []string{"api/healthmonitor"},
			expectError: false,
			prepare: func(mockAviClient *mock.MockAviClientInterface) {
				mockAviClient.EXPECT().GetAviSession().Return(&session.AviSession{})
				// First call with pagination (has Next)
				mockAviClient.EXPECT().AviSessionGetCollectionRaw(gomock.Any(), gomock.Any()).Return(session.AviCollectionResult{
					Count: 1,
					Next:  "api/healthmonitor?page=2",
					Results: json.RawMessage(`[{
						"uuid":           "test-uuid-1",
						"_last_modified": "1640995200000000",
						"name":           "test-object-1"
					}]`),
				}, nil)
				// Second call (no Next, end of pagination)
				mockAviClient.EXPECT().AviSessionGetCollectionRaw(gomock.Any(), gomock.Any()).Return(session.AviCollectionResult{
					Count: 1,
					Results: json.RawMessage(`[{
						"uuid":           "test-uuid-2",
						"_last_modified": "1640995200000001",
						"name":           "test-object-2"
					}]`),
				}, nil)
			},
			expectedData: types.DataMap{
				"uuid":           "test-uuid-2",
				"_last_modified": "1640995200000001",
				"name":           "test-object-2",
			},
			uuid: "test-uuid-2",
		},
		{
			name:        "error from AviSessionGetCollectionRaw",
			urls:        []string{"api/healthmonitor"},
			expectError: true,
			prepare: func(mockAviClient *mock.MockAviClientInterface) {
				mockAviClient.EXPECT().GetAviSession().Return(&session.AviSession{})
				mockAviClient.EXPECT().AviSessionGetCollectionRaw(gomock.Any(), gomock.Any()).Return(session.AviCollectionResult{}, fmt.Errorf("network error"))
			},
			expectedData: nil,
			uuid:         "test-uuid-1",
		},
		{
			name:        "invalid JSON in response",
			urls:        []string{"api/healthmonitor"},
			expectError: true,
			prepare: func(mockAviClient *mock.MockAviClientInterface) {
				mockAviClient.EXPECT().GetAviSession().Return(&session.AviSession{})
				mockAviClient.EXPECT().AviSessionGetCollectionRaw(gomock.Any(), gomock.Any()).Return(session.AviCollectionResult{
					Count:   1,
					Results: json.RawMessage(`invalid json`),
				}, nil)
			},
			expectedData: nil,
			uuid:         "test-uuid-1",
		},
		{
			name:        "object without UUID",
			urls:        []string{"api/healthmonitor"},
			expectError: false,
			prepare: func(mockAviClient *mock.MockAviClientInterface) {
				mockAviClient.EXPECT().GetAviSession().Return(&session.AviSession{})
				mockAviClient.EXPECT().AviSessionGetCollectionRaw(gomock.Any(), gomock.Any()).Return(session.AviCollectionResult{
					Count: 1,
					Results: json.RawMessage(`[{
						"_last_modified": "1640995200000000",
						"name":           "test-object-no-uuid"
					}]`),
				}, nil)
			},
			expectedData: nil,
			uuid:         "test-uuid-1",
		},
		{
			name:        "object with non-string UUID",
			urls:        []string{"api/healthmonitor"},
			expectError: false,
			prepare: func(mockAviClient *mock.MockAviClientInterface) {
				mockAviClient.EXPECT().GetAviSession().Return(&session.AviSession{})
				mockAviClient.EXPECT().AviSessionGetCollectionRaw(gomock.Any(), gomock.Any()).Return(session.AviCollectionResult{
					Count: 1,
					Results: json.RawMessage(`[{
						"uuid":           123,
						"_last_modified": "1640995200000000",
						"name":           "test-object-numeric-uuid"
					}]`),
				}, nil)
			},
			expectedData: nil,
			uuid:         "test-uuid-1",
		},
		{
			name:        "empty URLs slice",
			urls:        []string{},
			expectError: false,
			prepare: func(mockAviClient *mock.MockAviClientInterface) {
				// GetAviSession is always called even for empty URLs
				mockAviClient.EXPECT().GetAviSession().Return(&session.AviSession{})
			},
			expectedData: nil,
			uuid:         "test-uuid-1",
		},
		{
			name:        "multiple URLs with mixed success/failure",
			urls:        []string{"api/healthmonitor", "api/virtualservice"},
			expectError: true,
			prepare: func(mockAviClient *mock.MockAviClientInterface) {
				mockAviClient.EXPECT().GetAviSession().Return(&session.AviSession{})
				// First URL succeeds
				mockAviClient.EXPECT().AviSessionGetCollectionRaw(gomock.Any(), gomock.Any()).Return(session.AviCollectionResult{
					Count: 1,
					Results: json.RawMessage(`[{
						"uuid":           "test-uuid-1",
						"_last_modified": "1640995200000000",
						"name":           "test-object"
					}]`),
				}, nil)
				mockAviClient.EXPECT().GetAviSession().Return(&session.AviSession{})
				// Second URL fails
				mockAviClient.EXPECT().AviSessionGetCollectionRaw(gomock.Any(), gomock.Any()).Return(session.AviCollectionResult{}, fmt.Errorf("second URL error"))
			},
			expectedData: nil,
			uuid:         "test-uuid-1",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockAviClient := mock.NewMockAviClientInterface(gomock.NewController(t))

			if tt.prepare != nil {
				tt.prepare(mockAviClient)
			}

			cache := &cache{
				clusterName: "test-cluster",
				session:     mockAviClient,
			}

			ctx := utils.LoggerWithContext(context.Background(), utils.AviLog)
			err := cache.PopulateCache(ctx, tt.urls...)

			assert.Equal(t, tt.expectError, err != nil)

			if !tt.expectError && tt.expectedData != nil {
				data, ok := cache.GetObjectByUUID(ctx, tt.uuid)
				assert.True(t, ok)
				assert.Equal(t, tt.expectedData, data)
			} else if tt.uuid != "" && tt.expectedData == nil && len(tt.urls) > 0 {
				// For error cases with multiple URLs, the first URL might have populated data
				// before the second URL failed. Check based on test name
				if tt.name == "multiple URLs with mixed success/failure" {
					// In this case, the first URL succeeded, so data should exist
					data, ok := cache.GetObjectByUUID(ctx, tt.uuid)
					assert.True(t, ok)
					assert.NotNil(t, data)
				} else {
					// For other error cases, object should not be found
					data, ok := cache.GetObjectByUUID(ctx, tt.uuid)
					assert.False(t, ok)
					assert.Nil(t, data)
				}
			}
		})
	}
}
