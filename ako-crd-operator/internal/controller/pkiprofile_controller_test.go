/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
	"context"
	"errors"
	"fmt"
	"os"
	"testing"
	"time"

	"github.com/golang/mock/gomock"
	"github.com/stretchr/testify/assert"
	"github.com/vmware/alb-sdk/go/session"
	akov1alpha1 "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-crd-operator/api/v1alpha1"
	crdlib "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-crd-operator/internal/lib"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-crd-operator/test/mock"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/lib"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/utils"
	corev1 "k8s.io/api/core/v1"
	k8serror "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/tools/record"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/client/fake"
	"sigs.k8s.io/controller-runtime/pkg/client/interceptor"
)

const (
	// testCertificate represents a test certificate used in PKI profile tests
	testCertificate = "-----BEGIN CERTIFICATE-----\nMIIC...test...cert\n-----END CERTIFICATE-----"
	// testUpdatedCertificate represents an updated test certificate used in PKI profile tests
	testUpdatedCertificate = "-----BEGIN CERTIFICATE-----\nMIIC...updated...cert\n-----END CERTIFICATE-----"
)

// @AI-Generated
// [Generated by Cursor claude-4-sonnet]
func TestPKIProfileController(t *testing.T) {
	lib.SetNamePrefix(crdlib.Prefix)
	lib.SetClusterName("test-cluster")
	os.Setenv("ENABLE_EVH", "true")
	tests := []struct {
		name         string
		pki          *akov1alpha1.PKIProfile
		prepare      func(mockAviClient *mock.MockAviClientInterface)
		prepareCache func(cache *mock.MockCacheOperation)
		want         *akov1alpha1.PKIProfile
		wantErr      bool
	}{
		{
			name: "success: add finalizer",
			pki: &akov1alpha1.PKIProfile{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "test",
					Namespace: "default",
				},
			},
			prepare: func(mockAviClient *mock.MockAviClientInterface) {
				responseUUID := map[string]interface{}{
					"uuid": "123",
				}
				mockAviClient.EXPECT().AviSessionPost(crdlib.PKIProfileURL, gomock.Any(), gomock.Any(), gomock.Any()).Do(func(url string, request interface{}, response interface{}, params interface{}) {
					if resp, ok := response.(*map[string]interface{}); ok {
						*resp = responseUUID
					}
				}).Return(nil).AnyTimes()
			},
			want: &akov1alpha1.PKIProfile{
				ObjectMeta: metav1.ObjectMeta{
					Name:            "test",
					Namespace:       "default",
					Finalizers:      []string{"pkiprofile.ako.vmware.com/finalizer"},
					ResourceVersion: "1000",
				},
				Status: akov1alpha1.PKIProfileStatus{
					UUID:               "123",
					Controller:         crdlib.AKOCRDController,
					ObservedGeneration: 0,
					Conditions: []metav1.Condition{
						{
							Type:    string(akov1alpha1.ObjectConditionProgrammed),
							Status:  metav1.ConditionTrue,
							Reason:  "Created",
							Message: "PKIProfile created successfully on Avi Controller",
						},
					},
				},
			},
			wantErr: false,
		},
		{
			name: "success: add pkiprofile",
			pki: &akov1alpha1.PKIProfile{
				ObjectMeta: metav1.ObjectMeta{
					Name:            "test",
					Finalizers:      []string{"pkiprofile.ako.vmware.com/finalizer"},
					ResourceVersion: "1000",
					Namespace:       "default",
				},
				Spec: akov1alpha1.PKIProfileSpec{
					CACerts: []*akov1alpha1.SSLCertificate{{Certificate: func() *string {
						s := testCertificate
						return &s
					}()}},
				},
			},
			prepare: func(mockAviClient *mock.MockAviClientInterface) {
				responseUUID := map[string]interface{}{
					"uuid": "123",
				}
				mockAviClient.EXPECT().AviSessionPost(crdlib.PKIProfileURL, gomock.Any(), gomock.Any(), gomock.Any()).Do(func(url string, request interface{}, response interface{}, params interface{}) {
					if resp, ok := response.(*map[string]interface{}); ok {
						*resp = responseUUID
					}
				}).Return(nil).AnyTimes()
			},
			want: &akov1alpha1.PKIProfile{
				ObjectMeta: metav1.ObjectMeta{
					Name:            "test",
					Finalizers:      []string{"pkiprofile.ako.vmware.com/finalizer"},
					Namespace:       "default",
					ResourceVersion: "1001",
				},
				Status: akov1alpha1.PKIProfileStatus{
					UUID:               "123",
					Controller:         crdlib.AKOCRDController,
					ObservedGeneration: 0,
					Conditions: []metav1.Condition{
						{
							Type:   string(akov1alpha1.ObjectConditionProgrammed),
							Status: metav1.ConditionTrue,
							Reason: "Created",
						},
					},
				},
				Spec: akov1alpha1.PKIProfileSpec{
					CACerts: []*akov1alpha1.SSLCertificate{{Certificate: func() *string {
						s := testCertificate
						return &s
					}()}},
				},
			},
			wantErr: false,
		},
		{
			name: "success: update pkiprofile",
			pki: &akov1alpha1.PKIProfile{
				ObjectMeta: metav1.ObjectMeta{
					Name:            "test",
					Finalizers:      []string{"pkiprofile.ako.vmware.com/finalizer"},
					ResourceVersion: "1000",
					Namespace:       "default",
				},
				Status: akov1alpha1.PKIProfileStatus{
					UUID: "123",
				},
				Spec: akov1alpha1.PKIProfileSpec{
					CACerts: []*akov1alpha1.SSLCertificate{{Certificate: func() *string {
						s := testUpdatedCertificate
						return &s
					}()}},
				},
			},
			prepare: func(mockAviClient *mock.MockAviClientInterface) {
				responseUUID := map[string]interface{}{
					"uuid": "123",
				}
				mockAviClient.EXPECT().AviSessionPut(fmt.Sprintf("%s/%s", crdlib.PKIProfileURL, "123"), gomock.Any(), gomock.Any(), gomock.Any()).Do(func(url string, request interface{}, response interface{}, params interface{}) {
					if resp, ok := response.(*map[string]interface{}); ok {
						*resp = responseUUID
					}
				}).Return(nil).AnyTimes()
			},
			prepareCache: func(cache *mock.MockCacheOperation) {
				cache.EXPECT().GetObjectByUUID(gomock.Any(), gomock.Any()).Return(nil, false).AnyTimes()
			},
			want: &akov1alpha1.PKIProfile{
				ObjectMeta: metav1.ObjectMeta{
					Name:            "test",
					Finalizers:      []string{"pkiprofile.ako.vmware.com/finalizer"},
					Namespace:       "default",
					ResourceVersion: "1001",
				},
				Status: akov1alpha1.PKIProfileStatus{
					UUID:               "123",
					Controller:         crdlib.AKOCRDController,
					ObservedGeneration: 0,
					Conditions: []metav1.Condition{
						{
							Type:   string(akov1alpha1.ObjectConditionProgrammed),
							Status: metav1.ConditionTrue,
							Reason: "Updated",
						},
					},
				},
				Spec: akov1alpha1.PKIProfileSpec{
					CACerts: []*akov1alpha1.SSLCertificate{{Certificate: func() *string {
						s := testUpdatedCertificate
						return &s
					}()}},
				},
			},
			wantErr: false,
		},
		{
			name: "success: PUT returns 404, recreates pkiprofile",
			pki: &akov1alpha1.PKIProfile{
				ObjectMeta: metav1.ObjectMeta{
					Name:            "test",
					Finalizers:      []string{"pkiprofile.ako.vmware.com/finalizer"},
					ResourceVersion: "1000",
					Namespace:       "default",
					Generation:      2,
				},
				Status: akov1alpha1.PKIProfileStatus{
					UUID:               "123",
					ObservedGeneration: 1,
					Tenant:             "admin",
				},
				Spec: akov1alpha1.PKIProfileSpec{
					CACerts: []*akov1alpha1.SSLCertificate{{Certificate: func() *string {
						s := testCertificate
						return &s
					}()}},
				},
			},
			prepare: func(mockAviClient *mock.MockAviClientInterface) {
				// First PUT call returns 404
				mockAviClient.EXPECT().AviSessionPut(fmt.Sprintf("%s/%s", crdlib.PKIProfileURL, "123"), gomock.Any(), gomock.Any(), gomock.Any()).Return(session.AviError{
					HttpStatusCode: 404,
					AviResult: session.AviResult{
						Message: &[]string{"not found"}[0],
					},
				}).Times(1)
				// Then POST to recreate
				responseUUID := map[string]interface{}{
					"uuid": "456",
				}
				mockAviClient.EXPECT().AviSessionPost(crdlib.PKIProfileURL, gomock.Any(), gomock.Any(), gomock.Any()).Do(func(url string, request interface{}, response interface{}, params interface{}) {
					if resp, ok := response.(*map[string]interface{}); ok {
						*resp = responseUUID
					}
				}).Return(nil).Times(1)
			},
			prepareCache: func(cache *mock.MockCacheOperation) {
				cache.EXPECT().GetObjectByUUID(gomock.Any(), gomock.Any()).Return(nil, false).AnyTimes()
			},
			want: &akov1alpha1.PKIProfile{
				ObjectMeta: metav1.ObjectMeta{
					Name:            "test",
					Finalizers:      []string{"pkiprofile.ako.vmware.com/finalizer"},
					Namespace:       "default",
					ResourceVersion: "1001",
					Generation:      2,
				},
				Status: akov1alpha1.PKIProfileStatus{
					UUID:               "456",
					BackendObjectName:  "ako-crd-operator-test-cluster--738bb014438bdbfe7f14e44b60f97b07e22e4dc0",
					Tenant:             "admin",
					Controller:         crdlib.AKOCRDController,
					ObservedGeneration: 2,
					Conditions: []metav1.Condition{
						{
							Type:   string(akov1alpha1.ObjectConditionProgrammed),
							Status: metav1.ConditionTrue,
							Reason: "Created",
						},
					},
				},
				Spec: akov1alpha1.PKIProfileSpec{
					CACerts: []*akov1alpha1.SSLCertificate{{Certificate: func() *string {
						s := testCertificate
						return &s
					}()}},
				},
			},
			wantErr: false,
		},
		{
			name: "success: delete pkiprofile",
			pki: &akov1alpha1.PKIProfile{
				ObjectMeta: metav1.ObjectMeta{
					Name:              "test",
					Finalizers:        []string{"pkiprofile.ako.vmware.com/finalizer"},
					ResourceVersion:   "1000",
					Namespace:         "default",
					DeletionTimestamp: &metav1.Time{Time: time.Now()},
				},
				Status: akov1alpha1.PKIProfileStatus{
					UUID: "123",
				},
				Spec: akov1alpha1.PKIProfileSpec{
					CACerts: []*akov1alpha1.SSLCertificate{{Certificate: func() *string {
						s := testCertificate
						return &s
					}()}},
				},
			},
			prepare: func(mockAviClient *mock.MockAviClientInterface) {
				mockAviClient.EXPECT().AviSessionDelete(fmt.Sprintf("%s/%s", crdlib.PKIProfileURL, "123"), gomock.Any(), gomock.Any(), gomock.Any()).Return(nil).AnyTimes()
			},
			want: &akov1alpha1.PKIProfile{
				ObjectMeta: metav1.ObjectMeta{
					Name:              "test",
					Finalizers:        []string{},
					Namespace:         "default",
					ResourceVersion:   "1001",
					DeletionTimestamp: &metav1.Time{Time: time.Now()},
				},
				Status: akov1alpha1.PKIProfileStatus{
					UUID:               "123",
					Controller:         crdlib.AKOCRDController,
					ObservedGeneration: 0,
					Conditions: []metav1.Condition{
						{
							Type:   string(akov1alpha1.ObjectConditionProgrammed),
							Status: metav1.ConditionTrue,
							Reason: "DeletionSkipped",
						},
					},
				},
				Spec: akov1alpha1.PKIProfileSpec{
					CACerts: []*akov1alpha1.SSLCertificate{{Certificate: func() *string {
						s := testCertificate
						return &s
					}()}},
				},
			},
			wantErr: false,
		},
		{
			name: "success: delete pkiprofile with empty UUID (object not found on AVI)",
			pki: &akov1alpha1.PKIProfile{
				ObjectMeta: metav1.ObjectMeta{
					Name:              "test",
					Namespace:         "default",
					Finalizers:        []string{"pkiprofile.ako.vmware.com/finalizer"},
					DeletionTimestamp: &metav1.Time{Time: time.Now()},
				},
				Status: akov1alpha1.PKIProfileStatus{
					UUID: "",
				},
				Spec: akov1alpha1.PKIProfileSpec{
					CACerts: []*akov1alpha1.SSLCertificate{{Certificate: func() *string {
						s := testCertificate
						return &s
					}()}},
				},
			},
			prepare: func(mockAviClient *mock.MockAviClientInterface) {
				// Mock GetObjectUUIDFromAvi call - return 404 (not found)
				mockAviClient.EXPECT().AviSessionGet(
					gomock.Any(),
					gomock.Any(),
					gomock.Any(),
				).Return(session.AviError{
					HttpStatusCode: 404,
				}).AnyTimes()
			},
			want: &akov1alpha1.PKIProfile{
				ObjectMeta: metav1.ObjectMeta{
					Name:              "test",
					Finalizers:        []string{},
					Namespace:         "default",
					ResourceVersion:   "1000",
					DeletionTimestamp: &metav1.Time{Time: time.Now()},
				},
				Status: akov1alpha1.PKIProfileStatus{
					UUID:               "",
					Controller:         crdlib.AKOCRDController,
					ObservedGeneration: 0,
					Conditions: []metav1.Condition{
						{
							Type:   string(akov1alpha1.ObjectConditionProgrammed),
							Status: metav1.ConditionTrue,
							Reason: "DeletionSkipped",
						},
					},
				},
				Spec: akov1alpha1.PKIProfileSpec{
					CACerts: []*akov1alpha1.SSLCertificate{{Certificate: func() *string {
						s := testCertificate
						return &s
					}()}},
				},
			},
			wantErr: false,
		},
		{
			name: "success: delete pkiprofile with empty UUID (object found on AVI)",
			pki: &akov1alpha1.PKIProfile{
				ObjectMeta: metav1.ObjectMeta{
					Name:              "test",
					Namespace:         "default",
					Finalizers:        []string{"pkiprofile.ako.vmware.com/finalizer"},
					DeletionTimestamp: &metav1.Time{Time: time.Now()},
				},
				Status: akov1alpha1.PKIProfileStatus{
					UUID: "",
				},
				Spec: akov1alpha1.PKIProfileSpec{
					CACerts: []*akov1alpha1.SSLCertificate{{Certificate: func() *string {
						s := testCertificate
						return &s
					}()}},
				},
			},
			prepare: func(mockAviClient *mock.MockAviClientInterface) {
				// Mock GetObjectUUIDFromAvi call - return object with UUID
				responseBody := map[string]interface{}{
					"results": []interface{}{map[string]interface{}{"uuid": "fetched-uuid-123"}},
				}
				mockAviClient.EXPECT().AviSessionGet(
					fmt.Sprintf("%s?name=%s", crdlib.PKIProfileURL, "ako-crd-operator-test-cluster--738bb014438bdbfe7f14e44b60f97b07e22e4dc0"),
					gomock.Any(),
					gomock.Any(),
				).Do(func(url string, response interface{}, params ...interface{}) {
					if resp, ok := response.(*map[string]interface{}); ok {
						*resp = responseBody
					}
				}).Return(nil).Times(1)

				// Mock the actual delete call with fetched UUID
				mockAviClient.EXPECT().AviSessionDelete(
					crdlib.PKIProfileURL+"/fetched-uuid-123",
					gomock.Any(),
					gomock.Any(),
					gomock.Any(),
				).Return(nil).Times(1)
			},
			want: &akov1alpha1.PKIProfile{
				ObjectMeta: metav1.ObjectMeta{
					Name:              "test",
					Finalizers:        []string{},
					Namespace:         "default",
					ResourceVersion:   "1000",
					DeletionTimestamp: &metav1.Time{Time: time.Now()},
				},
				Status: akov1alpha1.PKIProfileStatus{
					UUID:               "",
					Controller:         crdlib.AKOCRDController,
					ObservedGeneration: 0,
					Conditions: []metav1.Condition{
						{
							Type:   string(akov1alpha1.ObjectConditionProgrammed),
							Status: metav1.ConditionTrue,
							Reason: "DeletionSkipped",
						},
					},
				},
				Spec: akov1alpha1.PKIProfileSpec{
					CACerts: []*akov1alpha1.SSLCertificate{{Certificate: func() *string {
						s := testCertificate
						return &s
					}()}},
				},
			},
			wantErr: false,
		},
		{
			name: "error: delete pkiprofile with empty UUID but AVI GET fails",
			pki: &akov1alpha1.PKIProfile{
				ObjectMeta: metav1.ObjectMeta{
					Name:              "test",
					Namespace:         "default",
					Finalizers:        []string{"pkiprofile.ako.vmware.com/finalizer"},
					DeletionTimestamp: &metav1.Time{Time: time.Now()},
					ResourceVersion:   "1000",
				},
				Status: akov1alpha1.PKIProfileStatus{
					UUID:   "",
					Tenant: "admin",
				},
				Spec: akov1alpha1.PKIProfileSpec{
					CACerts: []*akov1alpha1.SSLCertificate{{Certificate: func() *string {
						s := testCertificate
						return &s
					}()}},
				},
			},
			prepare: func(mockAviClient *mock.MockAviClientInterface) {
				// Mock GetObjectUUIDFromAvi call - return error
				mockAviClient.EXPECT().AviSessionGet(
					gomock.Any(),
					gomock.Any(),
					gomock.Any(),
				).Return(errors.New("AVI connection error")).Times(1)
			},
			want:    nil,
			wantErr: true,
		},
		{
			name: "error: AVI client validation error during creation",
			pki: &akov1alpha1.PKIProfile{
				ObjectMeta: metav1.ObjectMeta{
					Name:            "test-error",
					Finalizers:      []string{"pkiprofile.ako.vmware.com/finalizer"},
					ResourceVersion: "1000",
					Namespace:       "default",
				},
				Spec: akov1alpha1.PKIProfileSpec{
					CACerts: []*akov1alpha1.SSLCertificate{{Certificate: func() *string {
						s := testCertificate
						return &s
					}()}},
				},
			},
			prepare: func(mockAviClient *mock.MockAviClientInterface) {
				aviError := session.AviError{
					HttpStatusCode: 400,
					AviResult: session.AviResult{
						Code:    400,
						Message: func() *string { s := "Bad Request"; return &s }(),
					},
				}
				mockAviClient.EXPECT().AviSessionPost(crdlib.PKIProfileURL, gomock.Any(), gomock.Any(), gomock.Any()).Return(aviError).AnyTimes()
			},
			want: &akov1alpha1.PKIProfile{
				ObjectMeta: metav1.ObjectMeta{
					Name:            "test-error",
					Finalizers:      []string{"pkiprofile.ako.vmware.com/finalizer"},
					Namespace:       "default",
					ResourceVersion: "1001",
				},
				Status: akov1alpha1.PKIProfileStatus{
					Controller:         crdlib.AKOCRDController,
					ObservedGeneration: 0,
					Conditions: []metav1.Condition{
						{
							Type:    string(akov1alpha1.ObjectConditionProgrammed),
							Status:  metav1.ConditionFalse,
							Reason:  "BadRequest",
							Message: "Invalid PKIProfile specification: Bad Request",
						},
					},
				},
				Spec: akov1alpha1.PKIProfileSpec{
					CACerts: []*akov1alpha1.SSLCertificate{{Certificate: func() *string {
						s := testCertificate
						return &s
					}()}},
				},
			},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create mock AVI client
			mockAviClient := mock.NewMockAviClientInterface(gomock.NewController(t))
			if tt.prepare != nil {
				tt.prepare(mockAviClient)
			}

			mockCache := mock.NewMockCacheOperation(gomock.NewController(t))
			if tt.prepareCache != nil {
				tt.prepareCache(mockCache)
			}

			// Create fake k8s client
			scheme := runtime.NewScheme()
			_ = akov1alpha1.AddToScheme(scheme)
			_ = corev1.AddToScheme(scheme)

			// Create namespace object with tenant annotation
			namespace := createNamespaceWithTenant(tt.pki.Namespace)
			if tt.pki.Namespace == "" {
				namespace = createNamespaceWithTenant("default")
			}

			fakeClient := fake.NewClientBuilder().WithScheme(scheme).WithObjects(tt.pki, namespace).WithStatusSubresource(tt.pki).Build()

			// Create reconciler
			reconciler := &PKIProfileReconciler{
				Client:        fakeClient,
				AviClient:     mockAviClient,
				Scheme:        scheme,
				Logger:        utils.AviLog,
				EventRecorder: record.NewFakeRecorder(10),
				ClusterName:   "test-cluster",
				Cache:         mockCache,
			}

			// Test reconcile
			ctx := context.Background()
			_, err := reconciler.Reconcile(ctx, ctrl.Request{
				NamespacedName: types.NamespacedName{
					Name:      tt.pki.Name,
					Namespace: tt.pki.Namespace,
				},
			})

			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}

			// Get the updated object
			updatedPKI := &akov1alpha1.PKIProfile{}
			err = fakeClient.Get(ctx, types.NamespacedName{Name: tt.pki.Name, Namespace: tt.pki.Namespace}, updatedPKI)

			// For deletion tests, the object might be removed from the client
			if tt.pki.DeletionTimestamp != nil && k8serror.IsNotFound(err) {
				// Object was successfully deleted, skip further checks
				return
			}

			// If we expect an error or want is nil, skip further checks
			if tt.wantErr || tt.want == nil {
				return
			}

			assert.NoError(t, err)

			// Check finalizers
			assert.Equal(t, tt.want.Finalizers, updatedPKI.Finalizers)

			// Check status fields
			assert.Equal(t, tt.want.Status.UUID, updatedPKI.Status.UUID)
			assert.Equal(t, tt.want.Status.Controller, updatedPKI.Status.Controller)
			assert.Equal(t, tt.want.Status.ObservedGeneration, updatedPKI.Status.ObservedGeneration)

			// Check conditions
			if len(tt.want.Status.Conditions) > 0 && len(updatedPKI.Status.Conditions) > 0 {
				assert.Equal(t, len(tt.want.Status.Conditions), len(updatedPKI.Status.Conditions))
				for i, expectedCondition := range tt.want.Status.Conditions {
					if i < len(updatedPKI.Status.Conditions) {
						actualCondition := updatedPKI.Status.Conditions[i]
						assert.Equal(t, expectedCondition.Type, actualCondition.Type)
						assert.Equal(t, expectedCondition.Status, actualCondition.Status)
						assert.Equal(t, expectedCondition.Reason, actualCondition.Reason)
					}
				}
			}
		})
	}
}

func TestPKIProfileControllerKubernetesError(t *testing.T) {
	lib.SetNamePrefix(crdlib.Prefix)
	lib.SetClusterName("test-cluster")
	os.Setenv("ENABLE_EVH", "true")
	tests := []struct {
		name        string
		pki         *akov1alpha1.PKIProfile
		interceptor interceptor.Funcs
		wantErr     bool
	}{
		{
			name: "error: kubernetes client get error",
			pki: &akov1alpha1.PKIProfile{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "test",
					Namespace: "default",
				},
			},
			interceptor: interceptor.Funcs{
				Get: func(ctx context.Context, client client.WithWatch, key client.ObjectKey, obj client.Object, opts ...client.GetOption) error {
					return errors.New("get error")
				},
			},
			wantErr: true,
		},
		{
			name: "success: kubernetes client not found error",
			pki: &akov1alpha1.PKIProfile{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "test",
					Namespace: "default",
				},
			},
			interceptor: interceptor.Funcs{
				Get: func(ctx context.Context, client client.WithWatch, key client.ObjectKey, obj client.Object, opts ...client.GetOption) error {
					return k8serror.NewNotFound(akov1alpha1.GroupVersion.WithResource("pkiprofiles").GroupResource(), "test")
				},
			},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create fake k8s client with interceptor
			scheme := runtime.NewScheme()
			_ = akov1alpha1.AddToScheme(scheme)
			_ = corev1.AddToScheme(scheme)

			// Create namespace object with tenant annotation
			namespace := createNamespaceWithTenant("default")

			fakeClient := fake.NewClientBuilder().WithScheme(scheme).WithObjects(tt.pki, namespace).WithStatusSubresource(tt.pki).WithInterceptorFuncs(tt.interceptor).Build()

			// Create reconciler
			reconciler := &PKIProfileReconciler{
				Client:        fakeClient,
				Scheme:        scheme,
				Logger:        utils.AviLog,
				EventRecorder: record.NewFakeRecorder(10),
				ClusterName:   "test-cluster",
			}

			// Test reconcile
			ctx := context.Background()
			_, err := reconciler.Reconcile(ctx, ctrl.Request{
				NamespacedName: types.NamespacedName{
					Name:      tt.pki.Name,
					Namespace: tt.pki.Namespace,
				},
			})

			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

func TestPKIProfileSetStatus(t *testing.T) {
	lib.SetNamePrefix(crdlib.Prefix)
	lib.SetClusterName("test-cluster")
	os.Setenv("ENABLE_EVH", "true")
	tests := []struct {
		name            string
		initialPKI      *akov1alpha1.PKIProfile
		conditionType   akov1alpha1.ObjectConditionType
		conditionStatus metav1.ConditionStatus
		reason          akov1alpha1.ObjectConditionReason
		message         string
	}{
		{
			name: "success: set Deleted condition to True",
			initialPKI: &akov1alpha1.PKIProfile{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "test-pki-deleted",
					Namespace: "default",
				},
			},
			conditionType:   akov1alpha1.ObjectConditionProgrammed,
			conditionStatus: metav1.ConditionTrue,
			reason:          akov1alpha1.ObjectReasonDeletionSkipped,
			message:         "UUID not present, PKIProfile may not have been created on Avi Controller",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create fake k8s client
			scheme := runtime.NewScheme()
			_ = akov1alpha1.AddToScheme(scheme)
			_ = corev1.AddToScheme(scheme)

			// Create namespace object with tenant annotation
			namespace := createNamespaceWithTenant(tt.initialPKI.Namespace)

			fakeClient := fake.NewClientBuilder().WithScheme(scheme).WithObjects(tt.initialPKI, namespace).WithStatusSubresource(tt.initialPKI).Build()

			// Create reconciler
			reconciler := &PKIProfileReconciler{
				Client:        fakeClient,
				Scheme:        scheme,
				Logger:        utils.AviLog,
				EventRecorder: record.NewFakeRecorder(10),
				ClusterName:   "test-cluster",
			}

			// Test SetStatus
			ctx := context.Background()
			err := reconciler.SetStatus(ctx, tt.initialPKI, tt.conditionType, tt.conditionStatus, tt.reason, tt.message)
			assert.NoError(t, err)

			// Check status was set correctly
			assert.Equal(t, crdlib.AKOCRDController, tt.initialPKI.Status.Controller)
			assert.Equal(t, tt.message, tt.initialPKI.Status.Conditions[0].Message)
			assert.Equal(t, tt.initialPKI.Generation, tt.initialPKI.Status.ObservedGeneration)
			assert.NotNil(t, tt.initialPKI.Status.LastUpdated)

			// Check conditions
			found := false
			for _, condition := range tt.initialPKI.Status.Conditions {
				if condition.Type == string(tt.conditionType) && condition.Reason == string(tt.reason) {
					found = true
					assert.Equal(t, string(tt.conditionStatus), string(condition.Status))
					break
				}
			}
			assert.True(t, found, "Expected condition with type %s and reason %s", tt.conditionType, tt.reason)
		})
	}
}
