// @AI-Generated
// [Generated by Cursor claude-4-sonnet]
package event

import (
	"testing"

	"github.com/stretchr/testify/assert"
	akov1alpha1 "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-crd-operator/api/v1alpha1"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/utils"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
)

func TestNewEventManager(t *testing.T) {
	tests := []struct {
		name          string
		eventRecorder *utils.EventRecorder
		podMeta       *v1.Pod
		expectNil     bool
	}{
		{
			name:          "valid event recorder and pod",
			eventRecorder: &utils.EventRecorder{Fake: true},
			podMeta: &v1.Pod{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "test-pod",
					Namespace: "default",
				},
			},
			expectNil: false,
		},
		{
			name:          "nil event recorder",
			eventRecorder: nil,
			podMeta: &v1.Pod{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "test-pod",
					Namespace: "default",
				},
			},
			expectNil: false,
		},
		{
			name:          "nil pod metadata",
			eventRecorder: &utils.EventRecorder{Fake: true},
			podMeta:       nil,
			expectNil:     false,
		},
		{
			name:          "both nil",
			eventRecorder: nil,
			podMeta:       nil,
			expectNil:     false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			eventManager := NewEventManager(tt.eventRecorder, tt.podMeta)

			if tt.expectNil {
				assert.Nil(t, eventManager)
			} else {
				assert.NotNil(t, eventManager)
				assert.Equal(t, tt.eventRecorder, eventManager.eventRecorder)
				assert.Equal(t, tt.podMeta, eventManager.podMeta)
			}
		})
	}
}

func TestEventManager_PodEventf(t *testing.T) {
	tests := []struct {
		name        string
		eventType   string
		reason      string
		message     string
		formatArgs  []string
		expectPanic bool
	}{
		{
			name:       "normal event",
			eventType:  "Normal",
			reason:     "Created",
			message:    "Pod created successfully",
			formatArgs: []string{},
		},
		{
			name:       "warning event",
			eventType:  "Warning",
			reason:     "Failed",
			message:    "Pod creation failed",
			formatArgs: []string{},
		},
		{
			name:       "event with format args",
			eventType:  "Normal",
			reason:     "Updated",
			message:    "Pod %s updated in namespace %s",
			formatArgs: []string{"test-pod", "default"},
		},
		{
			name:       "empty strings",
			eventType:  "",
			reason:     "",
			message:    "",
			formatArgs: []string{},
		},
		{
			name:       "nil format args",
			eventType:  "Normal",
			reason:     "Test",
			message:    "Test message",
			formatArgs: nil,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create a fake EventRecorder to avoid nil pointer dereferences
			eventRecorder := &utils.EventRecorder{Fake: true}
			pod := &v1.Pod{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "test-pod",
					Namespace: "default",
				},
			}
			eventManager := NewEventManager(eventRecorder, pod)

			if tt.expectPanic {
				assert.Panics(t, func() {
					eventManager.PodEventf(tt.eventType, tt.reason, tt.message, tt.formatArgs...)
				})
			} else {
				// Test that the method doesn't panic and completes successfully
				assert.NotPanics(t, func() {
					eventManager.PodEventf(tt.eventType, tt.reason, tt.message, tt.formatArgs...)
				})
			}
		})
	}
}

func TestEventManager_PodEventf_WithNilPod(t *testing.T) {
	eventRecorder := &utils.EventRecorder{Fake: true}
	eventManager := NewEventManager(eventRecorder, nil)

	// Test that calling PodEventf with nil pod doesn't panic
	assert.NotPanics(t, func() {
		eventManager.PodEventf("Normal", "Test", "Test message")
	})
}

func TestEventManager_PodEventf_WithNilEventRecorder(t *testing.T) {
	pod := &v1.Pod{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-pod",
			Namespace: "default",
		},
	}
	eventManager := NewEventManager(nil, pod)

	// Test that calling PodEventf with nil event recorder panics
	assert.Panics(t, func() {
		eventManager.PodEventf("Normal", "Test", "Test message")
	})
}

func TestEventManager_Eventf(t *testing.T) {
	tests := []struct {
		name              string
		runtimeObjectMeta runtime.Object
		eventType         string
		reason            string
		message           string
		formatArgs        []string
		expectPanic       bool
	}{
		{
			name: "healthmonitor object",
			runtimeObjectMeta: &akov1alpha1.HealthMonitor{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "test-healthmonitor",
					Namespace: "default",
				},
			},
			eventType:  "Normal",
			reason:     "Created",
			message:    "HealthMonitor created successfully",
			formatArgs: []string{},
		},
		{
			name: "applicationprofile object",
			runtimeObjectMeta: &akov1alpha1.ApplicationProfile{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "test-applicationprofile",
					Namespace: "default",
				},
			},
			eventType:  "Warning",
			reason:     "ValidationFailed",
			message:    "ApplicationProfile validation failed",
			formatArgs: []string{},
		},
		{
			name: "pod object",
			runtimeObjectMeta: &v1.Pod{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "test-pod",
					Namespace: "default",
				},
			},
			eventType:  "Normal",
			reason:     "Started",
			message:    "Pod %s started in namespace %s",
			formatArgs: []string{"test-pod", "default"},
		},
		{
			name:              "nil runtime object",
			runtimeObjectMeta: nil,
			eventType:         "Normal",
			reason:            "Test",
			message:           "Test message",
			formatArgs:        []string{},
		},
		{
			name: "empty event details",
			runtimeObjectMeta: &akov1alpha1.HealthMonitor{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "test-hm",
					Namespace: "default",
				},
			},
			eventType:  "",
			reason:     "",
			message:    "",
			formatArgs: []string{},
		},
		{
			name: "multiple format args",
			runtimeObjectMeta: &akov1alpha1.ApplicationProfile{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "test-ap",
					Namespace: "test-ns",
				},
			},
			eventType:  "Warning",
			reason:     "ConfigError",
			message:    "Configuration error in %s: %s (code: %s)",
			formatArgs: []string{"test-ap", "invalid config", "400"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create a fake EventRecorder to avoid nil pointer dereferences
			eventRecorder := &utils.EventRecorder{Fake: true}
			pod := &v1.Pod{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "test-pod",
					Namespace: "default",
				},
			}
			eventManager := NewEventManager(eventRecorder, pod)

			if tt.expectPanic {
				assert.Panics(t, func() {
					eventManager.Eventf(tt.runtimeObjectMeta, tt.eventType, tt.reason, tt.message, tt.formatArgs...)
				})
			} else {
				// Test that the method doesn't panic and completes successfully
				assert.NotPanics(t, func() {
					eventManager.Eventf(tt.runtimeObjectMeta, tt.eventType, tt.reason, tt.message, tt.formatArgs...)
				})
			}
		})
	}
}

func TestEventManager_Eventf_WithNilEventRecorder(t *testing.T) {
	pod := &v1.Pod{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-pod",
			Namespace: "default",
		},
	}
	eventManager := NewEventManager(nil, pod)

	healthMonitor := &akov1alpha1.HealthMonitor{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-healthmonitor",
			Namespace: "default",
		},
	}

	// Test that calling Eventf with nil event recorder panics
	assert.Panics(t, func() {
		eventManager.Eventf(healthMonitor, "Normal", "Test", "Test message")
	})
}

func TestEventManager_Eventf_VariadicArgs(t *testing.T) {
	eventRecorder := &utils.EventRecorder{Fake: true}
	pod := &v1.Pod{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-pod",
			Namespace: "default",
		},
	}
	eventManager := NewEventManager(eventRecorder, pod)

	healthMonitor := &akov1alpha1.HealthMonitor{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-healthmonitor",
			Namespace: "default",
		},
	}

	// Test different variadic argument patterns
	testCases := []struct {
		name string
		call func()
	}{
		{
			name: "no format args",
			call: func() {
				eventManager.Eventf(healthMonitor, "Normal", "Test", "No format args")
			},
		},
		{
			name: "single format arg",
			call: func() {
				eventManager.Eventf(healthMonitor, "Normal", "Test", "Single arg: %s", "value")
			},
		},
		{
			name: "multiple format args",
			call: func() {
				eventManager.Eventf(healthMonitor, "Normal", "Test", "Multiple args: %s, %s, %s", "string", "123", "true")
			},
		},
		{
			name: "empty format args slice",
			call: func() {
				eventManager.Eventf(healthMonitor, "Normal", "Test", "Empty args", []string{}...)
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			assert.NotPanics(t, tc.call)
		})
	}
}

func TestEventManager_FieldAccess(t *testing.T) {
	eventRecorder := &utils.EventRecorder{Fake: true}
	pod := &v1.Pod{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-pod",
			Namespace: "default",
		},
	}

	eventManager := NewEventManager(eventRecorder, pod)

	// Test that the fields are properly set and accessible
	assert.Equal(t, eventRecorder, eventManager.eventRecorder)
	assert.Equal(t, pod, eventManager.podMeta)

	// Test behavior with different pod configurations
	t.Run("with minimal pod", func(t *testing.T) {
		minimalPod := &v1.Pod{
			ObjectMeta: metav1.ObjectMeta{
				Name: "minimal-pod",
			},
		}
		em := NewEventManager(eventRecorder, minimalPod)
		assert.Equal(t, minimalPod, em.podMeta)
		assert.NotPanics(t, func() {
			em.PodEventf("Normal", "Test", "Minimal pod test")
		})
	})

	t.Run("with full pod metadata", func(t *testing.T) {
		fullPod := &v1.Pod{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "full-pod",
				Namespace: "test-namespace",
				Labels: map[string]string{
					"app": "test-app",
				},
				Annotations: map[string]string{
					"test": "annotation",
				},
			},
		}
		em := NewEventManager(eventRecorder, fullPod)
		assert.Equal(t, fullPod, em.podMeta)
		assert.NotPanics(t, func() {
			em.PodEventf("Normal", "Test", "Full pod test")
		})
	})
}

func TestEventManager_ConcurrentUsage(t *testing.T) {
	eventRecorder := &utils.EventRecorder{Fake: true}
	pod := &v1.Pod{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "concurrent-pod",
			Namespace: "default",
		},
	}
	eventManager := NewEventManager(eventRecorder, pod)

	// Test concurrent access to EventManager methods
	done := make(chan bool, 10)

	for i := 0; i < 10; i++ {
		go func(id int) {
			defer func() {
				done <- true
			}()

			// Test PodEventf
			assert.NotPanics(t, func() {
				eventManager.PodEventf("Normal", "ConcurrentTest", "Concurrent test %d", []string{string(rune(id + '0'))}...)
			})

			// Test Eventf
			hm := &akov1alpha1.HealthMonitor{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "concurrent-hm",
					Namespace: "default",
				},
			}
			assert.NotPanics(t, func() {
				eventManager.Eventf(hm, "Normal", "ConcurrentTest", "Concurrent test %d", []string{string(rune(id + '0'))}...)
			})
		}(i)
	}

	// Wait for all goroutines to complete
	for i := 0; i < 10; i++ {
		<-done
	}
}

func TestEventManager_EnabledDisabledBehavior(t *testing.T) {
	tests := []struct {
		name               string
		enabled            bool
		fake               bool
		expectNormalPanic  bool
		expectWarningPanic bool
	}{
		{
			name:               "enabled fake recorder",
			enabled:            true,
			fake:               true,
			expectNormalPanic:  false,
			expectWarningPanic: false,
		},
		{
			name:               "disabled fake recorder",
			enabled:            false,
			fake:               true,
			expectNormalPanic:  false,
			expectWarningPanic: false,
		},
		{
			name:               "enabled non-fake recorder without proper init",
			enabled:            true,
			fake:               false,
			expectNormalPanic:  true, // Should panic because Recorder field is nil
			expectWarningPanic: true, // Should panic because Recorder field is nil
		},
		{
			name:               "disabled non-fake recorder without proper init",
			enabled:            false,
			fake:               false,
			expectNormalPanic:  false, // Should NOT panic because events are disabled for Normal events
			expectWarningPanic: true,  // Should panic because warning events are always processed
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			eventRecorder := &utils.EventRecorder{
				Enabled: tt.enabled,
				Fake:    tt.fake,
			}
			pod := &v1.Pod{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "test-pod",
					Namespace: "default",
				},
			}
			eventManager := NewEventManager(eventRecorder, pod)

			// Test Normal events
			if tt.expectNormalPanic {
				assert.Panics(t, func() {
					eventManager.PodEventf(v1.EventTypeNormal, "Test", "Test message")
				})
			} else {
				assert.NotPanics(t, func() {
					eventManager.PodEventf(v1.EventTypeNormal, "Test", "Test message")
				})
			}

			hm := &akov1alpha1.HealthMonitor{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "test-hm",
					Namespace: "default",
				},
			}
			if tt.expectNormalPanic {
				assert.Panics(t, func() {
					eventManager.Eventf(hm, v1.EventTypeNormal, "Test", "Test message")
				})
			} else {
				assert.NotPanics(t, func() {
					eventManager.Eventf(hm, v1.EventTypeNormal, "Test", "Test message")
				})
			}

			// Test Warning events - these are always processed even if disabled for non-fake recorders
			if tt.expectWarningPanic {
				assert.Panics(t, func() {
					eventManager.PodEventf(v1.EventTypeWarning, "Test", "Warning message")
				})
				assert.Panics(t, func() {
					eventManager.Eventf(hm, v1.EventTypeWarning, "Test", "Warning message")
				})
			} else {
				assert.NotPanics(t, func() {
					eventManager.PodEventf(v1.EventTypeWarning, "Test", "Warning message")
				})
				assert.NotPanics(t, func() {
					eventManager.Eventf(hm, v1.EventTypeWarning, "Test", "Warning message")
				})
			}
		})
	}
}
