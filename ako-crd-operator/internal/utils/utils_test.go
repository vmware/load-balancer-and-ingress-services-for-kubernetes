// @AI-Generated
// [Generated by Cursor claude-4-sonnet]
package utils

import (
	"context"
	"errors"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/vmware/alb-sdk/go/clients"
	"github.com/vmware/alb-sdk/go/session"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/lib"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/utils"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	kubefake "k8s.io/client-go/kubernetes/fake"
	clientfake "sigs.k8s.io/controller-runtime/pkg/client/fake"

	akov1alpha1 "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-crd-operator/api/v1alpha1"
)

func TestIsRetryableError(t *testing.T) {
	tests := []struct {
		name     string
		err      error
		expected bool
	}{
		{
			name:     "non-avi error should be retryable",
			err:      errors.New("network error"),
			expected: true,
		},
		{
			name: "avi error 400 should not be retryable",
			err: session.AviError{
				HttpStatusCode: 400,
			},
			expected: false,
		},
		{
			name: "avi error 401 should not be retryable",
			err: session.AviError{
				HttpStatusCode: 401,
			},
			expected: false,
		},
		{
			name: "avi error 403 should not be retryable",
			err: session.AviError{
				HttpStatusCode: 403,
			},
			expected: false,
		},
		{
			name: "avi error 404 should not be retryable",
			err: session.AviError{
				HttpStatusCode: 404,
			},
			expected: false,
		},
		{
			name: "avi error 409 should not be retryable",
			err: session.AviError{
				HttpStatusCode: 409,
			},
			expected: false,
		},
		{
			name: "avi error 412 should not be retryable",
			err: session.AviError{
				HttpStatusCode: 412,
			},
			expected: false,
		},
		{
			name: "avi error 422 should not be retryable",
			err: session.AviError{
				HttpStatusCode: 422,
			},
			expected: false,
		},
		{
			name: "avi error 501 should not be retryable",
			err: session.AviError{
				HttpStatusCode: 501,
			},
			expected: false,
		},
		{
			name: "avi error 500 should be retryable",
			err: session.AviError{
				HttpStatusCode: 500,
			},
			expected: true,
		},
		{
			name: "avi error 502 should be retryable",
			err: session.AviError{
				HttpStatusCode: 502,
			},
			expected: true,
		},
		{
			name: "avi error 503 should be retryable",
			err: session.AviError{
				HttpStatusCode: 503,
			},
			expected: true,
		},
		{
			name: "avi error 504 should be retryable",
			err: session.AviError{
				HttpStatusCode: 504,
			},
			expected: true,
		},
		{
			name: "avi error with unknown status code should be retryable",
			err: session.AviError{
				HttpStatusCode: 999,
			},
			expected: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := IsRetryableError(tt.err)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestUpdateStatusWithNonRetryableError(t *testing.T) {
	scheme := runtime.NewScheme()
	_ = akov1alpha1.AddToScheme(scheme)

	tests := []struct {
		name             string
		err              error
		resourceType     string
		expectedReason   string
		expectedMsg      string
		generation       int64
		useHealthMonitor bool
	}{
		{
			name:             "generic error with HealthMonitor",
			err:              errors.New("generic error"),
			resourceType:     "HealthMonitor",
			expectedReason:   "ConfigurationError",
			expectedMsg:      "Non-retryable error: generic error",
			generation:       1,
			useHealthMonitor: true,
		},
		{
			name: "avi error 400 with ApplicationProfile",
			err: session.AviError{
				HttpStatusCode: 400,
				AviResult: session.AviResult{
					Message: &[]string{"invalid request"}[0],
				},
			},
			resourceType:     "ApplicationProfile",
			expectedReason:   "BadRequest",
			expectedMsg:      "Invalid ApplicationProfile specification: error from Controller: invalid request",
			generation:       2,
			useHealthMonitor: false,
		},
		{
			name: "avi error 401 with HealthMonitor",
			err: session.AviError{
				HttpStatusCode: 401,
			},
			resourceType:     "HealthMonitor",
			expectedReason:   "Unauthorized",
			expectedMsg:      "Authentication failed with Avi Controller",
			generation:       3,
			useHealthMonitor: true,
		},
		{
			name: "avi error 403 with ApplicationProfile",
			err: session.AviError{
				HttpStatusCode: 403,
			},
			resourceType:     "ApplicationProfile",
			expectedReason:   "Forbidden",
			expectedMsg:      "Insufficient permissions to create/update ApplicationProfile on Avi Controller",
			generation:       4,
			useHealthMonitor: false,
		},
		{
			name: "avi error 409 with HealthMonitor",
			err: session.AviError{
				HttpStatusCode: 409,
				AviResult: session.AviResult{
					Message: &[]string{"resource conflict"}[0],
				},
			},
			resourceType:     "HealthMonitor",
			expectedReason:   "Conflict",
			expectedMsg:      "Resource conflict on Avi Controller: error from Controller: resource conflict",
			generation:       5,
			useHealthMonitor: true,
		},
		{
			name: "avi error 422 with ApplicationProfile",
			err: session.AviError{
				HttpStatusCode: 422,
				AviResult: session.AviResult{
					Message: &[]string{"validation failed"}[0],
				},
			},
			resourceType:     "ApplicationProfile",
			expectedReason:   "ValidationError",
			expectedMsg:      "ApplicationProfile validation failed on Avi Controller: error from Controller: validation failed",
			generation:       6,
			useHealthMonitor: false,
		},
		{
			name: "avi error 501 with HealthMonitor",
			err: session.AviError{
				HttpStatusCode: 501,
			},
			resourceType:     "HealthMonitor",
			expectedReason:   "NotImplemented",
			expectedMsg:      "HealthMonitor feature not supported by Avi Controller version",
			generation:       7,
			useHealthMonitor: true,
		},
		{
			name: "avi error without message with ApplicationProfile",
			err: session.AviError{
				HttpStatusCode: 400,
			},
			resourceType:     "ApplicationProfile",
			expectedReason:   "BadRequest",
			expectedMsg:      "Invalid ApplicationProfile specification: Encountered an error on  request to URL : HTTP code: 400.",
			generation:       8,
			useHealthMonitor: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var resource ResourceWithStatus

			if tt.useHealthMonitor {
				hm := &akov1alpha1.HealthMonitor{
					ObjectMeta: metav1.ObjectMeta{
						Name:       "test-healthmonitor",
						Namespace:  "default",
						Generation: tt.generation,
					},
					Spec: akov1alpha1.HealthMonitorSpec{
						Type: akov1alpha1.HealthMonitorTCP,
					},
				}
				resource = hm
			} else {
				ap := &akov1alpha1.ApplicationProfile{
					ObjectMeta: metav1.ObjectMeta{
						Name:       "test-applicationprofile",
						Namespace:  "default",
						Generation: tt.generation,
					},
					Spec: akov1alpha1.ApplicationProfileSpec{
						Type: akov1alpha1.APPLICATION_PROFILE_TYPE_HTTP,
					},
				}
				resource = ap
			}

			fakeClient := clientfake.NewClientBuilder().
				WithScheme(scheme).
				WithObjects(resource).
				WithStatusSubresource(resource).
				Build()

			// Create context
			ctx := context.Background()

			UpdateStatusWithNonRetryableError(ctx, fakeClient, resource, tt.err, tt.resourceType)

			// Verify conditions
			conditions := resource.GetConditions()
			assert.Len(t, conditions, 1)

			condition := conditions[0]
			assert.Equal(t, "Ready", condition.Type)
			assert.Equal(t, metav1.ConditionFalse, condition.Status)
			assert.Equal(t, tt.expectedReason, condition.Reason)
			assert.Equal(t, tt.expectedMsg, condition.Message)
			assert.NotNil(t, condition.LastTransitionTime)

			// Verify observed generation and last updated - ApplicationProfile and HealthMonitor implement this
			if tt.useHealthMonitor {
				hm := resource.(*akov1alpha1.HealthMonitor)
				assert.Equal(t, tt.generation, hm.Status.ObservedGeneration)
				assert.NotNil(t, hm.Status.LastUpdated)
			} else {
				ap := resource.(*akov1alpha1.ApplicationProfile)
				assert.Equal(t, tt.generation, ap.Status.ObservedGeneration)
				assert.NotNil(t, ap.Status.LastUpdated)
			}
		})
	}
}

func TestExtractAviControllerErrorMessage(t *testing.T) {
	tests := []struct {
		name     string
		aviError session.AviError
		expected string
	}{
		{
			name: "error with message",
			aviError: session.AviError{
				AviResult: session.AviResult{
					Message: &[]string{"custom error message"}[0],
				},
			},
			expected: "error from Controller: custom error message",
		},
		{
			name: "error without message",
			aviError: session.AviError{
				HttpStatusCode: 400,
			},
			expected: "Encountered an error on  request to URL : HTTP code: 400.",
		},
		{
			name: "error with empty message",
			aviError: session.AviError{
				AviResult: session.AviResult{
					Message: &[]string{""}[0],
				},
				HttpStatusCode: 500,
			},
			expected: "Encountered an error on  request to URL : HTTP code: 500; error from Controller: ",
		},
		{
			name: "error with nil message",
			aviError: session.AviError{
				AviResult: session.AviResult{
					Message: nil,
				},
				HttpStatusCode: 404,
			},
			expected: "Encountered an error on  request to URL : HTTP code: 404.",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := extractAviControllerErrorMessage(tt.aviError)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestSetCondition(t *testing.T) {
	now := metav1.Time{Time: time.Now()}

	tests := []struct {
		name           string
		conditions     []metav1.Condition
		newCondition   metav1.Condition
		expectedLength int
		expectedType   string
		expectedStatus metav1.ConditionStatus
	}{
		{
			name:       "add new condition to empty slice",
			conditions: []metav1.Condition{},
			newCondition: metav1.Condition{
				Type:               "Ready",
				Status:             metav1.ConditionTrue,
				LastTransitionTime: now,
				Reason:             "Success",
				Message:            "All good",
			},
			expectedLength: 1,
			expectedType:   "Ready",
			expectedStatus: metav1.ConditionTrue,
		},
		{
			name: "add new condition to existing slice",
			conditions: []metav1.Condition{
				{
					Type:               "Available",
					Status:             metav1.ConditionTrue,
					LastTransitionTime: now,
					Reason:             "Available",
					Message:            "Resource is available",
				},
			},
			newCondition: metav1.Condition{
				Type:               "Ready",
				Status:             metav1.ConditionTrue,
				LastTransitionTime: now,
				Reason:             "Success",
				Message:            "All good",
			},
			expectedLength: 2,
			expectedType:   "Ready",
			expectedStatus: metav1.ConditionTrue,
		},
		{
			name: "update existing condition",
			conditions: []metav1.Condition{
				{
					Type:               "Ready",
					Status:             metav1.ConditionFalse,
					LastTransitionTime: now,
					Reason:             "Error",
					Message:            "Something wrong",
				},
			},
			newCondition: metav1.Condition{
				Type:               "Ready",
				Status:             metav1.ConditionTrue,
				LastTransitionTime: now,
				Reason:             "Success",
				Message:            "All good",
			},
			expectedLength: 1,
			expectedType:   "Ready",
			expectedStatus: metav1.ConditionTrue,
		},
		{
			name: "update condition in middle of slice",
			conditions: []metav1.Condition{
				{
					Type:               "Available",
					Status:             metav1.ConditionTrue,
					LastTransitionTime: now,
					Reason:             "Available",
					Message:            "Resource is available",
				},
				{
					Type:               "Ready",
					Status:             metav1.ConditionFalse,
					LastTransitionTime: now,
					Reason:             "Error",
					Message:            "Something wrong",
				},
				{
					Type:               "Progressing",
					Status:             metav1.ConditionTrue,
					LastTransitionTime: now,
					Reason:             "InProgress",
					Message:            "Work in progress",
				},
			},
			newCondition: metav1.Condition{
				Type:               "Ready",
				Status:             metav1.ConditionTrue,
				LastTransitionTime: now,
				Reason:             "Success",
				Message:            "All good",
			},
			expectedLength: 3,
			expectedType:   "Ready",
			expectedStatus: metav1.ConditionTrue,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := SetCondition(tt.conditions, tt.newCondition)

			assert.Len(t, result, tt.expectedLength)

			// Find the condition we added/updated
			var foundCondition *metav1.Condition
			for i := range result {
				if result[i].Type == tt.expectedType {
					foundCondition = &result[i]
					break
				}
			}

			assert.NotNil(t, foundCondition, "Expected condition not found")
			if foundCondition != nil {
				assert.Equal(t, tt.expectedStatus, foundCondition.Status)
				assert.Equal(t, tt.newCondition.Reason, foundCondition.Reason)
				assert.Equal(t, tt.newCondition.Message, foundCondition.Message)
			}
		})
	}
}

func TestCreateMarkers(t *testing.T) {
	tests := []struct {
		name           string
		clusterName    string
		namespace      string
		expectedLength int
		expectedKeys   []string
		expectedValues [][]string
	}{
		{
			name:           "both cluster name and namespace provided",
			clusterName:    "test-cluster",
			namespace:      "test-namespace",
			expectedLength: 2,
			expectedKeys:   []string{"clustername", "namespace"},
			expectedValues: [][]string{{"test-cluster"}, {"test-namespace"}},
		},
		{
			name:           "only cluster name provided",
			clusterName:    "test-cluster",
			namespace:      "",
			expectedLength: 1,
			expectedKeys:   []string{"clustername"},
			expectedValues: [][]string{{"test-cluster"}},
		},
		{
			name:           "only namespace provided",
			clusterName:    "",
			namespace:      "test-namespace",
			expectedLength: 1,
			expectedKeys:   []string{"namespace"},
			expectedValues: [][]string{{"test-namespace"}},
		},
		{
			name:           "neither cluster name nor namespace provided",
			clusterName:    "",
			namespace:      "",
			expectedLength: 0,
			expectedKeys:   []string{},
			expectedValues: [][]string{},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := CreateMarkers(tt.clusterName, tt.namespace)

			assert.Len(t, result, tt.expectedLength)

			// Verify each marker
			for i, marker := range result {
				assert.NotNil(t, marker.Key, "Marker key should not be nil")
				if marker.Key != nil {
					assert.Equal(t, tt.expectedKeys[i], *marker.Key)
				}
				assert.Equal(t, tt.expectedValues[i], marker.Values)
			}
		})
	}
}

func TestResourceWithStatusInterface(t *testing.T) {
	// Test that HealthMonitor implements ResourceWithStatus interface
	hm := &akov1alpha1.HealthMonitor{
		ObjectMeta: metav1.ObjectMeta{
			Generation: 123,
		},
	}

	// Test that our HealthMonitor implements the interface
	var _ ResourceWithStatus = hm

	// Test all interface methods on HealthMonitor
	assert.Equal(t, int64(123), hm.GetGeneration())

	conditions := []metav1.Condition{
		{
			Type:   "Ready",
			Status: metav1.ConditionTrue,
		},
	}
	hm.SetConditions(conditions)
	assert.Equal(t, conditions, hm.GetConditions())

	hm.SetObservedGeneration(456)
	assert.Equal(t, int64(456), hm.Status.ObservedGeneration)

	now := &metav1.Time{Time: time.Now()}
	hm.SetLastUpdated(now)
	assert.Equal(t, now, hm.Status.LastUpdated)

	// Test that ApplicationProfile implements ResourceWithStatus interface
	ap := &akov1alpha1.ApplicationProfile{
		ObjectMeta: metav1.ObjectMeta{
			Generation: 789,
		},
	}

	// Test that our ApplicationProfile implements the interface
	var _ ResourceWithStatus = ap

	// Test all interface methods on ApplicationProfile
	assert.Equal(t, int64(789), ap.GetGeneration())

	ap.SetConditions(conditions)
	assert.Equal(t, conditions, ap.GetConditions())

	ap.SetObservedGeneration(101112)
	assert.Equal(t, int64(101112), ap.Status.ObservedGeneration)

	ap.SetLastUpdated(now)
	assert.Equal(t, now, ap.Status.LastUpdated)
}

func TestParseAviErrorMessage(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "error message with array and obj_name",
			input:    `map[error:Cannot delete, object is referred by: [''IcapProfile custom-icap-profile'',    ''Pool custom-icap-pool1'', ''PoolGroup custom-icap-pg''] obj_name:my-cluster2-default-example-ping-healthmonitor]`,
			expected: "Cannot delete, object is referred by: [''IcapProfile custom-icap-profile'',    ''Pool custom-icap-pool1'', ''PoolGroup custom-icap-pg'']",
		},
		{
			name:     "simple error message with obj_name",
			input:    `map[error:Resource not found obj_name:test-resource]`,
			expected: "Resource not found",
		},
		{
			name:     "error message without obj_name",
			input:    `map[error:Invalid configuration]`,
			expected: "Invalid configuration",
		},
		{
			name:     "non-map format returns original",
			input:    `This is just a regular error message`,
			expected: "This is just a regular error message",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := ParseAviErrorMessage(tt.input)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestWaitForWCPCloudNameAndInitialize_AnnotationExists(t *testing.T) {
	// Save original function and restore after test
	originalFunc := newAviClientFunc
	defer func() { newAviClientFunc = originalFunc }()

	// Mock the function to return success
	newAviClientFunc = func(host string, username string, options ...func(*session.AviSession) error) (*clients.AviClient, error) {
		return &clients.AviClient{}, nil
	}

	// Create a namespace with the WCP cloud name annotation already set
	ns := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: utils.GetAKONamespace(),
			Annotations: map[string]string{
				lib.WCPCloud: "test-cloud",
			},
		},
	}

	// Create a configmap with required data
	cm := &corev1.ConfigMap{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "avi-k8s-config",
			Namespace: utils.GetAKONamespace(),
		},
		Data: map[string]string{
			"clusterID":    "test-cluster-id",
			"controllerIP": "192.168.1.100",
		},
	}

	// Create a secret with AVI credentials
	secret := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      lib.AviSecret,
			Namespace: utils.GetAKONamespace(),
		},
		Data: map[string][]byte{
			"username":                 []byte("admin"),
			"password":                 []byte("password"),
			"authtoken":                []byte("token123"),
			"certificateAuthorityData": []byte("ca-data"),
		},
	}

	// Create fake kubernetes client
	kubeClient := kubefake.NewSimpleClientset(ns, cm, secret)

	// Create a real logger for testing
	logger := utils.AviLog.WithName("test")

	ctx := context.Background()

	// Call the function
	err := WaitForWCPCloudNameAndInitialize(ctx, kubeClient, logger)

	// Verify success with mocked AVI client
	assert.NoError(t, err)
}

func TestWaitForWCPCloudNameAndInitialize_NamespaceNotFound(t *testing.T) {
	// Create fake kubernetes client with no namespace
	kubeClient := kubefake.NewSimpleClientset()

	// Create a real logger for testing
	logger := utils.AviLog.WithName("test")

	ctx := context.Background()

	// Call the function
	err := WaitForWCPCloudNameAndInitialize(ctx, kubeClient, logger)

	// Verify error occurred
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "not found")
}

func TestWaitForWCPCloudNameAndInitialize_NoAnnotation(t *testing.T) {
	// Create a namespace without the WCP cloud name annotation
	ns := &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: utils.GetAKONamespace(),
		},
	}

	// Create fake kubernetes client
	kubeClient := kubefake.NewSimpleClientset(ns)

	// Create a real logger for testing
	logger := utils.AviLog.WithName("test")

	// Create context with timeout to prevent test hanging
	ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)
	defer cancel()

	// Call the function
	err := WaitForWCPCloudNameAndInitialize(ctx, kubeClient, logger)

	// Verify timeout error occurred
	assert.Error(t, err)
	assert.Equal(t, context.DeadlineExceeded, err)
}

func TestInitializeClusterConfig_Success(t *testing.T) {
	// Save original function and restore after test
	originalFunc := newAviClientFunc
	defer func() { newAviClientFunc = originalFunc }()

	// Mock the function to return success
	newAviClientFunc = func(host string, username string, options ...func(*session.AviSession) error) (*clients.AviClient, error) {
		return &clients.AviClient{}, nil
	}

	// Create a configmap with required data
	cm := &corev1.ConfigMap{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "avi-k8s-config",
			Namespace: utils.GetAKONamespace(),
		},
		Data: map[string]string{
			"clusterID":    "test-cluster-id",
			"controllerIP": "192.168.1.100",
		},
	}

	// Create a secret with AVI credentials
	secret := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      lib.AviSecret,
			Namespace: utils.GetAKONamespace(),
		},
		Data: map[string][]byte{
			"username":                 []byte("admin"),
			"password":                 []byte("password"),
			"authtoken":                []byte("token123"),
			"certificateAuthorityData": []byte("ca-data"),
		},
	}

	// Create fake kubernetes client
	kubeClient := kubefake.NewSimpleClientset(cm, secret)

	// Create a real logger for testing
	logger := utils.AviLog.WithName("test")

	ctx := context.Background()

	// Call the function
	err := initializeClusterConfig(ctx, kubeClient, "test-cloud", logger)

	// Verify success with mocked AVI client
	assert.NoError(t, err)
}

func TestInitializeClusterConfig_ConfigMapNotFound(t *testing.T) {
	// Create fake kubernetes client with no configmap
	kubeClient := kubefake.NewSimpleClientset()

	// Create a real logger for testing
	logger := utils.AviLog.WithName("test")

	ctx := context.Background()

	// Call the function
	err := initializeClusterConfig(ctx, kubeClient, "test-cloud", logger)

	// Verify error occurred
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "not found")
}

func TestInitializeClusterConfig_MissingClusterID(t *testing.T) {
	// Create a configmap without clusterID
	cm := &corev1.ConfigMap{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "avi-k8s-config",
			Namespace: utils.GetAKONamespace(),
		},
		Data: map[string]string{
			"controllerIP": "192.168.1.100",
		},
	}

	// Create fake kubernetes client
	kubeClient := kubefake.NewSimpleClientset(cm)

	// Create a real logger for testing
	logger := utils.AviLog.WithName("test")

	ctx := context.Background()

	// Call the function
	err := initializeClusterConfig(ctx, kubeClient, "test-cloud", logger)

	// Verify error occurred
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "clusterID not found in configmap")
}

func TestInitializeClusterConfig_MissingControllerIP(t *testing.T) {
	// Create a configmap without controllerIP
	cm := &corev1.ConfigMap{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "avi-k8s-config",
			Namespace: utils.GetAKONamespace(),
		},
		Data: map[string]string{
			"clusterID": "test-cluster-id",
		},
	}

	// Create fake kubernetes client
	kubeClient := kubefake.NewSimpleClientset(cm)

	// Create a real logger for testing
	logger := utils.AviLog.WithName("test")

	ctx := context.Background()

	// Call the function
	err := initializeClusterConfig(ctx, kubeClient, "test-cloud", logger)

	// Verify error occurred
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "controllerIP not found in configmap")
}

func TestValidateAviSecret_SecretNotFound(t *testing.T) {
	// Create fake kubernetes client with no secret
	kubeClient := kubefake.NewSimpleClientset()

	// Create a real logger for testing
	logger := utils.AviLog.WithName("test")

	ctx := context.Background()

	// Call the function
	err := validateAviSecret(ctx, kubeClient, "192.168.1.100", logger)

	// Verify error occurred
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "not found")
}

func TestValidateAviSecret_MissingUsername(t *testing.T) {
	// Create a secret without username
	secret := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      lib.AviSecret,
			Namespace: utils.GetAKONamespace(),
		},
		Data: map[string][]byte{
			"password":                 []byte("password"),
			"certificateAuthorityData": []byte("ca-data"),
		},
	}

	// Create fake kubernetes client
	kubeClient := kubefake.NewSimpleClientset(secret)

	// Create a real logger for testing
	logger := utils.AviLog.WithName("test")

	ctx := context.Background()

	// Call the function
	err := validateAviSecret(ctx, kubeClient, "192.168.1.100", logger)

	// Verify error occurred
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "username is required")
}

func TestValidateAviSecret_MissingCredentials(t *testing.T) {
	// Create a secret without password or authtoken
	secret := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      lib.AviSecret,
			Namespace: utils.GetAKONamespace(),
		},
		Data: map[string][]byte{
			"username":                 []byte("admin"),
			"certificateAuthorityData": []byte("ca-data"),
		},
	}

	// Create fake kubernetes client
	kubeClient := kubefake.NewSimpleClientset(secret)

	// Create a real logger for testing
	logger := utils.AviLog.WithName("test")

	ctx := context.Background()

	// Call the function
	err := validateAviSecret(ctx, kubeClient, "192.168.1.100", logger)

	// Verify error occurred
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "either password or authtoken must be provided")
}

func TestValidateAviSecret_ValidCredentials(t *testing.T) {
	// Save original function and restore after test
	originalFunc := newAviClientFunc
	defer func() { newAviClientFunc = originalFunc }()

	// Mock the function to return success
	newAviClientFunc = func(host string, username string, options ...func(*session.AviSession) error) (*clients.AviClient, error) {
		return &clients.AviClient{}, nil
	}

	// Create a secret with valid credentials
	secret := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      lib.AviSecret,
			Namespace: utils.GetAKONamespace(),
		},
		Data: map[string][]byte{
			"username":                 []byte("admin"),
			"password":                 []byte("password"),
			"authtoken":                []byte("token123"),
			"certificateAuthorityData": []byte("ca-data"),
		},
	}

	// Create fake kubernetes client
	kubeClient := kubefake.NewSimpleClientset(secret)

	// Create a real logger for testing
	logger := utils.AviLog.WithName("test")

	ctx := context.Background()

	// Call the function
	err := validateAviSecret(ctx, kubeClient, "192.168.1.100", logger)

	// Verify success with mocked AVI client
	assert.NoError(t, err)
}
