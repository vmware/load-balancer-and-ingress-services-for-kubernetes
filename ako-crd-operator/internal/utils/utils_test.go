// @AI-Generated
// [Generated by Cursor claude-4-sonnet]
package utils

import (
	"context"
	"errors"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/vmware/alb-sdk/go/session"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"sigs.k8s.io/controller-runtime/pkg/client/fake"

	akov1alpha1 "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-crd-operator/api/v1alpha1"
)

func TestIsRetryableError(t *testing.T) {
	tests := []struct {
		name     string
		err      error
		expected bool
	}{
		{
			name:     "non-avi error should be retryable",
			err:      errors.New("network error"),
			expected: true,
		},
		{
			name: "avi error 400 should not be retryable",
			err: session.AviError{
				HttpStatusCode: 400,
			},
			expected: false,
		},
		{
			name: "avi error 401 should not be retryable",
			err: session.AviError{
				HttpStatusCode: 401,
			},
			expected: false,
		},
		{
			name: "avi error 403 should not be retryable",
			err: session.AviError{
				HttpStatusCode: 403,
			},
			expected: false,
		},
		{
			name: "avi error 404 should not be retryable",
			err: session.AviError{
				HttpStatusCode: 404,
			},
			expected: false,
		},
		{
			name: "avi error 409 should not be retryable",
			err: session.AviError{
				HttpStatusCode: 409,
			},
			expected: false,
		},
		{
			name: "avi error 412 should not be retryable",
			err: session.AviError{
				HttpStatusCode: 412,
			},
			expected: false,
		},
		{
			name: "avi error 422 should not be retryable",
			err: session.AviError{
				HttpStatusCode: 422,
			},
			expected: false,
		},
		{
			name: "avi error 501 should not be retryable",
			err: session.AviError{
				HttpStatusCode: 501,
			},
			expected: false,
		},
		{
			name: "avi error 500 should be retryable",
			err: session.AviError{
				HttpStatusCode: 500,
			},
			expected: true,
		},
		{
			name: "avi error 502 should be retryable",
			err: session.AviError{
				HttpStatusCode: 502,
			},
			expected: true,
		},
		{
			name: "avi error 503 should be retryable",
			err: session.AviError{
				HttpStatusCode: 503,
			},
			expected: true,
		},
		{
			name: "avi error 504 should be retryable",
			err: session.AviError{
				HttpStatusCode: 504,
			},
			expected: true,
		},
		{
			name: "avi error with unknown status code should be retryable",
			err: session.AviError{
				HttpStatusCode: 999,
			},
			expected: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := IsRetryableError(tt.err)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestUpdateStatusWithNonRetryableError(t *testing.T) {
	scheme := runtime.NewScheme()
	_ = akov1alpha1.AddToScheme(scheme)

	tests := []struct {
		name             string
		err              error
		resourceType     string
		expectedReason   string
		expectedMsg      string
		generation       int64
		useHealthMonitor bool
	}{
		{
			name:             "generic error with HealthMonitor",
			err:              errors.New("generic error"),
			resourceType:     "HealthMonitor",
			expectedReason:   "ConfigurationError",
			expectedMsg:      "Non-retryable error: generic error",
			generation:       1,
			useHealthMonitor: true,
		},
		{
			name: "avi error 400 with ApplicationProfile",
			err: session.AviError{
				HttpStatusCode: 400,
				AviResult: session.AviResult{
					Message: &[]string{"invalid request"}[0],
				},
			},
			resourceType:     "ApplicationProfile",
			expectedReason:   "BadRequest",
			expectedMsg:      "Invalid ApplicationProfile specification: error from Controller: invalid request",
			generation:       2,
			useHealthMonitor: false,
		},
		{
			name: "avi error 401 with HealthMonitor",
			err: session.AviError{
				HttpStatusCode: 401,
			},
			resourceType:     "HealthMonitor",
			expectedReason:   "Unauthorized",
			expectedMsg:      "Authentication failed with Avi Controller",
			generation:       3,
			useHealthMonitor: true,
		},
		{
			name: "avi error 403 with ApplicationProfile",
			err: session.AviError{
				HttpStatusCode: 403,
			},
			resourceType:     "ApplicationProfile",
			expectedReason:   "Forbidden",
			expectedMsg:      "Insufficient permissions to create/update ApplicationProfile on Avi Controller",
			generation:       4,
			useHealthMonitor: false,
		},
		{
			name: "avi error 409 with HealthMonitor",
			err: session.AviError{
				HttpStatusCode: 409,
				AviResult: session.AviResult{
					Message: &[]string{"resource conflict"}[0],
				},
			},
			resourceType:     "HealthMonitor",
			expectedReason:   "Conflict",
			expectedMsg:      "Resource conflict on Avi Controller: error from Controller: resource conflict",
			generation:       5,
			useHealthMonitor: true,
		},
		{
			name: "avi error 422 with ApplicationProfile",
			err: session.AviError{
				HttpStatusCode: 422,
				AviResult: session.AviResult{
					Message: &[]string{"validation failed"}[0],
				},
			},
			resourceType:     "ApplicationProfile",
			expectedReason:   "ValidationError",
			expectedMsg:      "ApplicationProfile validation failed on Avi Controller: error from Controller: validation failed",
			generation:       6,
			useHealthMonitor: false,
		},
		{
			name: "avi error 501 with HealthMonitor",
			err: session.AviError{
				HttpStatusCode: 501,
			},
			resourceType:     "HealthMonitor",
			expectedReason:   "NotImplemented",
			expectedMsg:      "HealthMonitor feature not supported by Avi Controller version",
			generation:       7,
			useHealthMonitor: true,
		},
		{
			name: "avi error without message with ApplicationProfile",
			err: session.AviError{
				HttpStatusCode: 400,
			},
			resourceType:     "ApplicationProfile",
			expectedReason:   "BadRequest",
			expectedMsg:      "Invalid ApplicationProfile specification: Encountered an error on  request to URL : HTTP code: 400.",
			generation:       8,
			useHealthMonitor: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var resource ResourceWithStatus

			if tt.useHealthMonitor {
				hm := &akov1alpha1.HealthMonitor{
					ObjectMeta: metav1.ObjectMeta{
						Name:       "test-healthmonitor",
						Namespace:  "default",
						Generation: tt.generation,
					},
					Spec: akov1alpha1.HealthMonitorSpec{
						Type: akov1alpha1.HealthMonitorTCP,
					},
				}
				resource = hm
			} else {
				ap := &akov1alpha1.ApplicationProfile{
					ObjectMeta: metav1.ObjectMeta{
						Name:       "test-applicationprofile",
						Namespace:  "default",
						Generation: tt.generation,
					},
					Spec: akov1alpha1.ApplicationProfileSpec{
						Type: akov1alpha1.APPLICATION_PROFILE_TYPE_HTTP,
					},
				}
				resource = ap
			}

			fakeClient := fake.NewClientBuilder().
				WithScheme(scheme).
				WithObjects(resource).
				WithStatusSubresource(resource).
				Build()

			// Create context
			ctx := context.Background()

			UpdateStatusWithNonRetryableError(ctx, fakeClient, resource, tt.err, tt.resourceType)

			// Verify conditions
			conditions := resource.GetConditions()
			assert.Len(t, conditions, 1)

			condition := conditions[0]
			assert.Equal(t, "Ready", condition.Type)
			assert.Equal(t, metav1.ConditionFalse, condition.Status)
			assert.Equal(t, tt.expectedReason, condition.Reason)
			assert.Equal(t, tt.expectedMsg, condition.Message)
			assert.NotNil(t, condition.LastTransitionTime)

			// Verify observed generation and last updated - ApplicationProfile and HealthMonitor implement this
			if tt.useHealthMonitor {
				hm := resource.(*akov1alpha1.HealthMonitor)
				assert.Equal(t, tt.generation, hm.Status.ObservedGeneration)
				assert.NotNil(t, hm.Status.LastUpdated)
			} else {
				ap := resource.(*akov1alpha1.ApplicationProfile)
				assert.Equal(t, tt.generation, ap.Status.ObservedGeneration)
				assert.NotNil(t, ap.Status.LastUpdated)
			}
		})
	}
}

func TestExtractAviControllerErrorMessage(t *testing.T) {
	tests := []struct {
		name     string
		aviError session.AviError
		expected string
	}{
		{
			name: "error with message",
			aviError: session.AviError{
				AviResult: session.AviResult{
					Message: &[]string{"custom error message"}[0],
				},
			},
			expected: "error from Controller: custom error message",
		},
		{
			name: "error without message",
			aviError: session.AviError{
				HttpStatusCode: 400,
			},
			expected: "Encountered an error on  request to URL : HTTP code: 400.",
		},
		{
			name: "error with empty message",
			aviError: session.AviError{
				AviResult: session.AviResult{
					Message: &[]string{""}[0],
				},
				HttpStatusCode: 500,
			},
			expected: "Encountered an error on  request to URL : HTTP code: 500; error from Controller: ",
		},
		{
			name: "error with nil message",
			aviError: session.AviError{
				AviResult: session.AviResult{
					Message: nil,
				},
				HttpStatusCode: 404,
			},
			expected: "Encountered an error on  request to URL : HTTP code: 404.",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := extractAviControllerErrorMessage(tt.aviError)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestSetCondition(t *testing.T) {
	now := metav1.Time{Time: time.Now()}

	tests := []struct {
		name           string
		conditions     []metav1.Condition
		newCondition   metav1.Condition
		expectedLength int
		expectedType   string
		expectedStatus metav1.ConditionStatus
	}{
		{
			name:       "add new condition to empty slice",
			conditions: []metav1.Condition{},
			newCondition: metav1.Condition{
				Type:               "Ready",
				Status:             metav1.ConditionTrue,
				LastTransitionTime: now,
				Reason:             "Success",
				Message:            "All good",
			},
			expectedLength: 1,
			expectedType:   "Ready",
			expectedStatus: metav1.ConditionTrue,
		},
		{
			name: "add new condition to existing slice",
			conditions: []metav1.Condition{
				{
					Type:               "Available",
					Status:             metav1.ConditionTrue,
					LastTransitionTime: now,
					Reason:             "Available",
					Message:            "Resource is available",
				},
			},
			newCondition: metav1.Condition{
				Type:               "Ready",
				Status:             metav1.ConditionTrue,
				LastTransitionTime: now,
				Reason:             "Success",
				Message:            "All good",
			},
			expectedLength: 2,
			expectedType:   "Ready",
			expectedStatus: metav1.ConditionTrue,
		},
		{
			name: "update existing condition",
			conditions: []metav1.Condition{
				{
					Type:               "Ready",
					Status:             metav1.ConditionFalse,
					LastTransitionTime: now,
					Reason:             "Error",
					Message:            "Something wrong",
				},
			},
			newCondition: metav1.Condition{
				Type:               "Ready",
				Status:             metav1.ConditionTrue,
				LastTransitionTime: now,
				Reason:             "Success",
				Message:            "All good",
			},
			expectedLength: 1,
			expectedType:   "Ready",
			expectedStatus: metav1.ConditionTrue,
		},
		{
			name: "update condition in middle of slice",
			conditions: []metav1.Condition{
				{
					Type:               "Available",
					Status:             metav1.ConditionTrue,
					LastTransitionTime: now,
					Reason:             "Available",
					Message:            "Resource is available",
				},
				{
					Type:               "Ready",
					Status:             metav1.ConditionFalse,
					LastTransitionTime: now,
					Reason:             "Error",
					Message:            "Something wrong",
				},
				{
					Type:               "Progressing",
					Status:             metav1.ConditionTrue,
					LastTransitionTime: now,
					Reason:             "InProgress",
					Message:            "Work in progress",
				},
			},
			newCondition: metav1.Condition{
				Type:               "Ready",
				Status:             metav1.ConditionTrue,
				LastTransitionTime: now,
				Reason:             "Success",
				Message:            "All good",
			},
			expectedLength: 3,
			expectedType:   "Ready",
			expectedStatus: metav1.ConditionTrue,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := SetCondition(tt.conditions, tt.newCondition)

			assert.Len(t, result, tt.expectedLength)

			// Find the condition we added/updated
			var foundCondition *metav1.Condition
			for i := range result {
				if result[i].Type == tt.expectedType {
					foundCondition = &result[i]
					break
				}
			}

			assert.NotNil(t, foundCondition, "Expected condition not found")
			if foundCondition != nil {
				assert.Equal(t, tt.expectedStatus, foundCondition.Status)
				assert.Equal(t, tt.newCondition.Reason, foundCondition.Reason)
				assert.Equal(t, tt.newCondition.Message, foundCondition.Message)
			}
		})
	}
}

func TestCreateMarkers(t *testing.T) {
	tests := []struct {
		name           string
		clusterName    string
		namespace      string
		expectedLength int
		expectedKeys   []string
		expectedValues [][]string
	}{
		{
			name:           "both cluster name and namespace provided",
			clusterName:    "test-cluster",
			namespace:      "test-namespace",
			expectedLength: 2,
			expectedKeys:   []string{"clustername", "namespace"},
			expectedValues: [][]string{{"test-cluster"}, {"test-namespace"}},
		},
		{
			name:           "only cluster name provided",
			clusterName:    "test-cluster",
			namespace:      "",
			expectedLength: 1,
			expectedKeys:   []string{"clustername"},
			expectedValues: [][]string{{"test-cluster"}},
		},
		{
			name:           "only namespace provided",
			clusterName:    "",
			namespace:      "test-namespace",
			expectedLength: 1,
			expectedKeys:   []string{"namespace"},
			expectedValues: [][]string{{"test-namespace"}},
		},
		{
			name:           "neither cluster name nor namespace provided",
			clusterName:    "",
			namespace:      "",
			expectedLength: 0,
			expectedKeys:   []string{},
			expectedValues: [][]string{},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := CreateMarkers(tt.clusterName, tt.namespace)

			assert.Len(t, result, tt.expectedLength)

			// Verify each marker
			for i, marker := range result {
				assert.NotNil(t, marker.Key, "Marker key should not be nil")
				if marker.Key != nil {
					assert.Equal(t, tt.expectedKeys[i], *marker.Key)
				}
				assert.Equal(t, tt.expectedValues[i], marker.Values)
			}
		})
	}
}

func TestResourceWithStatusInterface(t *testing.T) {
	// Test that HealthMonitor implements ResourceWithStatus interface
	hm := &akov1alpha1.HealthMonitor{
		ObjectMeta: metav1.ObjectMeta{
			Generation: 123,
		},
	}

	// Test that our HealthMonitor implements the interface
	var _ ResourceWithStatus = hm

	// Test all interface methods on HealthMonitor
	assert.Equal(t, int64(123), hm.GetGeneration())

	conditions := []metav1.Condition{
		{
			Type:   "Ready",
			Status: metav1.ConditionTrue,
		},
	}
	hm.SetConditions(conditions)
	assert.Equal(t, conditions, hm.GetConditions())

	hm.SetObservedGeneration(456)
	assert.Equal(t, int64(456), hm.Status.ObservedGeneration)

	now := &metav1.Time{Time: time.Now()}
	hm.SetLastUpdated(now)
	assert.Equal(t, now, hm.Status.LastUpdated)

	// Test that ApplicationProfile implements ResourceWithStatus interface
	ap := &akov1alpha1.ApplicationProfile{
		ObjectMeta: metav1.ObjectMeta{
			Generation: 789,
		},
	}

	// Test that our ApplicationProfile implements the interface
	var _ ResourceWithStatus = ap

	// Test all interface methods on ApplicationProfile
	assert.Equal(t, int64(789), ap.GetGeneration())

	ap.SetConditions(conditions)
	assert.Equal(t, conditions, ap.GetConditions())

	ap.SetObservedGeneration(101112)
	assert.Equal(t, int64(101112), ap.Status.ObservedGeneration)

	ap.SetLastUpdated(now)
	assert.Equal(t, now, ap.Status.LastUpdated)
}

func TestParseAviErrorMessage(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "error message with array and obj_name",
			input:    `map[error:Cannot delete, object is referred by: [''IcapProfile custom-icap-profile'',    ''Pool custom-icap-pool1'', ''PoolGroup custom-icap-pg''] obj_name:my-cluster2-default-example-ping-healthmonitor]`,
			expected: "Cannot delete, object is referred by: [''IcapProfile custom-icap-profile'',    ''Pool custom-icap-pool1'', ''PoolGroup custom-icap-pg'']",
		},
		{
			name:     "simple error message with obj_name",
			input:    `map[error:Resource not found obj_name:test-resource]`,
			expected: "Resource not found",
		},
		{
			name:     "error message without obj_name",
			input:    `map[error:Invalid configuration]`,
			expected: "Invalid configuration",
		},
		{
			name:     "non-map format returns original",
			input:    `This is just a regular error message`,
			expected: "This is just a regular error message",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := ParseAviErrorMessage(tt.input)
			assert.Equal(t, tt.expected, result)
		})
	}
}
