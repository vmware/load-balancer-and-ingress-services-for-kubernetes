/*
 * Copyright Â© 2025 Broadcom Inc. and/or its subsidiaries. All Rights Reserved.
 * All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*   http://www.apache.org/licenses/LICENSE-2.0
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

// @AI-Generated
// This test file was generated by Claude AI assistant.

package ingestion

import (
	"context"
	"fmt"
	"testing"

	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-infra/webhook"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/lib"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/utils"

	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/dynamic/fake"
	k8sfake "k8s.io/client-go/kubernetes/fake"
)

func TestNewVKSClusterWatcher(t *testing.T) {
	kubeClient := k8sfake.NewSimpleClientset()
	dynamicClient := fake.NewSimpleDynamicClient(runtime.NewScheme())

	watcher := NewVKSClusterWatcher(kubeClient, dynamicClient)

	if watcher == nil {
		t.Fatal("Expected VKSClusterWatcher to be created, got nil")
	}

	if watcher.kubeClient != kubeClient {
		t.Error("Expected kubeClient to be set correctly")
	}

	if watcher.dynamicClient != dynamicClient {
		t.Error("Expected dynamicClient to be set correctly")
	}

	if watcher.workqueue == nil {
		t.Error("Expected workqueue to be initialized")
	}
}

func TestVKSClusterWatcher_GetClusterPhase(t *testing.T) {
	tests := []struct {
		name          string
		cluster       *unstructured.Unstructured
		expectedPhase string
	}{
		{
			name: "Provisioned cluster",
			cluster: &unstructured.Unstructured{
				Object: map[string]interface{}{
					"status": map[string]interface{}{
						"phase": "Provisioned",
					},
				},
			},
			expectedPhase: "Provisioned",
		},
		{
			name: "Deleting cluster",
			cluster: &unstructured.Unstructured{
				Object: map[string]interface{}{
					"status": map[string]interface{}{
						"phase": "Deleting",
					},
				},
			},
			expectedPhase: "Deleting",
		},
		{
			name: "No status",
			cluster: &unstructured.Unstructured{
				Object: map[string]interface{}{},
			},
			expectedPhase: "",
		},
		{
			name: "No phase",
			cluster: &unstructured.Unstructured{
				Object: map[string]interface{}{
					"status": map[string]interface{}{},
				},
			},
			expectedPhase: "",
		},
	}

	kubeClient := k8sfake.NewSimpleClientset()
	dynamicClient := fake.NewSimpleDynamicClient(runtime.NewScheme())
	watcher := NewVKSClusterWatcher(kubeClient, dynamicClient)

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			phase := watcher.GetClusterPhase(tt.cluster)
			if phase != tt.expectedPhase {
				t.Errorf("Expected phase %s, got %s", tt.expectedPhase, phase)
			}
		})
	}
}

func TestVKSClusterWatcher_GenerateClusterSecret(t *testing.T) {
	// Set up mock controller IP
	lib.SetControllerIP("10.10.10.10")

	tests := []struct {
		name             string
		clusterName      string
		clusterNamespace string
		expectError      bool
		validateSecret   bool
	}{
		{
			name:             "Valid cluster",
			clusterName:      "test-cluster",
			clusterNamespace: "test-namespace",
			expectError:      false,
			validateSecret:   true,
		},
		{
			name:             "Another valid cluster",
			clusterName:      "another-cluster",
			clusterNamespace: "another-namespace",
			expectError:      false,
			validateSecret:   true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			kubeClient := k8sfake.NewSimpleClientset()
			dynamicClient := fake.NewSimpleDynamicClient(runtime.NewScheme())

			// Create admin avi-secret with realistic credentials
			adminSecret := createTestAdminSecret()
			_, err := kubeClient.CoreV1().Secrets(adminSecret.Namespace).Create(context.Background(), adminSecret, metav1.CreateOptions{})
			if err != nil {
				t.Fatalf("Failed to create admin secret for test: %v", err)
			}

			watcher := NewVKSClusterWatcher(kubeClient, dynamicClient)

			cluster := &unstructured.Unstructured{
				Object: map[string]interface{}{
					"metadata": map[string]interface{}{
						"name":      tt.clusterName,
						"namespace": tt.clusterNamespace,
					},
				},
			}

			ctx := context.Background()
			err = watcher.GenerateClusterSecret(ctx, cluster)

			if tt.expectError && err == nil {
				t.Error("Expected error but got none")
			}

			if !tt.expectError && err != nil {
				t.Errorf("Expected no error but got: %v", err)
			}

			if tt.validateSecret {
				// Verify secret was created
				secretName := fmt.Sprintf("%s-avi-secret", tt.clusterName)
				secret, err := kubeClient.CoreV1().Secrets(tt.clusterNamespace).Get(ctx, secretName, metav1.GetOptions{})
				if err != nil {
					t.Fatalf("Expected secret to be created, but got error: %v", err)
				}

				// Validate secret contents
				if secret.Name != secretName {
					t.Errorf("Expected secret name %s, got %s", secretName, secret.Name)
				}

				if secret.Namespace != tt.clusterNamespace {
					t.Errorf("Expected secret namespace %s, got %s", tt.clusterNamespace, secret.Namespace)
				}

				// Check labels
				expectedLabels := map[string]string{
					"ako.kubernetes.vmware.com/cluster":    tt.clusterName,
					"ako.kubernetes.vmware.com/managed-by": "ako-infra",
				}

				for key, expectedValue := range expectedLabels {
					if actualValue, exists := secret.Labels[key]; !exists || actualValue != expectedValue {
						t.Errorf("Expected label %s=%s, got %s=%s", key, expectedValue, key, actualValue)
					}
				}

				// Check secret data (now using admin credentials)
				expectedFields := []string{"username", "controllerIP", "authtoken"}
				for _, field := range expectedFields {
					if _, exists := secret.Data[field]; !exists {
						t.Errorf("Expected secret to contain field %s", field)
					}
				}

				// Verify we're using admin credentials
				if string(secret.Data["username"]) != "admin" {
					t.Errorf("Expected username to be 'admin', got '%s'", string(secret.Data["username"]))
				}
			}
		})
	}
}

func TestVKSClusterWatcher_cleanupClusterSecret(t *testing.T) {
	tests := []struct {
		name             string
		clusterName      string
		clusterNamespace string
		secretExists     bool
		expectError      bool
	}{
		{
			name:             "Delete existing secret",
			clusterName:      "test-cluster",
			clusterNamespace: "test-namespace",
			secretExists:     true,
			expectError:      false,
		},
		{
			name:             "Delete non-existing secret",
			clusterName:      "missing-cluster",
			clusterNamespace: "test-namespace",
			secretExists:     false,
			expectError:      false, // Should not error on missing secret
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			kubeClient := k8sfake.NewSimpleClientset()

			// Create secret if it should exist
			if tt.secretExists {
				secretName := fmt.Sprintf("%s-avi-secret", tt.clusterName)
				secret := &corev1.Secret{
					ObjectMeta: metav1.ObjectMeta{
						Name:      secretName,
						Namespace: tt.clusterNamespace,
					},
				}
				_, err := kubeClient.CoreV1().Secrets(tt.clusterNamespace).Create(context.Background(), secret, metav1.CreateOptions{})
				if err != nil {
					t.Fatalf("Failed to create test secret: %v", err)
				}
			}

			dynamicClient := fake.NewSimpleDynamicClient(runtime.NewScheme())
			watcher := NewVKSClusterWatcher(kubeClient, dynamicClient)

			ctx := context.Background()
			err := watcher.cleanupClusterSecret(ctx, tt.clusterName, tt.clusterNamespace)

			if tt.expectError && err == nil {
				t.Error("Expected error but got none")
			}

			if !tt.expectError && err != nil {
				t.Errorf("Expected no error but got: %v", err)
			}

			// Verify secret was deleted if it existed
			if tt.secretExists {
				secretName := fmt.Sprintf("%s-avi-secret", tt.clusterName)
				_, err := kubeClient.CoreV1().Secrets(tt.clusterNamespace).Get(ctx, secretName, metav1.GetOptions{})
				if err == nil {
					t.Error("Expected secret to be deleted but it still exists")
				}
			}
		})
	}
}

func TestVKSClusterWatcher_HandleProvisionedCluster(t *testing.T) {
	// Set up mock controller IP
	lib.SetControllerIP("10.10.10.10")

	tests := []struct {
		name             string
		clusterName      string
		clusterNamespace string
		vksLabel         string
		secretExists     bool
		expectedAction   string // "create", "delete", "none"
		expectError      bool
	}{
		{
			name:             "Should manage cluster with no secret - create secret",
			clusterName:      "test-cluster",
			clusterNamespace: "test-namespace",
			vksLabel:         webhook.VKSManagedLabelValueTrue,
			secretExists:     false,
			expectedAction:   "create",
			expectError:      false,
		},
		{
			name:             "Should not manage cluster with secret - delete secret",
			clusterName:      "test-cluster",
			clusterNamespace: "test-namespace",
			vksLabel:         webhook.VKSManagedLabelValueFalse,
			secretExists:     true,
			expectedAction:   "delete",
			expectError:      false,
		},
		{
			name:             "Should manage cluster with secret - no action",
			clusterName:      "test-cluster",
			clusterNamespace: "test-namespace",
			vksLabel:         webhook.VKSManagedLabelValueTrue,
			secretExists:     true,
			expectedAction:   "none",
			expectError:      false,
		},
		{
			name:             "Should not manage cluster with no secret - no action",
			clusterName:      "test-cluster",
			clusterNamespace: "test-namespace",
			vksLabel:         webhook.VKSManagedLabelValueFalse,
			secretExists:     false,
			expectedAction:   "none",
			expectError:      false,
		},
		{
			name:             "No VKS label with secret - delete secret",
			clusterName:      "test-cluster",
			clusterNamespace: "test-namespace",
			vksLabel:         "",
			secretExists:     true,
			expectedAction:   "delete",
			expectError:      false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			kubeClient := k8sfake.NewSimpleClientset()

			// Create admin avi-secret for credential retrieval
			adminSecret := createTestAdminSecret()
			_, err := kubeClient.CoreV1().Secrets(adminSecret.Namespace).Create(context.Background(), adminSecret, metav1.CreateOptions{})
			if err != nil {
				t.Fatalf("Failed to create admin secret for test: %v", err)
			}

			// Create secret if it should exist
			secretName := fmt.Sprintf("%s-avi-secret", tt.clusterName)
			if tt.secretExists {
				secret := &corev1.Secret{
					ObjectMeta: metav1.ObjectMeta{
						Name:      secretName,
						Namespace: tt.clusterNamespace,
					},
				}
				_, err := kubeClient.CoreV1().Secrets(tt.clusterNamespace).Create(context.Background(), secret, metav1.CreateOptions{})
				if err != nil {
					t.Fatalf("Failed to create test secret: %v", err)
				}
			}

			dynamicClient := fake.NewSimpleDynamicClient(runtime.NewScheme())
			watcher := NewVKSClusterWatcher(kubeClient, dynamicClient)

			// Create cluster with appropriate label
			cluster := &unstructured.Unstructured{
				Object: map[string]interface{}{
					"metadata": map[string]interface{}{
						"name":      tt.clusterName,
						"namespace": tt.clusterNamespace,
					},
				},
			}

			if tt.vksLabel != "" {
				cluster.SetLabels(map[string]string{
					webhook.VKSManagedLabel: tt.vksLabel,
				})
			}

			err = watcher.HandleProvisionedCluster(cluster)

			if tt.expectError && err == nil {
				t.Error("Expected error but got none")
			}

			if !tt.expectError && err != nil {
				t.Errorf("Expected no error but got: %v", err)
			}

			// Verify expected action was taken
			ctx := context.Background()
			_, secretErr := kubeClient.CoreV1().Secrets(tt.clusterNamespace).Get(ctx, secretName, metav1.GetOptions{})
			secretExistsAfter := secretErr == nil

			switch tt.expectedAction {
			case "create":
				if !secretExistsAfter {
					t.Error("Expected secret to be created but it doesn't exist")
				}
			case "delete":
				if secretExistsAfter {
					t.Error("Expected secret to be deleted but it still exists")
				}
			case "none":
				if secretExistsAfter != tt.secretExists {
					t.Errorf("Expected secret existence to remain %v but it's %v", tt.secretExists, secretExistsAfter)
				}
			}
		})
	}
}

func TestVKSClusterWatcher_handleClusterDeletion(t *testing.T) {
	tests := []struct {
		name             string
		clusterName      string
		clusterNamespace string
		secretExists     bool
		expectError      bool
	}{
		{
			name:             "Delete cluster with secret",
			clusterName:      "test-cluster",
			clusterNamespace: "test-namespace",
			secretExists:     true,
			expectError:      false,
		},
		{
			name:             "Delete cluster without secret",
			clusterName:      "test-cluster",
			clusterNamespace: "test-namespace",
			secretExists:     false,
			expectError:      false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			kubeClient := k8sfake.NewSimpleClientset()

			// Create secret if it should exist
			if tt.secretExists {
				secretName := fmt.Sprintf("%s-avi-secret", tt.clusterName)
				secret := &corev1.Secret{
					ObjectMeta: metav1.ObjectMeta{
						Name:      secretName,
						Namespace: tt.clusterNamespace,
					},
				}
				_, err := kubeClient.CoreV1().Secrets(tt.clusterNamespace).Create(context.Background(), secret, metav1.CreateOptions{})
				if err != nil {
					t.Fatalf("Failed to create test secret: %v", err)
				}
			}

			dynamicClient := fake.NewSimpleDynamicClient(runtime.NewScheme())
			watcher := NewVKSClusterWatcher(kubeClient, dynamicClient)

			err := watcher.handleClusterDeletion(tt.clusterNamespace, tt.clusterName)

			if tt.expectError && err == nil {
				t.Error("Expected error but got none")
			}

			if !tt.expectError && err != nil {
				t.Errorf("Expected no error but got: %v", err)
			}

			// Verify secret was cleaned up if it existed
			if tt.secretExists {
				secretName := fmt.Sprintf("%s-avi-secret", tt.clusterName)
				_, err := kubeClient.CoreV1().Secrets(tt.clusterNamespace).Get(context.Background(), secretName, metav1.GetOptions{})
				if err == nil {
					t.Error("Expected secret to be deleted but it still exists")
				}
			}
		})
	}
}

func TestVKSClusterWatcher_ProcessClusterEvent(t *testing.T) {
	// Set up mock controller IP
	lib.SetControllerIP("10.10.10.10")

	tests := []struct {
		name          string
		key           string
		clusterExists bool
		clusterPhase  string
		vksLabel      string
		expectError   bool
	}{
		{
			name:          "Process provisioned cluster",
			key:           "test-namespace/test-cluster",
			clusterExists: true,
			clusterPhase:  ClusterPhaseProvisioned,
			vksLabel:      webhook.VKSManagedLabelValueTrue,
			expectError:   false,
		},
		{
			name:          "Process deleting cluster",
			key:           "test-namespace/test-cluster",
			clusterExists: true,
			clusterPhase:  ClusterPhaseDeleting,
			vksLabel:      webhook.VKSManagedLabelValueTrue,
			expectError:   false,
		},
		{
			name:          "Process non-existent cluster",
			key:           "test-namespace/missing-cluster",
			clusterExists: false,
			clusterPhase:  "",
			vksLabel:      "",
			expectError:   false, // Should handle deletion case
		},
		{
			name:          "Invalid key format",
			key:           "invalid-key",
			clusterExists: false,
			clusterPhase:  "",
			vksLabel:      "",
			expectError:   false, // Should handle gracefully
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			kubeClient := k8sfake.NewSimpleClientset()
			scheme := runtime.NewScheme()
			dynamicClient := fake.NewSimpleDynamicClient(scheme)

			// Create admin avi-secret for credential retrieval (if cluster creation is expected)
			if tt.clusterExists && tt.clusterPhase == ClusterPhaseProvisioned && tt.vksLabel == webhook.VKSManagedLabelValueTrue {
				adminSecret := createTestAdminSecret()
				_, err := kubeClient.CoreV1().Secrets(adminSecret.Namespace).Create(context.Background(), adminSecret, metav1.CreateOptions{})
				if err != nil {
					t.Fatalf("Failed to create admin secret for test: %v", err)
				}
			}

			// Create cluster if it should exist
			if tt.clusterExists {
				cluster := &unstructured.Unstructured{
					Object: map[string]interface{}{
						"apiVersion": "cluster.x-k8s.io/v1beta2",
						"kind":       "Cluster",
						"metadata": map[string]interface{}{
							"name":      "test-cluster",
							"namespace": "test-namespace",
						},
						"status": map[string]interface{}{
							"phase": tt.clusterPhase,
						},
					},
				}

				if tt.vksLabel != "" {
					cluster.SetLabels(map[string]string{
						webhook.VKSManagedLabel: tt.vksLabel,
					})
				}

				// Add cluster to fake client
				dynamicClient.Tracker().Add(cluster)
			}

			watcher := NewVKSClusterWatcher(kubeClient, dynamicClient)

			err := watcher.ProcessClusterEvent(tt.key)

			if tt.expectError && err == nil {
				t.Error("Expected error but got none")
			}

			if !tt.expectError && err != nil {
				t.Errorf("Expected no error but got: %v", err)
			}
		})
	}
}

func TestVKSClusterWatcher_WorkerIntegration(t *testing.T) {
	// Set up mock controller IP
	lib.SetControllerIP("10.10.10.10")

	kubeClient := k8sfake.NewSimpleClientset()
	scheme := runtime.NewScheme()
	dynamicClient := fake.NewSimpleDynamicClient(scheme)

	// Create admin avi-secret for credential retrieval
	adminSecret := createTestAdminSecret()
	_, err := kubeClient.CoreV1().Secrets(adminSecret.Namespace).Create(context.Background(), adminSecret, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create admin secret for test: %v", err)
	}

	watcher := NewVKSClusterWatcher(kubeClient, dynamicClient)

	// Create a test cluster
	cluster := &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "cluster.x-k8s.io/v1beta2",
			"kind":       "Cluster",
			"metadata": map[string]interface{}{
				"name":      "test-cluster",
				"namespace": "test-namespace",
				"labels": map[string]interface{}{
					webhook.VKSManagedLabel: webhook.VKSManagedLabelValueTrue,
				},
			},
			"status": map[string]interface{}{
				"phase": ClusterPhaseProvisioned,
			},
		},
	}

	// Add cluster to fake client
	dynamicClient.Tracker().Add(cluster)

	// Start the worker
	err = watcher.Start(make(<-chan struct{}))
	if err != nil {
		t.Fatalf("Failed to start watcher: %v", err)
	}

	// Enqueue a cluster event
	watcher.EnqueueCluster(cluster, "ADD")

	// Process one work item
	processed := watcher.ProcessNextWorkItem()
	if !processed {
		t.Error("Expected work item to be processed")
	}

	// Verify secret was created
	secretName := "test-cluster-avi-secret"
	secret, err := kubeClient.CoreV1().Secrets("test-namespace").Get(context.Background(), secretName, metav1.GetOptions{})
	if err != nil {
		t.Fatalf("Expected secret to be created, got error: %v", err)
	}

	if secret.Name != secretName {
		t.Errorf("Expected secret name %s, got %s", secretName, secret.Name)
	}

	// Stop the watcher
	watcher.Stop()
}

func TestVKSClusterWatcher_SecretIdempotency(t *testing.T) {
	// Set up mock controller IP
	lib.SetControllerIP("10.10.10.10")

	kubeClient := k8sfake.NewSimpleClientset()
	dynamicClient := fake.NewSimpleDynamicClient(runtime.NewScheme())

	// Create admin avi-secret for credential retrieval
	adminSecret := createTestAdminSecret()
	_, err := kubeClient.CoreV1().Secrets(adminSecret.Namespace).Create(context.Background(), adminSecret, metav1.CreateOptions{})
	if err != nil {
		t.Fatalf("Failed to create admin secret for test: %v", err)
	}

	watcher := NewVKSClusterWatcher(kubeClient, dynamicClient)

	cluster := &unstructured.Unstructured{
		Object: map[string]interface{}{
			"metadata": map[string]interface{}{
				"name":      "test-cluster",
				"namespace": "test-namespace",
				"labels": map[string]interface{}{
					webhook.VKSManagedLabel: webhook.VKSManagedLabelValueTrue,
				},
			},
		},
	}

	ctx := context.Background()

	// Create secret first time
	err = watcher.GenerateClusterSecret(ctx, cluster)
	if err != nil {
		t.Fatalf("First secret creation failed: %v", err)
	}

	// Get original secret
	secretName := "test-cluster-avi-secret"
	originalSecret, err := kubeClient.CoreV1().Secrets("test-namespace").Get(ctx, secretName, metav1.GetOptions{})
	if err != nil {
		t.Fatalf("Failed to get original secret: %v", err)
	}

	// Try to handle the same provisioned cluster again (should be idempotent)
	err = watcher.HandleProvisionedCluster(cluster)
	if err != nil {
		t.Fatalf("Second HandleProvisionedCluster failed: %v", err)
	}

	// Verify secret still exists and hasn't changed
	currentSecret, err := kubeClient.CoreV1().Secrets("test-namespace").Get(ctx, secretName, metav1.GetOptions{})
	if err != nil {
		t.Fatalf("Failed to get current secret: %v", err)
	}

	if originalSecret.ResourceVersion != currentSecret.ResourceVersion {
		t.Error("Expected secret to remain unchanged on second processing")
	}
}

// createTestAdminSecret creates a mock avi-secret for testing with realistic admin credentials
func createTestAdminSecret() *corev1.Secret {
	return &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      lib.AviSecret,           // "avi-secret"
			Namespace: utils.GetAKONamespace(), // "avi-system"
		},
		Type: corev1.SecretTypeOpaque,
		Data: map[string][]byte{
			"username":                 []byte("admin"),
			"password":                 []byte("admin123"),
			"authtoken":                []byte("test-auth-token-12345"),
			"certificateAuthorityData": []byte("-----BEGIN CERTIFICATE-----\nMIICertificateData...\n-----END CERTIFICATE-----"),
		},
	}
}
