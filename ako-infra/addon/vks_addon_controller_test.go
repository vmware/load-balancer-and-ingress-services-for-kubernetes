/*
 * Copyright Â© 2025 Broadcom Inc. and/or its subsidiaries. All Rights Reserved.
 * All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*   http://www.apache.org/licenses/LICENSE-2.0
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

// @AI-Generated
// This test file was generated by Claude AI assistant.

package addon

import (
	"testing"

	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-infra/webhook"

	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

func TestCreateAddonInstallSpec(t *testing.T) {
	addonSpec := createAddonInstallSpec()

	// Test basic structure
	if addonSpec == nil {
		t.Fatal("createAddonInstallSpec returned nil")
	}

	// Test apiVersion and kind
	if addonSpec.GetAPIVersion() != "addons.kubernetes.vmware.com/v1alpha1" {
		t.Errorf("Expected apiVersion 'addons.kubernetes.vmware.com/v1alpha1', got '%s'", addonSpec.GetAPIVersion())
	}

	if addonSpec.GetKind() != "AddonInstall" {
		t.Errorf("Expected kind 'AddonInstall', got '%s'", addonSpec.GetKind())
	}

	// Test metadata
	if addonSpec.GetName() != AKOAddonInstallName {
		t.Errorf("Expected name '%s', got '%s'", AKOAddonInstallName, addonSpec.GetName())
	}

	if addonSpec.GetNamespace() != VKSPublicNamespace {
		t.Errorf("Expected namespace '%s', got '%s'", VKSPublicNamespace, addonSpec.GetNamespace())
	}

	// Test labels
	labels := addonSpec.GetLabels()
	expectedLabels := map[string]string{
		"app.kubernetes.io/name":       "ako",
		"app.kubernetes.io/managed-by": "ako-infra",
	}

	for key, expectedValue := range expectedLabels {
		if labels[key] != expectedValue {
			t.Errorf("Expected label %s='%s', got '%s'", key, expectedValue, labels[key])
		}
	}

	// Test spec fields
	spec, found, err := unstructured.NestedMap(addonSpec.Object, "spec")
	if err != nil || !found {
		t.Fatalf("Failed to get spec: %v", err)
	}

	// Test addonRef field
	addonRef, found, err := unstructured.NestedMap(addonSpec.Object, "spec", "addonRef")
	if err != nil || !found {
		t.Fatalf("Failed to get addonRef: %v", err)
	}

	if addonRef["name"] != AKOAddonName {
		t.Errorf("Expected addonRef.name '%s', got '%v'", AKOAddonName, addonRef["name"])
	}

	if spec["crossNamespaceSelection"] != "Allowed" {
		t.Errorf("Expected crossNamespaceSelection 'Allowed', got '%v'", spec["crossNamespaceSelection"])
	}

	if spec["paused"] != false {
		t.Errorf("Expected paused 'false', got '%v'", spec["paused"])
	}

	// Test clusters configuration
	clusters, found, err := unstructured.NestedSlice(addonSpec.Object, "spec", "clusters")
	if err != nil || !found || len(clusters) != 1 {
		t.Fatalf("Expected 1 cluster configuration, got %d: %v", len(clusters), err)
	}

	cluster, ok := clusters[0].(map[string]interface{})
	if !ok {
		t.Fatal("Cluster configuration is not a map")
	}

	matchLabels, found, err := unstructured.NestedStringMap(cluster, "selector", "matchLabels")
	if err != nil || !found {
		t.Fatalf("Failed to get cluster selector matchLabels: %v", err)
	}

	expectedVKSLabel := webhook.VKSManagedLabelValueTrue
	if matchLabels[webhook.VKSManagedLabel] != expectedVKSLabel {
		t.Errorf("Expected VKS label '%s'='%s', got '%s'", webhook.VKSManagedLabel, expectedVKSLabel, matchLabels[webhook.VKSManagedLabel])
	}

	// Test releaseFilter configuration
	releaseFilter, found, err := unstructured.NestedMap(addonSpec.Object, "spec", "releaseFilter")
	if err != nil || !found {
		t.Fatalf("Failed to get releaseFilter configuration: %v", err)
	}

	// Note: resolutionRule is not needed - framework automatically selects latest compatible version

	releaseMatchLabels, found, err := unstructured.NestedStringMap(releaseFilter, "selector", "matchLabels")
	if err != nil || !found {
		t.Fatalf("Failed to get releaseFilter selector matchLabels: %v", err)
	}

	expectedAddonLabel := AKOAddonName
	if releaseMatchLabels["addon.kubernetes.vmware.com/addon-name"] != expectedAddonLabel {
		t.Errorf("Expected addon label '%s', got '%s'", expectedAddonLabel, releaseMatchLabels["addon.kubernetes.vmware.com/addon-name"])
	}
}

// Note: EnsureGlobalAddonInstall() tests are integration tests that require real Kubernetes API
// The core logic is tested via createAddonInstallSpec() which contains the business logic

func TestConstants(t *testing.T) {
	// Test that constants have expected values
	if VKSPublicNamespace != "vmware-system-vks-public" {
		t.Errorf("Expected VKSPublicNamespace 'vmware-system-vks-public', got '%s'", VKSPublicNamespace)
	}

	if AKOAddonName != "ako" {
		t.Errorf("Expected AKOAddonName 'ako', got '%s'", AKOAddonName)
	}

	if AKOAddonInstallName != "ako-global-installer" {
		t.Errorf("Expected AKOAddonInstallName 'ako-global-installer', got '%s'", AKOAddonInstallName)
	}

	// Test AddonInstallGVR
	expectedGVR := schema.GroupVersionResource{
		Group:    "addons.kubernetes.vmware.com",
		Version:  "v1alpha1",
		Resource: "addoninstalls",
	}

	if AddonInstallGVR != expectedGVR {
		t.Errorf("Expected AddonInstallGVR %+v, got %+v", expectedGVR, AddonInstallGVR)
	}
}
