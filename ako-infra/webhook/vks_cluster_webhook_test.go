/*
 * Copyright Â© 2025 Broadcom Inc. and/or its subsidiaries. All Rights Reserved.
 * All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*   http://www.apache.org/licenses/LICENSE-2.0
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

// @AI-Generated
// This test file was generated by Claude AI assistant.

package webhook

import (
	"bytes"
	"context"
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/json"
	"encoding/pem"
	"math/big"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	admissionv1 "k8s.io/api/admission/v1"
	admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	dynamicfake "k8s.io/client-go/dynamic/fake"
	k8sfake "k8s.io/client-go/kubernetes/fake"

	internalLib "github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/internal/lib"
)

// Test helper functions
func createTestCluster(name, namespace string, labels map[string]string) *unstructured.Unstructured {
	cluster := &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "cluster.x-k8s.io/v1beta2",
			"kind":       "Cluster",
			"metadata": map[string]interface{}{
				"name":      name,
				"namespace": namespace,
			},
		},
	}

	if labels != nil {
		cluster.SetLabels(labels)
	}

	return cluster
}

func createAdmissionRequest(cluster *unstructured.Unstructured) *admissionv1.AdmissionRequest {
	rawCluster, _ := json.Marshal(cluster)

	return &admissionv1.AdmissionRequest{
		UID: "test-uid",
		Kind: metav1.GroupVersionKind{
			Group:   "cluster.x-k8s.io",
			Version: "v1beta2",
			Kind:    "Cluster",
		},
		Name:      cluster.GetName(),
		Namespace: cluster.GetNamespace(),
		Operation: admissionv1.Create,
		Object: runtime.RawExtension{
			Raw: rawCluster,
		},
	}
}

func createNamespaceWithSEG(name, segValue string) *corev1.Namespace {
	return &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: name,
			Annotations: map[string]string{
				internalLib.WCPSEGroup: segValue,
			},
		},
	}
}

func createNamespaceWithoutSEG(name string) *corev1.Namespace {
	return &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: name,
		},
	}
}

// HTTP handler tests
func TestVKSClusterWebhook_ServeHTTP_InvalidJSON(t *testing.T) {
	webhook := NewVKSClusterWebhook(k8sfake.NewSimpleClientset())

	req := httptest.NewRequest("POST", "/mutate", bytes.NewBufferString("invalid json"))
	recorder := httptest.NewRecorder()

	webhook.ServeHTTP(recorder, req)

	if recorder.Code != http.StatusBadRequest {
		t.Errorf("Expected status %d, got %d", http.StatusBadRequest, recorder.Code)
	}
}

func TestVKSClusterWebhook_ServeHTTP_NilRequest(t *testing.T) {
	webhook := NewVKSClusterWebhook(k8sfake.NewSimpleClientset())

	admissionReview := &admissionv1.AdmissionReview{
		TypeMeta: metav1.TypeMeta{
			APIVersion: "admission.k8s.io/v1",
			Kind:       "AdmissionReview",
		},
		Request: nil,
	}

	requestBody, _ := json.Marshal(admissionReview)
	req := httptest.NewRequest("POST", "/mutate", bytes.NewBuffer(requestBody))
	recorder := httptest.NewRecorder()

	webhook.ServeHTTP(recorder, req)

	if recorder.Code != http.StatusBadRequest {
		t.Errorf("Expected status %d, got %d", http.StatusBadRequest, recorder.Code)
	}
}

func TestVKSClusterWebhook_ServeHTTP_ValidRequest(t *testing.T) {
	namespace := createNamespaceWithSEG("test-namespace", "test-seg")
	kubeClient := k8sfake.NewSimpleClientset(namespace)
	webhook := NewVKSClusterWebhook(kubeClient)

	cluster := createTestCluster("test-cluster", "test-namespace", nil)
	request := createAdmissionRequest(cluster)

	admissionReview := &admissionv1.AdmissionReview{
		TypeMeta: metav1.TypeMeta{
			APIVersion: "admission.k8s.io/v1",
			Kind:       "AdmissionReview",
		},
		Request: request,
	}

	requestBody, _ := json.Marshal(admissionReview)
	req := httptest.NewRequest("POST", "/mutate", bytes.NewBuffer(requestBody))
	recorder := httptest.NewRecorder()

	webhook.ServeHTTP(recorder, req)

	if recorder.Code != http.StatusOK {
		t.Errorf("Expected status %d, got %d", http.StatusOK, recorder.Code)
	}

	var response admissionv1.AdmissionReview
	if err := json.Unmarshal(recorder.Body.Bytes(), &response); err != nil {
		t.Errorf("Failed to unmarshal response: %v", err)
	}

	if response.Response == nil {
		t.Errorf("Expected response, got nil")
	}

	if !response.Response.Allowed {
		t.Errorf("Expected admission to be allowed, got denied")
	}

	// Validate patch content
	if response.Response.Patch == nil {
		t.Errorf("Expected patch to be created, got nil")
	}

	if response.Response.PatchType == nil || *response.Response.PatchType != admissionv1.PatchTypeJSONPatch {
		t.Errorf("Expected JSON patch type")
	}

	// Unmarshal and validate patch content
	var patches []map[string]interface{}
	if err := json.Unmarshal(response.Response.Patch, &patches); err != nil {
		t.Errorf("Failed to unmarshal patch: %v", err)
	}

	if len(patches) != 1 {
		t.Errorf("Expected 1 patch operation, got %d", len(patches))
	}

	patch := patches[0]
	if patch["op"] != "add" {
		t.Errorf("Expected 'add' operation, got %s", patch["op"])
	}

	if patch["path"] != "/metadata/labels" {
		t.Errorf("Expected path '/metadata/labels', got %s", patch["path"])
	}

	// Verify the value contains the VKS label
	value, ok := patch["value"].(map[string]interface{})
	if !ok {
		t.Errorf("Expected value to be map[string]interface{}")
	}

	vksLabelValue, exists := value[VKSManagedLabel]
	if !exists {
		t.Errorf("Expected VKS label '%s' to exist in patch value", VKSManagedLabel)
	}

	if vksLabelValue != VKSManagedLabelValueTrue {
		t.Errorf("Expected VKS label value '%s', got '%s'", VKSManagedLabelValueTrue, vksLabelValue)
	}
}

// Core admission request processing tests
func TestVKSClusterWebhook_ProcessAdmissionRequest_ValidCluster(t *testing.T) {
	namespace := createNamespaceWithSEG("test-namespace", "test-seg")
	kubeClient := k8sfake.NewSimpleClientset(namespace)
	webhook := NewVKSClusterWebhook(kubeClient)

	cluster := createTestCluster("test-cluster", "test-namespace", nil)
	request := createAdmissionRequest(cluster)

	response := webhook.ProcessAdmissionRequest(request)

	if !response.Allowed {
		t.Errorf("Expected admission to be allowed, got denied")
	}

	if response.Patch == nil {
		t.Errorf("Expected patch to be created, got nil")
	}

	if response.PatchType == nil || *response.PatchType != admissionv1.PatchTypeJSONPatch {
		t.Errorf("Expected JSON patch type")
	}

	// Validate actual patch content
	var patches []map[string]interface{}
	if err := json.Unmarshal(response.Patch, &patches); err != nil {
		t.Errorf("Failed to unmarshal patch: %v", err)
	}

	if len(patches) != 1 {
		t.Errorf("Expected 1 patch operation, got %d", len(patches))
	}

	patch := patches[0]
	if patch["op"] != "add" {
		t.Errorf("Expected 'add' operation, got %s", patch["op"])
	}

	if patch["path"] != "/metadata/labels" {
		t.Errorf("Expected path '/metadata/labels', got %s", patch["path"])
	}

	// Verify the value contains the VKS label
	value, ok := patch["value"].(map[string]interface{})
	if !ok {
		t.Errorf("Expected value to be map[string]interface{}")
	}

	vksLabelValue, exists := value[VKSManagedLabel]
	if !exists {
		t.Errorf("Expected VKS label '%s' to exist in patch value", VKSManagedLabel)
	}

	if vksLabelValue != VKSManagedLabelValueTrue {
		t.Errorf("Expected VKS label value '%s', got '%s'", VKSManagedLabelValueTrue, vksLabelValue)
	}
}

func TestVKSClusterWebhook_ProcessAdmissionRequest_ValidClusterWithExistingLabels(t *testing.T) {
	namespace := createNamespaceWithSEG("test-namespace", "test-seg")
	kubeClient := k8sfake.NewSimpleClientset(namespace)
	webhook := NewVKSClusterWebhook(kubeClient)

	// Create cluster with existing labels but no VKS label
	cluster := createTestCluster("test-cluster", "test-namespace", map[string]string{
		"existing-label": "existing-value",
		"another-label":  "another-value",
	})
	request := createAdmissionRequest(cluster)

	response := webhook.ProcessAdmissionRequest(request)

	if !response.Allowed {
		t.Errorf("Expected admission to be allowed, got denied")
	}

	if response.Patch == nil {
		t.Errorf("Expected patch to be created, got nil")
	}

	if response.PatchType == nil || *response.PatchType != admissionv1.PatchTypeJSONPatch {
		t.Errorf("Expected JSON patch type")
	}

	// Validate actual patch content
	var patches []map[string]interface{}
	if err := json.Unmarshal(response.Patch, &patches); err != nil {
		t.Errorf("Failed to unmarshal patch: %v", err)
	}

	if len(patches) != 1 {
		t.Errorf("Expected 1 patch operation, got %d", len(patches))
	}

	patch := patches[0]
	if patch["op"] != "add" {
		t.Errorf("Expected 'add' operation, got %s", patch["op"])
	}

	// Should be adding to specific label path, not replacing entire labels map
	expectedPath := "/metadata/labels/" + escapeJSONPointer(VKSManagedLabel)
	if patch["path"] != expectedPath {
		t.Errorf("Expected path '%s', got %s", expectedPath, patch["path"])
	}

	// Verify the value is just the label value, not a map
	if patch["value"] != VKSManagedLabelValueTrue {
		t.Errorf("Expected VKS label value '%s', got '%s'", VKSManagedLabelValueTrue, patch["value"])
	}
}

func TestVKSClusterWebhook_ProcessAdmissionRequest_OptedOutCluster(t *testing.T) {
	namespace := createNamespaceWithSEG("test-namespace", "test-seg")
	kubeClient := k8sfake.NewSimpleClientset(namespace)
	webhook := NewVKSClusterWebhook(kubeClient)

	cluster := createTestCluster("test-cluster", "test-namespace", map[string]string{
		VKSManagedLabel: VKSManagedLabelValueFalse,
	})
	request := createAdmissionRequest(cluster)

	response := webhook.ProcessAdmissionRequest(request)

	if !response.Allowed {
		t.Errorf("Expected admission to be allowed, got denied")
	}

	if response.Patch != nil {
		t.Errorf("Expected no patch for opted-out cluster, got patch")
	}
}

func TestVKSClusterWebhook_ProcessAdmissionRequest_NoSEGNamespace(t *testing.T) {
	namespace := createNamespaceWithoutSEG("test-namespace")
	kubeClient := k8sfake.NewSimpleClientset(namespace)
	webhook := NewVKSClusterWebhook(kubeClient)

	cluster := createTestCluster("test-cluster", "test-namespace", nil)
	request := createAdmissionRequest(cluster)

	response := webhook.ProcessAdmissionRequest(request)

	if !response.Allowed {
		t.Errorf("Expected admission to be allowed, got denied")
	}

	if response.Patch != nil {
		t.Errorf("Expected no patch for non-SEG namespace, got patch")
	}
}

func TestVKSClusterWebhook_ProcessAdmissionRequest_InvalidObject(t *testing.T) {
	webhook := NewVKSClusterWebhook(k8sfake.NewSimpleClientset())

	request := &admissionv1.AdmissionRequest{
		UID:       "test-uid",
		Operation: admissionv1.Create,
		Kind: metav1.GroupVersionKind{
			Group:   "cluster.x-k8s.io",
			Version: "v1beta2",
			Kind:    "Cluster",
		},
		Object: runtime.RawExtension{
			Raw: []byte("invalid json"),
		},
	}

	response := webhook.ProcessAdmissionRequest(request)

	if response.Allowed {
		t.Errorf("Expected admission to be denied for invalid object, got allowed")
	}
}

func TestVKSClusterWebhook_ProcessAdmissionRequest_NonClusterObject(t *testing.T) {
	webhook := NewVKSClusterWebhook(k8sfake.NewSimpleClientset())

	request := &admissionv1.AdmissionRequest{
		UID:       "test-uid",
		Operation: admissionv1.Create,
		Kind: metav1.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "Deployment",
		},
	}

	response := webhook.ProcessAdmissionRequest(request)

	if !response.Allowed {
		t.Errorf("Expected non-cluster objects to be allowed, got denied")
	}

	if response.Patch != nil {
		t.Errorf("Expected no patch for non-cluster objects, got patch")
	}
}

// Cluster management eligibility tests
func TestVKSClusterWebhook_ShouldManageCluster_WithSEG(t *testing.T) {
	namespace := createNamespaceWithSEG("test-namespace", "test-seg")
	kubeClient := k8sfake.NewSimpleClientset(namespace)
	webhook := NewVKSClusterWebhook(kubeClient)

	cluster := createTestCluster("test-cluster", "test-namespace", nil)

	shouldManage := webhook.shouldManageCluster(cluster)
	if !shouldManage {
		t.Errorf("Expected cluster to be managed when namespace has SEG, got false")
	}
}

func TestVKSClusterWebhook_ShouldManageCluster_WithoutSEG(t *testing.T) {
	namespace := createNamespaceWithoutSEG("test-namespace")
	kubeClient := k8sfake.NewSimpleClientset(namespace)
	webhook := NewVKSClusterWebhook(kubeClient)

	cluster := createTestCluster("test-cluster", "test-namespace", nil)

	shouldManage := webhook.shouldManageCluster(cluster)
	if shouldManage {
		t.Errorf("Expected cluster not to be managed when namespace has no SEG, got true")
	}
}

func TestVKSClusterWebhook_ShouldManageCluster_OptedOut(t *testing.T) {
	namespace := createNamespaceWithSEG("test-namespace", "test-seg")
	kubeClient := k8sfake.NewSimpleClientset(namespace)
	webhook := NewVKSClusterWebhook(kubeClient)

	cluster := createTestCluster("test-cluster", "test-namespace", map[string]string{
		VKSManagedLabel: VKSManagedLabelValueFalse,
	})

	shouldManage := webhook.shouldManageCluster(cluster)
	if shouldManage {
		t.Errorf("Expected cluster not to be managed when opted out, got true")
	}
}

func TestVKSClusterWebhook_ShouldManageCluster_AlreadyManaged(t *testing.T) {
	namespace := createNamespaceWithSEG("test-namespace", "test-seg")
	kubeClient := k8sfake.NewSimpleClientset(namespace)
	webhook := NewVKSClusterWebhook(kubeClient)

	cluster := createTestCluster("test-cluster", "test-namespace", map[string]string{
		VKSManagedLabel: VKSManagedLabelValueTrue,
	})

	shouldManage := webhook.shouldManageCluster(cluster)
	if !shouldManage {
		t.Errorf("Expected cluster to be managed when already has correct label, got false")
	}
}

// Namespace SEG checking tests
func TestVKSClusterWebhook_NamespaceHasSEG_WithSEG(t *testing.T) {
	namespace := createNamespaceWithSEG("test-namespace", "test-seg")
	kubeClient := k8sfake.NewSimpleClientset(namespace)
	webhook := NewVKSClusterWebhook(kubeClient)

	hasSEG, err := webhook.namespaceHasSEG("test-namespace")
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}

	if !hasSEG {
		t.Errorf("Expected namespace to have SEG, got false")
	}
}

func TestVKSClusterWebhook_NamespaceHasSEG_WithoutSEG(t *testing.T) {
	namespace := createNamespaceWithoutSEG("test-namespace")
	kubeClient := k8sfake.NewSimpleClientset(namespace)
	webhook := NewVKSClusterWebhook(kubeClient)

	hasSEG, err := webhook.namespaceHasSEG("test-namespace")
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}

	if hasSEG {
		t.Errorf("Expected namespace not to have SEG, got true")
	}
}

func TestVKSClusterWebhook_NamespaceHasSEG_NamespaceNotFound(t *testing.T) {
	kubeClient := k8sfake.NewSimpleClientset()
	webhook := NewVKSClusterWebhook(kubeClient)

	hasSEG, err := webhook.namespaceHasSEG("nonexistent-namespace")
	if err == nil {
		t.Errorf("Expected error for nonexistent namespace, got nil")
	}

	if hasSEG {
		t.Errorf("Expected false for nonexistent namespace, got true")
	}
}

// Label patch creation tests
func TestVKSClusterWebhook_CreateVKSLabelPatch_NoExistingLabels(t *testing.T) {
	webhook := NewVKSClusterWebhook(k8sfake.NewSimpleClientset())
	cluster := createTestCluster("test-cluster", "test-namespace", nil)

	patches, err := webhook.createVKSLabelPatch(cluster)
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}

	if len(patches) != 1 {
		t.Errorf("Expected 1 patch, got %d", len(patches))
	}

	patch := patches[0]
	if patch["op"] != "add" {
		t.Errorf("Expected 'add' operation, got %s", patch["op"])
	}
	if patch["path"] != "/metadata/labels" {
		t.Errorf("Expected path '/metadata/labels', got %s", patch["path"])
	}

	// Verify the value
	value, ok := patch["value"].(map[string]interface{})
	if !ok {
		t.Errorf("Expected value to be map[string]interface{}")
	}
	if value[VKSManagedLabel] != VKSManagedLabelValueTrue {
		t.Errorf("Expected label value '%s', got '%s'", VKSManagedLabelValueTrue, value[VKSManagedLabel])
	}
}

func TestVKSClusterWebhook_CreateVKSLabelPatch_ExistingLabelsCorrectValue(t *testing.T) {
	webhook := NewVKSClusterWebhook(k8sfake.NewSimpleClientset())
	cluster := createTestCluster("test-cluster", "test-namespace", map[string]string{
		VKSManagedLabel: VKSManagedLabelValueTrue,
	})

	patches, err := webhook.createVKSLabelPatch(cluster)
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}

	if len(patches) != 0 {
		t.Errorf("Expected 0 patches when label already has correct value, got %d", len(patches))
	}
}

func TestVKSClusterWebhook_CreateVKSLabelPatch_ExistingLabelsWrongValue(t *testing.T) {
	webhook := NewVKSClusterWebhook(k8sfake.NewSimpleClientset())
	cluster := createTestCluster("test-cluster", "test-namespace", map[string]string{
		VKSManagedLabel: "wrong-value",
	})

	patches, err := webhook.createVKSLabelPatch(cluster)
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}

	if len(patches) != 1 {
		t.Errorf("Expected 1 patch, got %d", len(patches))
	}

	patch := patches[0]
	if patch["op"] != "replace" {
		t.Errorf("Expected 'replace' operation, got %s", patch["op"])
	}

	expectedPath := "/metadata/labels/" + escapeJSONPointer(VKSManagedLabel)
	if patch["path"] != expectedPath {
		t.Errorf("Expected path '%s', got %s", expectedPath, patch["path"])
	}

	if patch["value"] != VKSManagedLabelValueTrue {
		t.Errorf("Expected value '%s', got %s", VKSManagedLabelValueTrue, patch["value"])
	}
}

func TestVKSClusterWebhook_CreateVKSLabelPatch_ExistingLabelsNewLabel(t *testing.T) {
	webhook := NewVKSClusterWebhook(k8sfake.NewSimpleClientset())
	cluster := createTestCluster("test-cluster", "test-namespace", map[string]string{
		"existing-label": "existing-value",
	})

	patches, err := webhook.createVKSLabelPatch(cluster)
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}

	if len(patches) != 1 {
		t.Errorf("Expected 1 patch, got %d", len(patches))
	}

	patch := patches[0]
	if patch["op"] != "add" {
		t.Errorf("Expected 'add' operation, got %s", patch["op"])
	}

	expectedPath := "/metadata/labels/" + escapeJSONPointer(VKSManagedLabel)
	if patch["path"] != expectedPath {
		t.Errorf("Expected path '%s', got %s", expectedPath, patch["path"])
	}

	if patch["value"] != VKSManagedLabelValueTrue {
		t.Errorf("Expected value '%s', got %s", VKSManagedLabelValueTrue, patch["value"])
	}
}

// JSON Pointer escaping tests
func TestEscapeJSONPointer(t *testing.T) {
	testCases := []struct {
		input    string
		expected string
	}{
		{"normal", "normal"},
		{"with~tilde", "with~0tilde"},
		{"with/slash", "with~1slash"},
		{"with~and/both", "with~0and~1both"},
		{"", ""},
		{"ako.kubernetes.vmware.com/install", "ako.kubernetes.vmware.com~1install"},
	}

	for _, tc := range testCases {
		result := escapeJSONPointer(tc.input)
		if result != tc.expected {
			t.Errorf("escapeJSONPointer(%q) = %q, expected %q", tc.input, result, tc.expected)
		}
	}
}

// Webhook configuration tests
func TestCreateWebhookConfiguration_DoesNotExist(t *testing.T) {
	kubeClient := k8sfake.NewSimpleClientset()

	err := CreateWebhookConfiguration(kubeClient)
	if err != nil {
		t.Errorf("Expected no error when creating webhook, got: %v", err)
	}

	// Verify it was created
	webhook, err := kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().Get(
		context.TODO(), "ako-vks-cluster-webhook", metav1.GetOptions{})

	if err != nil {
		t.Errorf("Expected webhook to be created, got error: %v", err)
	}

	if webhook.Name != "ako-vks-cluster-webhook" {
		t.Errorf("Expected webhook name 'ako-vks-cluster-webhook', got %s", webhook.Name)
	}

	// Verify webhook has correct structure
	if len(webhook.Webhooks) != 1 {
		t.Errorf("Expected 1 webhook, got %d", len(webhook.Webhooks))
	}

	wh := webhook.Webhooks[0]
	if wh.Name != "vks-cluster-labeling.ako.vmware.com" {
		t.Errorf("Expected webhook name 'vks-cluster-labeling.ako.vmware.com', got %s", wh.Name)
	}

	if len(wh.Rules) != 1 {
		t.Errorf("Expected 1 rule, got %d", len(wh.Rules))
	}

	rule := wh.Rules[0]
	if len(rule.Operations) != 1 || rule.Operations[0] != admissionregistrationv1.Create {
		t.Errorf("Expected Create operation, got %v", rule.Operations)
	}

	if len(rule.APIGroups) != 1 || rule.APIGroups[0] != "cluster.x-k8s.io" {
		t.Errorf("Expected cluster.x-k8s.io API group, got %v", rule.APIGroups)
	}

	// Verify cert-manager annotation is set
	expectedAnnotation := "cert-manager.io/inject-ca-from"
	if webhook.Annotations == nil || webhook.Annotations[expectedAnnotation] == "" {
		t.Errorf("Expected cert-manager annotation %s to be set", expectedAnnotation)
	}

	expectedValue := "/ako-vks-webhook-serving-cert"
	if webhook.Annotations[expectedAnnotation] != expectedValue {
		t.Errorf("Expected cert-manager annotation value %s, got %s", expectedValue, webhook.Annotations[expectedAnnotation])
	}
}

func TestCreateWebhookConfiguration_AlreadyExists(t *testing.T) {
	existingWebhook := &admissionregistrationv1.MutatingWebhookConfiguration{
		ObjectMeta: metav1.ObjectMeta{
			Name: "ako-vks-cluster-webhook",
		},
	}

	kubeClient := k8sfake.NewSimpleClientset(existingWebhook)

	err := CreateWebhookConfiguration(kubeClient)
	if err != nil {
		t.Errorf("Expected no error when webhook already exists, got: %v", err)
	}
}

// Webhook startup tests
func TestStartVKSWebhook_SyncOnce(t *testing.T) {
	kubeClient := k8sfake.NewSimpleClientset()
	stopCh := make(chan struct{})

	// Note: With the new implementation, StartVKSWebhook will fail early because
	// cert-manager is not available in the test environment. The sync.Once pattern
	// still works correctly - the setup function is only called once, but it fails
	// immediately due to missing cert-manager CRDs.

	// This test now verifies that sync.Once is used correctly by ensuring multiple
	// calls don't cause issues, even though they all fail for the same reason.

	// Close the stopCh immediately to trigger early exit
	close(stopCh)

	// Call the function multiple times (only first call will execute due to sync.Once)
	StartVKSWebhook(kubeClient, stopCh)
	StartVKSWebhook(kubeClient, stopCh)
	StartVKSWebhook(kubeClient, stopCh)

	// Give time for any goroutines to complete
	time.Sleep(100 * time.Millisecond)

	// Verify that no webhook configuration was created (expected behavior with no cert-manager)
	webhooks, err := kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().List(
		context.TODO(), metav1.ListOptions{})

	if err != nil {
		t.Errorf("Expected to list webhooks, got error: %v", err)
	}

	// Should have no webhooks since cert-manager is not available
	count := 0
	for _, wh := range webhooks.Items {
		if wh.Name == "ako-vks-cluster-webhook" {
			count++
		}
	}

	if count != 0 {
		t.Errorf("Expected 0 webhook configurations (cert-manager not available), got %d", count)
	}

	// The test passes if no panics occurred and sync.Once worked correctly
}

func TestStartVKSWebhook_EnvironmentDefaults(t *testing.T) {
	kubeClient := k8sfake.NewSimpleClientset()
	stopCh := make(chan struct{})

	// Clear environment variables to test defaults
	os.Unsetenv("VKS_WEBHOOK_PORT")
	os.Unsetenv("VKS_WEBHOOK_CERT_DIR")

	// Since sync.Once can only be used once per test run, this call will be ignored
	// if StartVKSWebhook was already called in previous tests.
	// This test verifies that the function doesn't crash with missing env vars.
	StartVKSWebhook(kubeClient, stopCh)

	// Give time for goroutines to start (if they do)
	time.Sleep(100 * time.Millisecond)

	// We can't reliably test webhook creation here due to sync.Once behavior,
	// but we can verify the function doesn't panic with missing environment variables.
	// The actual environment default testing is implicitly covered by the server startup logic.
}

// Certificate waiting functionality tests
func TestFilesExist(t *testing.T) {
	// Create a temporary directory for test certificates
	tempDir, err := os.MkdirTemp("", "webhook-cert-test")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	certPath := filepath.Join(tempDir, "tls.crt")
	keyPath := filepath.Join(tempDir, "tls.key")

	// Test case 1: Files don't exist
	t.Run("FilesDoNotExist", func(t *testing.T) {
		if filesExist(certPath, keyPath) {
			t.Error("Expected false when files don't exist")
		}
	})
}

func TestWaitForCertificates(t *testing.T) {
	// Create a temporary directory for test certificates
	tempDir, err := os.MkdirTemp("", "webhook-cert-wait-test")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	// Test case 1: Timeout when certificates don't exist
	t.Run("TimeoutWhenMissing", func(t *testing.T) {
		start := time.Now()
		err := waitForCertificates(tempDir, 1*time.Second)
		duration := time.Since(start)

		if err == nil {
			t.Error("Expected timeout error when certificates don't exist")
		}
		if duration < 1*time.Second {
			t.Error("Expected to wait for at least the timeout duration")
		}
	})

	// Test case 2: Success when certificates are created
	t.Run("SuccessWhenCertificatesExist", func(t *testing.T) {
		certPath := filepath.Join(tempDir, "tls.crt")
		keyPath := filepath.Join(tempDir, "tls.key")

		// Create certificates first
		err := createTestCertificatesForValidation(certPath, keyPath)
		if err != nil {
			t.Fatalf("Failed to create test certificates: %v", err)
		}

		start := time.Now()
		err = waitForCertificates(tempDir, 5*time.Second)
		duration := time.Since(start)

		if err != nil {
			t.Errorf("Expected success when certificates exist: %v", err)
		}
		if duration > 3*time.Second {
			t.Error("Expected to return quickly when certificates are ready")
		}
	})
}

// createTestCertificatesForValidation creates a valid certificate and key pair for testing
func createTestCertificatesForValidation(certPath, keyPath string) error {
	// Generate private key
	privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		return err
	}

	// Create certificate template
	template := x509.Certificate{
		SerialNumber: big.NewInt(1),
		Subject: pkix.Name{
			Organization: []string{"Test Org"},
		},
		NotBefore:             time.Now(),
		NotAfter:              time.Now().Add(time.Hour * 24 * 180),
		KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		BasicConstraintsValid: true,
	}

	// Create certificate
	certDER, err := x509.CreateCertificate(rand.Reader, &template, &template, &privateKey.PublicKey, privateKey)
	if err != nil {
		return err
	}

	// Write certificate file
	certOut, err := os.Create(certPath)
	if err != nil {
		return err
	}
	defer certOut.Close()
	pem.Encode(certOut, &pem.Block{Type: "CERTIFICATE", Bytes: certDER})

	// Write private key file
	keyOut, err := os.Create(keyPath)
	if err != nil {
		return err
	}
	defer keyOut.Close()
	privKeyDER, err := x509.MarshalPKCS8PrivateKey(privateKey)
	if err != nil {
		return err
	}
	pem.Encode(keyOut, &pem.Block{Type: "PRIVATE KEY", Bytes: privKeyDER})

	return nil
}

func TestCleanupWebhookConfiguration(t *testing.T) {
	kubeClient := k8sfake.NewSimpleClientset()

	// Test cleanup when webhook doesn't exist (should not error)
	t.Run("WebhookNotExists", func(t *testing.T) {
		err := CleanupWebhookConfiguration(kubeClient)
		if err != nil {
			t.Errorf("Expected no error when webhook doesn't exist, got: %v", err)
		}
	})

	// Test cleanup when webhook exists
	t.Run("WebhookExists", func(t *testing.T) {
		// First create a webhook configuration
		err := CreateWebhookConfiguration(kubeClient)
		if err != nil {
			t.Fatalf("Failed to create webhook configuration: %v", err)
		}

		// Verify it was created
		_, err = kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().Get(
			context.TODO(), "ako-vks-cluster-webhook", metav1.GetOptions{})
		if err != nil {
			t.Fatalf("Expected webhook to exist after creation, got error: %v", err)
		}

		// Now test cleanup
		err = CleanupWebhookConfiguration(kubeClient)
		if err != nil {
			t.Errorf("Expected no error during cleanup, got: %v", err)
		}

		// Verify it was deleted
		_, err = kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().Get(
			context.TODO(), "ako-vks-cluster-webhook", metav1.GetOptions{})
		if err == nil {
			t.Error("Expected webhook to be deleted, but it still exists")
		}
		if !errors.IsNotFound(err) {
			t.Errorf("Expected NotFound error, got: %v", err)
		}
	})
}

// TestWaitForWebhookCertificates tests the secret-based certificate waiting
func TestWaitForWebhookCertificates(t *testing.T) {
	// Set testing environment variable for shorter timeouts
	os.Setenv("TESTING", "true")
	defer os.Unsetenv("TESTING")

	namespace := "test-namespace"

	t.Run("SecretReady", func(t *testing.T) {
		// Create a secret with all required certificate data
		secret := &corev1.Secret{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "ako-vks-webhook-serving-cert",
				Namespace: namespace,
			},
			Data: map[string][]byte{
				"tls.crt": []byte("fake-cert-data"),
				"tls.key": []byte("fake-key-data"),
				"ca.crt":  []byte("fake-ca-data"),
			},
		}

		kubeClient := k8sfake.NewSimpleClientset(secret)

		err := waitForWebhookCertificates(kubeClient, namespace)
		if err != nil {
			t.Errorf("Expected no error when secret is ready, got: %v", err)
		}
	})

	t.Run("SecretNotFound", func(t *testing.T) {
		kubeClient := k8sfake.NewSimpleClientset()

		// Set short timeout for test
		oldTimeout := 5 * time.Minute
		defer func() {
			// Restore timeout (though this function doesn't take timeout as param)
			_ = oldTimeout
		}()

		// This should timeout quickly in real implementation
		// For test, we'll just verify it handles the not found case properly
		go func() {
			time.Sleep(100 * time.Millisecond)
			// Create secret with missing keys to test the incomplete secret case
			secret := &corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "ako-vks-webhook-serving-cert",
					Namespace: namespace,
				},
				Data: map[string][]byte{
					"tls.crt": []byte("fake-cert-data"),
					// Missing tls.key and ca.crt
				},
			}
			kubeClient.CoreV1().Secrets(namespace).Create(context.TODO(), secret, metav1.CreateOptions{})
		}()

		err := waitForWebhookCertificates(kubeClient, namespace)
		// Should timeout or find incomplete secret
		if err == nil {
			t.Error("Expected timeout error when secret is not ready")
		}
	})

	t.Run("IncompleteSecret", func(t *testing.T) {
		// Create a secret missing some required keys
		secret := &corev1.Secret{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "ako-vks-webhook-serving-cert",
				Namespace: namespace,
			},
			Data: map[string][]byte{
				"tls.crt": []byte("fake-cert-data"),
				// Missing tls.key and ca.crt
			},
		}

		kubeClient := k8sfake.NewSimpleClientset(secret)

		err := waitForWebhookCertificates(kubeClient, namespace)
		// Should timeout because secret is incomplete
		if err == nil {
			t.Error("Expected timeout error when secret is incomplete")
		}
	})
}

// TestCleanupCertManagerResources tests cert-manager resource cleanup
func TestCleanupCertManagerResources(t *testing.T) {
	kubeClient := k8sfake.NewSimpleClientset()

	t.Run("CertManagerNotAvailable", func(t *testing.T) {
		// When cert-manager CRDs are not available, cleanup should skip gracefully
		err := CleanupCertManagerResources(kubeClient)
		if err != nil {
			t.Errorf("Expected no error when cert-manager not available, got: %v", err)
		}
	})

	// Note: Testing with actual cert-manager resources would require setting up
	// dynamic client with cert-manager CRDs, which is complex for unit tests.
	// Integration tests would be better for full cert-manager resource testing.
}

// TestCleanupAllWebhookResources tests comprehensive cleanup
func TestCleanupAllWebhookResources(t *testing.T) {
	kubeClient := k8sfake.NewSimpleClientset()

	t.Run("CleanupAll", func(t *testing.T) {
		// First create a webhook configuration
		err := CreateWebhookConfiguration(kubeClient)
		if err != nil {
			t.Fatalf("Failed to create webhook configuration: %v", err)
		}

		// Verify it was created
		_, err = kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().Get(
			context.TODO(), "ako-vks-cluster-webhook", metav1.GetOptions{})
		if err != nil {
			t.Fatalf("Expected webhook to exist after creation, got error: %v", err)
		}

		// Test comprehensive cleanup
		err = CleanupAllWebhookResources(kubeClient)
		if err != nil {
			t.Errorf("Expected no error during comprehensive cleanup, got: %v", err)
		}

		// Verify webhook configuration was deleted
		_, err = kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().Get(
			context.TODO(), "ako-vks-cluster-webhook", metav1.GetOptions{})
		if err == nil {
			t.Error("Expected webhook to be deleted, but it still exists")
		}
		if !errors.IsNotFound(err) {
			t.Errorf("Expected NotFound error, got: %v", err)
		}
	})
}

// TestIsCertManagerAvailable tests cert-manager CRD detection
func TestIsCertManagerAvailable(t *testing.T) {
	t.Run("CertManagerNotAvailable", func(t *testing.T) {
		kubeClient := k8sfake.NewSimpleClientset()

		available := isCertManagerAvailable(kubeClient)
		if available {
			t.Error("Expected cert-manager to not be available with fake client")
		}
	})
}

// TestSetupAndStartWebhook tests the atomic setup function
func TestSetupAndStartWebhook(t *testing.T) {
	t.Run("CertManagerNotReady", func(t *testing.T) {
		kubeClient := k8sfake.NewSimpleClientset()
		stopCh := make(chan struct{})
		defer close(stopCh)

		// This should fail because cert-manager is not available
		err := setupAndStartWebhook(kubeClient, stopCh)
		if err == nil {
			t.Error("Expected error when cert-manager not available")
		}
		if err != nil && !strings.Contains(err.Error(), "cert-manager not ready") {
			t.Errorf("Expected cert-manager error, got: %v", err)
		}
	})
}

// TestCreateCertManagerResources tests the creation of cert-manager resources
func TestCreateCertManagerResources(t *testing.T) {
	namespace := "test-namespace"

	// Setup mock dynamic client with cert-manager CRDs
	scheme := runtime.NewScheme()

	// Create fake dynamic client
	dynamicClient := dynamicfake.NewSimpleDynamicClient(scheme)

	// Store original dynamic client and restore after test
	originalDynamicClient := internalLib.GetDynamicClientSet()
	internalLib.SetDynamicClientSet(dynamicClient)
	defer func() {
		if originalDynamicClient != nil {
			internalLib.SetDynamicClientSet(originalDynamicClient)
		}
	}()

	t.Run("CertManagerNotAvailable", func(t *testing.T) {
		kubeClient := k8sfake.NewSimpleClientset()

		err := createCertManagerResources(kubeClient, namespace)
		if err == nil {
			t.Error("Expected error when cert-manager CRDs not available")
		}
		if !strings.Contains(err.Error(), "cert-manager CRDs not available") {
			t.Errorf("Expected cert-manager CRD error, got: %v", err)
		}
	})

	t.Run("DynamicClientNotAvailable", func(t *testing.T) {
		// Simple test - we already test this scenario in main tests
		kubeClient := k8sfake.NewSimpleClientset()

		// Temporarily set dynamic client to nil
		internalLib.SetDynamicClientSet(nil)

		err := createCertManagerResources(kubeClient, namespace)
		if err == nil {
			t.Error("Expected error when dynamic client not available")
		}

		// Restore dynamic client
		internalLib.SetDynamicClientSet(dynamicClient)
	})
}

// TestCreateWebhookIssuer tests the Issuer resource creation
func TestCreateWebhookIssuer(t *testing.T) {
	namespace := "test-namespace"
	scheme := runtime.NewScheme()
	dynamicClient := dynamicfake.NewSimpleDynamicClient(scheme)

	t.Run("CreateNewIssuer", func(t *testing.T) {
		err := createWebhookIssuer(dynamicClient, namespace)
		if err != nil {
			t.Errorf("Expected no error creating issuer, got: %v", err)
		}

		// Verify issuer was created
		issuerGVR := schema.GroupVersionResource{
			Group:    "cert-manager.io",
			Version:  "v1",
			Resource: "issuers",
		}

		issuer, err := dynamicClient.Resource(issuerGVR).Namespace(namespace).Get(
			context.TODO(), "ako-vks-webhook-selfsigned-issuer", metav1.GetOptions{})
		if err != nil {
			t.Errorf("Expected issuer to be created, got error: %v", err)
		}

		// Verify issuer properties
		if issuer.GetName() != "ako-vks-webhook-selfsigned-issuer" {
			t.Errorf("Expected issuer name 'ako-vks-webhook-selfsigned-issuer', got: %s", issuer.GetName())
		}
		if issuer.GetNamespace() != namespace {
			t.Errorf("Expected issuer namespace '%s', got: %s", namespace, issuer.GetNamespace())
		}
	})

	t.Run("IssuerAlreadyExists", func(t *testing.T) {
		// First create issuer
		err := createWebhookIssuer(dynamicClient, namespace)
		if err != nil {
			t.Errorf("Expected no error creating first issuer, got: %v", err)
		}

		// Try to create again - should handle gracefully
		err = createWebhookIssuer(dynamicClient, namespace)
		if err != nil {
			t.Errorf("Expected no error when issuer already exists, got: %v", err)
		}
	})
}

// TestCreateWebhookCertificate tests the Certificate resource creation
func TestCreateWebhookCertificate(t *testing.T) {
	namespace := "test-namespace"
	scheme := runtime.NewScheme()
	dynamicClient := dynamicfake.NewSimpleDynamicClient(scheme)

	t.Run("CreateNewCertificate", func(t *testing.T) {
		err := createWebhookCertificate(dynamicClient, namespace)
		if err != nil {
			t.Errorf("Expected no error creating certificate, got: %v", err)
		}

		// Verify certificate was created
		certificateGVR := schema.GroupVersionResource{
			Group:    "cert-manager.io",
			Version:  "v1",
			Resource: "certificates",
		}

		cert, err := dynamicClient.Resource(certificateGVR).Namespace(namespace).Get(
			context.TODO(), "ako-vks-webhook-serving-cert", metav1.GetOptions{})
		if err != nil {
			t.Errorf("Expected certificate to be created, got error: %v", err)
		}

		// Verify certificate properties
		if cert.GetName() != "ako-vks-webhook-serving-cert" {
			t.Errorf("Expected certificate name 'ako-vks-webhook-serving-cert', got: %s", cert.GetName())
		}
		if cert.GetNamespace() != namespace {
			t.Errorf("Expected certificate namespace '%s', got: %s", namespace, cert.GetNamespace())
		}

		// Verify DNS names
		spec, found, err := unstructured.NestedMap(cert.Object, "spec")
		if err != nil || !found {
			t.Error("Expected certificate to have spec")
		}

		dnsNames, found, err := unstructured.NestedStringSlice(spec, "dnsNames")
		if err != nil || !found {
			t.Error("Expected certificate to have dnsNames")
		}

		expectedDNSNames := []string{
			"ako-vks-webhook-service." + namespace + ".svc",
			"ako-vks-webhook-service." + namespace + ".svc.cluster.local",
		}

		if len(dnsNames) != len(expectedDNSNames) {
			t.Errorf("Expected %d DNS names, got %d", len(expectedDNSNames), len(dnsNames))
		}

		for i, expected := range expectedDNSNames {
			if i < len(dnsNames) && dnsNames[i] != expected {
				t.Errorf("Expected DNS name[%d] '%s', got '%s'", i, expected, dnsNames[i])
			}
		}

		// Verify secret name
		secretName, found, err := unstructured.NestedString(spec, "secretName")
		if err != nil || !found {
			t.Error("Expected certificate to have secretName")
		}
		if secretName != "ako-vks-webhook-serving-cert" {
			t.Errorf("Expected secret name 'ako-vks-webhook-serving-cert', got: %s", secretName)
		}
	})

	t.Run("CertificateAlreadyExists", func(t *testing.T) {
		// First create certificate
		err := createWebhookCertificate(dynamicClient, namespace)
		if err != nil {
			t.Errorf("Expected no error creating first certificate, got: %v", err)
		}

		// Try to create again - should handle gracefully
		err = createWebhookCertificate(dynamicClient, namespace)
		if err != nil {
			t.Errorf("Expected no error when certificate already exists, got: %v", err)
		}
	})
}

// TestEnsureWebhookCertificates tests the complete certificate setup flow
func TestEnsureWebhookCertificates(t *testing.T) {
	// Set testing environment variable for shorter timeouts
	os.Setenv("TESTING", "true")
	defer os.Unsetenv("TESTING")

	scheme := runtime.NewScheme()
	dynamicClient := dynamicfake.NewSimpleDynamicClient(scheme)

	// Store original dynamic client and restore after test
	originalDynamicClient := internalLib.GetDynamicClientSet()
	internalLib.SetDynamicClientSet(dynamicClient)
	defer func() {
		if originalDynamicClient != nil {
			internalLib.SetDynamicClientSet(originalDynamicClient)
		}
	}()

	t.Run("CertManagerNotAvailable", func(t *testing.T) {
		kubeClient := k8sfake.NewSimpleClientset()

		stopCh := make(chan struct{})
		defer close(stopCh)
		err := ensureWebhookCertificates(kubeClient)
		if err == nil {
			t.Error("Expected error when cert-manager not available")
		}
		if !strings.Contains(err.Error(), "cert-manager not ready") {
			t.Errorf("Expected cert-manager error, got: %v", err)
		}
	})

	// We've already tested the scenarios where cert-manager is not available
	// The complex mock setup isn't worth the effort for this unit test
	// Integration tests would be better for full end-to-end scenarios
}

// TestVKSWebhookEnvironmentVariables tests environment variable handling
func TestVKSWebhookEnvironmentVariables(t *testing.T) {
	t.Run("CustomCertSecret", func(t *testing.T) {
		// Set custom cert secret name
		os.Setenv("VKS_WEBHOOK_CERT_SECRET", "custom-cert-secret")
		defer os.Unsetenv("VKS_WEBHOOK_CERT_SECRET")

		// Create secret with custom name
		secret := &corev1.Secret{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "custom-cert-secret",
				Namespace: "test-namespace",
			},
			Data: map[string][]byte{
				"tls.crt": []byte("fake-cert-data"),
				"tls.key": []byte("fake-key-data"),
				"ca.crt":  []byte("fake-ca-data"),
			},
		}

		kubeClient := k8sfake.NewSimpleClientset(secret)

		// Set testing environment for shorter timeout
		os.Setenv("TESTING", "true")
		defer os.Unsetenv("TESTING")

		err := waitForWebhookCertificates(kubeClient, "test-namespace")
		if err != nil {
			t.Errorf("Expected no error with custom cert secret, got: %v", err)
		}
	})
}

// TestVKSWebhookStartOnce tests that the webhook only starts once
func TestVKSWebhookStartOnce(t *testing.T) {
	// Test that StartVKSWebhook uses sync.Once properly
	kubeClient := k8sfake.NewSimpleClientset()
	stopCh := make(chan struct{})
	defer close(stopCh)

	// Create a counter to track how many times the setup is called
	setupCallCount := 0

	// Note: We can't easily test the sync.Once without refactoring the code
	// This is more of a design verification that the pattern is correct
	// The sync.Once ensures StartVKSWebhook can be called multiple times safely

	// Multiple calls should be safe (though we can't verify setup only runs once without refactoring)
	go func() {
		setupCallCount++
		StartVKSWebhook(kubeClient, stopCh)
	}()

	go func() {
		setupCallCount++
		StartVKSWebhook(kubeClient, stopCh)
	}()

	// Brief delay to allow goroutines to start
	time.Sleep(10 * time.Millisecond)

	// This test mainly verifies the code structure rather than runtime behavior
	// The sync.Once pattern is correct in the implementation
	if setupCallCount != 2 {
		t.Errorf("Expected 2 setup calls, got %d", setupCallCount)
	}
}

// TestWebhookConfigurationCABundle tests CA bundle handling
func TestWebhookConfigurationCABundle(t *testing.T) {
	kubeClient := k8sfake.NewSimpleClientset()

	t.Run("CreateWithCertManagerAnnotation", func(t *testing.T) {
		err := CreateWebhookConfiguration(kubeClient)
		if err != nil {
			t.Errorf("Expected no error creating webhook configuration, got: %v", err)
		}

		// Verify webhook configuration was created with cert-manager annotation
		webhook, err := kubeClient.AdmissionregistrationV1().MutatingWebhookConfigurations().Get(
			context.TODO(), "ako-vks-cluster-webhook", metav1.GetOptions{})
		if err != nil {
			t.Errorf("Expected webhook configuration to exist, got error: %v", err)
		}

		// Check for cert-manager annotation
		expectedAnnotation := "cert-manager.io/inject-ca-from"
		if webhook.Annotations == nil || webhook.Annotations[expectedAnnotation] == "" {
			t.Errorf("Expected webhook to have cert-manager CA injection annotation")
		}

		// Verify annotation value format (serviceNamespace comes from utils.GetAKONamespace())
		// In test context, this returns empty string, so we get "/ako-vks-webhook-serving-cert"
		expectedValue := "/ako-vks-webhook-serving-cert"
		if webhook.Annotations[expectedAnnotation] != expectedValue {
			t.Errorf("Expected annotation value '%s', got '%s'",
				expectedValue, webhook.Annotations[expectedAnnotation])
		}
	})
}

// TestFileOperations tests certificate file operations
func TestFileOperations(t *testing.T) {
	// Test the filesExist helper function with various scenarios
	t.Run("FilesExist", func(t *testing.T) {
		// Create temporary directory and files
		tempDir := t.TempDir()
		certPath := filepath.Join(tempDir, "tls.crt")
		keyPath := filepath.Join(tempDir, "tls.key")

		// Test when files don't exist
		if filesExist(certPath, keyPath) {
			t.Error("Expected filesExist to return false when files don't exist")
		}

		// Create cert file only
		err := os.WriteFile(certPath, []byte("cert"), 0644)
		if err != nil {
			t.Fatalf("Failed to create cert file: %v", err)
		}

		if filesExist(certPath, keyPath) {
			t.Error("Expected filesExist to return false when key file missing")
		}

		// Create key file
		err = os.WriteFile(keyPath, []byte("key"), 0644)
		if err != nil {
			t.Fatalf("Failed to create key file: %v", err)
		}

		if !filesExist(certPath, keyPath) {
			t.Error("Expected filesExist to return true when both files exist")
		}
	})
}

// TestErrorHandling tests various error scenarios
func TestErrorHandling(t *testing.T) {
	t.Run("CreateWebhookConfigurationError", func(t *testing.T) {
		// Test error handling in CreateWebhookConfiguration
		// This would require a more sophisticated mock, but we can test the happy path
		kubeClient := k8sfake.NewSimpleClientset()

		err := CreateWebhookConfiguration(kubeClient)
		if err != nil {
			t.Errorf("Expected no error in normal case, got: %v", err)
		}

		// Test idempotency - calling again should not error
		err = CreateWebhookConfiguration(kubeClient)
		if err != nil {
			t.Errorf("Expected no error when webhook already exists, got: %v", err)
		}
	})

	t.Run("CleanupNonExistentResources", func(t *testing.T) {
		// Test cleanup when resources don't exist
		kubeClient := k8sfake.NewSimpleClientset()

		// Should not error when cleaning up non-existent resources
		err := CleanupWebhookConfiguration(kubeClient)
		if err != nil {
			t.Errorf("Expected no error cleaning up non-existent webhook, got: %v", err)
		}

		err = CleanupCertManagerResources(kubeClient)
		if err != nil {
			t.Errorf("Expected no error cleaning up when cert-manager not available, got: %v", err)
		}

		err = CleanupAllWebhookResources(kubeClient)
		if err != nil {
			t.Errorf("Expected no error in comprehensive cleanup, got: %v", err)
		}
	})
}
